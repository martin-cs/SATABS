/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 33 "C:/NTDDK/inc/stdio.h"
#pragma pack(push,8)
#line 63 "C:/NTDDK/inc/stdio.h"
typedef unsigned int size_t;
#line 70 "C:/NTDDK/inc/stdio.h"
typedef unsigned short wchar_t;
#line 432
#pragma pack(pop)
#line 33 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"
#pragma pack(push,8)
#line 156
#pragma pack(pop)
#line 88 "C:/NTDDK/inc/basetsd.h"
typedef unsigned long ULONG_PTR;
#line 88 "C:/NTDDK/inc/basetsd.h"
typedef unsigned long *PULONG_PTR;
#line 288 "C:/NTDDK/inc/basetsd.h"
typedef ULONG_PTR SIZE_T;
#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void *PVOID;
#line 266 "C:/NTDDK/inc/ntdef.h"
typedef char CHAR;
#line 267 "C:/NTDDK/inc/ntdef.h"
typedef short SHORT;
#line 268 "C:/NTDDK/inc/ntdef.h"
typedef long LONG;
#line 276 "C:/NTDDK/inc/ntdef.h"
typedef wchar_t WCHAR;
#line 286 "C:/NTDDK/inc/ntdef.h"
typedef WCHAR *PWSTR;
#line 288 "C:/NTDDK/inc/ntdef.h"
typedef WCHAR const   *PCWSTR;
#line 293 "C:/NTDDK/inc/ntdef.h"
typedef CHAR *PCHAR;
#line 350 "C:/NTDDK/inc/ntdef.h"
typedef LONG *PLONG;
#line 360 "C:/NTDDK/inc/ntdef.h"
typedef unsigned char UCHAR;
#line 361 "C:/NTDDK/inc/ntdef.h"
typedef unsigned short USHORT;
#line 362 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ULONG;
#line 369 "C:/NTDDK/inc/ntdef.h"
typedef UCHAR *PUCHAR;
#line 371 "C:/NTDDK/inc/ntdef.h"
typedef ULONG *PULONG;
#line 394 "C:/NTDDK/inc/ntdef.h"
typedef void *HANDLE;
#line 400 "C:/NTDDK/inc/ntdef.h"
typedef HANDLE *PHANDLE;
#line 478 "C:/NTDDK/inc/ntdef.h"
typedef char CCHAR;
#line 479 "C:/NTDDK/inc/ntdef.h"
typedef short CSHORT;
#line 492 "C:/NTDDK/inc/ntdef.h"
typedef ULONG LCID;
#line 508 "C:/NTDDK/inc/ntdef.h"
typedef LONG NTSTATUS;
#line 621 "C:/NTDDK/inc/ntdef.h"
typedef long long LONGLONG;
#line 622 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long long ULONGLONG;
#line 649 "C:/NTDDK/inc/ntdef.h"
struct __anonstruct____missing_field_name_1 {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 649 "C:/NTDDK/inc/ntdef.h"
struct __anonstruct_u_2 {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 649 "C:/NTDDK/inc/ntdef.h"
union _LARGE_INTEGER {
   struct __anonstruct____missing_field_name_1 __annonCompField1 ;
   struct __anonstruct_u_2 u ;
   LONGLONG QuadPart ;
};
#line 649 "C:/NTDDK/inc/ntdef.h"
typedef union _LARGE_INTEGER LARGE_INTEGER;
#line 662 "C:/NTDDK/inc/ntdef.h"
typedef LARGE_INTEGER *PLARGE_INTEGER;
#line 668 "C:/NTDDK/inc/ntdef.h"
struct __anonstruct____missing_field_name_3 {
   ULONG LowPart ;
   ULONG HighPart ;
};
#line 668 "C:/NTDDK/inc/ntdef.h"
struct __anonstruct_u_4 {
   ULONG LowPart ;
   ULONG HighPart ;
};
#line 668 "C:/NTDDK/inc/ntdef.h"
union _ULARGE_INTEGER {
   struct __anonstruct____missing_field_name_3 __annonCompField2 ;
   struct __anonstruct_u_4 u ;
   ULONGLONG QuadPart ;
};
#line 668 "C:/NTDDK/inc/ntdef.h"
typedef union _ULARGE_INTEGER ULARGE_INTEGER;
#line 690 "C:/NTDDK/inc/ntdef.h"
struct _LUID {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 690 "C:/NTDDK/inc/ntdef.h"
typedef struct _LUID LUID;
#line 707 "C:/NTDDK/inc/ntdef.h"
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
#line 956
enum _EVENT_TYPE {
    NotificationEvent = 0,
    SynchronizationEvent = 1
} ;
#line 956 "C:/NTDDK/inc/ntdef.h"
typedef enum _EVENT_TYPE EVENT_TYPE;
#line 984 "C:/NTDDK/inc/ntdef.h"
typedef char const   *PCSZ;
#line 991 "C:/NTDDK/inc/ntdef.h"
struct _STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PCHAR Buffer ;
};
#line 991 "C:/NTDDK/inc/ntdef.h"
typedef struct _STRING STRING;
#line 999 "C:/NTDDK/inc/ntdef.h"
typedef STRING *PSTRING;
#line 1002 "C:/NTDDK/inc/ntdef.h"
typedef PSTRING PANSI_STRING;
#line 1027 "C:/NTDDK/inc/ntdef.h"
struct _UNICODE_STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PWSTR Buffer ;
};
#line 1027 "C:/NTDDK/inc/ntdef.h"
typedef struct _UNICODE_STRING UNICODE_STRING;
#line 1036 "C:/NTDDK/inc/ntdef.h"
typedef UNICODE_STRING *PUNICODE_STRING;
#line 1046 "C:/NTDDK/inc/ntdef.h"
typedef UCHAR BOOLEAN;
#line 1057 "C:/NTDDK/inc/ntdef.h"
struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink ;
   struct _LIST_ENTRY *Blink ;
};
#line 1057 "C:/NTDDK/inc/ntdef.h"
typedef struct _LIST_ENTRY LIST_ENTRY;
#line 1057 "C:/NTDDK/inc/ntdef.h"
typedef struct _LIST_ENTRY *PLIST_ENTRY;
#line 1067 "C:/NTDDK/inc/ntdef.h"
struct _SINGLE_LIST_ENTRY {
   struct _SINGLE_LIST_ENTRY *Next ;
};
#line 1067 "C:/NTDDK/inc/ntdef.h"
typedef struct _SINGLE_LIST_ENTRY SINGLE_LIST_ENTRY;
#line 1067 "C:/NTDDK/inc/ntdef.h"
typedef struct _SINGLE_LIST_ENTRY *PSINGLE_LIST_ENTRY;
#line 1078 "C:/NTDDK/inc/ntdef.h"
struct LIST_ENTRY32 {
   ULONG Flink ;
   ULONG Blink ;
};
#line 1078 "C:/NTDDK/inc/ntdef.h"
typedef struct LIST_ENTRY32 LIST_ENTRY32;
#line 1082 "C:/NTDDK/inc/ntdef.h"
typedef LIST_ENTRY32 *PLIST_ENTRY32;
#line 1084 "C:/NTDDK/inc/ntdef.h"
struct LIST_ENTRY64 {
   ULONGLONG Flink ;
   ULONGLONG Blink ;
};
#line 1084 "C:/NTDDK/inc/ntdef.h"
typedef struct LIST_ENTRY64 LIST_ENTRY64;
#line 1088 "C:/NTDDK/inc/ntdef.h"
typedef LIST_ENTRY64 *PLIST_ENTRY64;
#line 1173 "C:/NTDDK/inc/ntdef.h"
struct _OBJECT_ATTRIBUTES {
   ULONG Length ;
   HANDLE RootDirectory ;
   PUNICODE_STRING ObjectName ;
   ULONG Attributes ;
   PVOID SecurityDescriptor ;
   PVOID SecurityQualityOfService ;
};
#line 1173 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECT_ATTRIBUTES OBJECT_ATTRIBUTES;
#line 1181 "C:/NTDDK/inc/ntdef.h"
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
#line 17 "C:/NTDDK/inc/guiddef.h"
struct _GUID {
   unsigned long Data1 ;
   unsigned short Data2 ;
   unsigned short Data3 ;
   unsigned char Data4[8] ;
};
#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID GUID;
#line 1306 "C:/NTDDK/inc/ntdef.h"
typedef UCHAR KIRQL;
#line 1316
enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt = 2,
    NtProductServer = 3
} ;
#line 1316 "C:/NTDDK/inc/ntdef.h"
typedef enum _NT_PRODUCT_TYPE NT_PRODUCT_TYPE;
#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KTHREAD;
#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD *PKTHREAD;
#line 76
struct _ETHREAD;
#line 76 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ETHREAD *PETHREAD;
#line 77
struct _EPROCESS;
#line 77 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _EPROCESS *PEPROCESS;
#line 80
struct _IO_TIMER;
#line 80 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_TIMER *PIO_TIMER;
#line 81
struct _OBJECT_TYPE;
#line 81 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
#line 143 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct____missing_field_name_5 {
   SINGLE_LIST_ENTRY Next ;
   USHORT Depth ;
   USHORT Sequence ;
};
#line 143 "C:/NTDDK/inc/ddk/ntddk.h"
union _SLIST_HEADER {
   ULONGLONG Alignment ;
   struct __anonstruct____missing_field_name_5 __annonCompField3 ;
};
#line 143 "C:/NTDDK/inc/ddk/ntddk.h"
typedef union _SLIST_HEADER SLIST_HEADER;
#line 143 "C:/NTDDK/inc/ddk/ntddk.h"
typedef union _SLIST_HEADER *PSLIST_HEADER;
#line 204 "C:/NTDDK/inc/ddk/ntddk.h"
typedef CCHAR KPROCESSOR_MODE;
#line 222
struct _KAPC;
#line 222
struct _KAPC;
#line 224 "C:/NTDDK/inc/ddk/ntddk.h"
typedef void (*PKNORMAL_ROUTINE)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 );
#line 265 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KAPC {
   CSHORT Type ;
   CSHORT Size ;
   ULONG Spare0 ;
   struct _KTHREAD *Thread ;
   LIST_ENTRY ApcListEntry ;
   void (*KernelRoutine)(struct _KAPC *Apc , PKNORMAL_ROUTINE *NormalRoutine , PVOID *NormalContext ,
                         PVOID *SystemArgument1 , PVOID *SystemArgument2 ) ;
   void (*RundownRoutine)(struct _KAPC *Apc ) ;
   void (*NormalRoutine)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;
   PVOID NormalContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   CCHAR ApcStateIndex ;
   KPROCESSOR_MODE ApcMode ;
   BOOLEAN Inserted ;
};
#line 265 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KAPC KAPC;
#line 292
struct _KDPC;
#line 292
struct _KDPC;
#line 361 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KDPC {
   CSHORT Type ;
   UCHAR Number ;
   UCHAR Importance ;
   LIST_ENTRY DpcListEntry ;
   void (*DeferredRoutine)(struct _KDPC *Dpc , PVOID DeferredContext , PVOID SystemArgument1 ,
                           PVOID SystemArgument2 ) ;
   PVOID DeferredContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   PULONG_PTR Lock ;
};
#line 361 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KDPC KDPC;
#line 361 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KDPC *PKDPC;
#line 443 "C:/NTDDK/inc/ddk/ntddk.h"
struct _MDL {
   struct _MDL *Next ;
   CSHORT Size ;
   CSHORT MdlFlags ;
   struct _EPROCESS *Process ;
   PVOID MappedSystemVa ;
   PVOID StartVa ;
   ULONG ByteCount ;
   ULONG ByteOffset ;
};
#line 443 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _MDL MDL;
#line 443 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _MDL *PMDL;
#line 532 "C:/NTDDK/inc/ddk/ntddk.h"
typedef PVOID PACCESS_TOKEN;
#line 538 "C:/NTDDK/inc/ddk/ntddk.h"
typedef PVOID PSECURITY_DESCRIPTOR;
#line 546 "C:/NTDDK/inc/ddk/ntddk.h"
typedef ULONG ACCESS_MASK;
#line 27 "C:/NTDDK/inc/pshpack4.h"
#pragma pack(push,4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
struct _LUID_AND_ATTRIBUTES {
   LUID Luid ;
   ULONG Attributes ;
};
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES;
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 681 "C:/NTDDK/inc/ddk/ntddk.h"
struct _PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[1] ;
};
#line 681 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _PRIVILEGE_SET PRIVILEGE_SET;
#line 735
enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3
} ;
#line 735 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _SECURITY_IMPERSONATION_LEVEL SECURITY_IMPERSONATION_LEVEL;
#line 753 "C:/NTDDK/inc/ddk/ntddk.h"
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
#line 762 "C:/NTDDK/inc/ddk/ntddk.h"
struct _SECURITY_QUALITY_OF_SERVICE {
   ULONG Length ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode ;
   BOOLEAN EffectiveOnly ;
};
#line 762 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;
#line 782 "C:/NTDDK/inc/ddk/ntddk.h"
typedef ULONG SECURITY_INFORMATION;
#line 816 "C:/NTDDK/inc/ddk/ntddk.h"
typedef LONG KPRIORITY;
#line 824 "C:/NTDDK/inc/ddk/ntddk.h"
typedef ULONG_PTR KSPIN_LOCK;
#line 825 "C:/NTDDK/inc/ddk/ntddk.h"
typedef KSPIN_LOCK *PKSPIN_LOCK;
#line 1088 "C:/NTDDK/inc/ddk/ntddk.h"
struct _RTL_QUERY_REGISTRY_TABLE {
   NTSTATUS ( __attribute__((__stdcall__)) (*QueryRoutine))(PWSTR ValueName , ULONG ValueType ,
                                                            PVOID ValueData , ULONG ValueLength ,
                                                            PVOID Context , PVOID EntryContext ) ;
   ULONG Flags ;
   PWSTR Name ;
   PVOID EntryContext ;
   ULONG DefaultType ;
   PVOID DefaultData ;
   ULONG DefaultLength ;
};
#line 1088 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _RTL_QUERY_REGISTRY_TABLE RTL_QUERY_REGISTRY_TABLE;
#line 1088 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _RTL_QUERY_REGISTRY_TABLE *PRTL_QUERY_REGISTRY_TABLE;
#line 3648 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_6 {
   NTSTATUS Status ;
   PVOID Pointer ;
};
#line 3648 "C:/NTDDK/inc/ddk/ntddk.h"
struct _IO_STATUS_BLOCK {
   union __anonunion____missing_field_name_6 __annonCompField4 ;
   ULONG_PTR Information ;
};
#line 3648 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STATUS_BLOCK IO_STATUS_BLOCK;
#line 3648 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STATUS_BLOCK *PIO_STATUS_BLOCK;
#line 3685
enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileMaximumInformation = 37
} ;
#line 3685 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _FILE_INFORMATION_CLASS FILE_INFORMATION_CLASS;
#line 3731 "C:/NTDDK/inc/ddk/ntddk.h"
struct _FILE_BASIC_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   ULONG FileAttributes ;
};
#line 3731 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _FILE_BASIC_INFORMATION *PFILE_BASIC_INFORMATION;
#line 3739 "C:/NTDDK/inc/ddk/ntddk.h"
struct _FILE_STANDARD_INFORMATION {
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG NumberOfLinks ;
   BOOLEAN DeletePending ;
   BOOLEAN Directory ;
};
#line 3739 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _FILE_STANDARD_INFORMATION *PFILE_STANDARD_INFORMATION;
#line 3760 "C:/NTDDK/inc/ddk/ntddk.h"
struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG FileAttributes ;
};
#line 3760 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _FILE_NETWORK_OPEN_INFORMATION *PFILE_NETWORK_OPEN_INFORMATION;
#line 3798
enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsMaximumInformation = 9
} ;
#line 3798 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _FSINFOCLASS FS_INFORMATION_CLASS;
#line 3829
enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    MaximumInterfaceType = 16
} ;
#line 3829 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _INTERFACE_TYPE INTERFACE_TYPE;
#line 3829 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _INTERFACE_TYPE *PINTERFACE_TYPE;
#line 4141 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KEY_VALUE_FULL_INFORMATION {
   ULONG TitleIndex ;
   ULONG Type ;
   ULONG DataOffset ;
   ULONG DataLength ;
   ULONG NameLength ;
   WCHAR Name[1] ;
};
#line 4141 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KEY_VALUE_FULL_INFORMATION *PKEY_VALUE_FULL_INFORMATION;
#line 4294 "C:/NTDDK/inc/ddk/ntddk.h"
struct _CLIENT_ID {
   HANDLE UniqueProcess ;
   HANDLE UniqueThread ;
};
#line 4294 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CLIENT_ID CLIENT_ID;
#line 4298 "C:/NTDDK/inc/ddk/ntddk.h"
typedef CLIENT_ID *PCLIENT_ID;
#line 4587
enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} ;
#line 4587 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _SYSTEM_POWER_STATE SYSTEM_POWER_STATE;
#line 4598
enum __anonenum_POWER_ACTION_11 {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7
} ;
#line 4598 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum __anonenum_POWER_ACTION_11 POWER_ACTION;
#line 4609
enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5
} ;
#line 4609 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _DEVICE_POWER_STATE DEVICE_POWER_STATE;
#line 4618 "C:/NTDDK/inc/ddk/ntddk.h"
union _POWER_STATE {
   SYSTEM_POWER_STATE SystemState ;
   DEVICE_POWER_STATE DeviceState ;
};
#line 4618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef union _POWER_STATE POWER_STATE;
#line 4623
enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState = 1
} ;
#line 4623 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _POWER_STATE_TYPE POWER_STATE_TYPE;
#line 6994 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KSYSTEM_TIME {
   ULONG LowPart ;
   LONG High1Time ;
   LONG High2Time ;
};
#line 6994 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KSYSTEM_TIME KSYSTEM_TIME;
#line 7850
enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign = 0,
    NEC98x86 = 1,
    EndAlternatives = 2
} ;
#line 7850 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ALTERNATIVE_ARCHITECTURE_TYPE;
#line 7899 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KUSER_SHARED_DATA {
   ULONG volatile   TickCountLow ;
   ULONG TickCountMultiplier ;
   KSYSTEM_TIME volatile   InterruptTime ;
   KSYSTEM_TIME volatile   SystemTime ;
   KSYSTEM_TIME volatile   TimeZoneBias ;
   USHORT ImageNumberLow ;
   USHORT ImageNumberHigh ;
   WCHAR NtSystemRoot[260] ;
   ULONG MaxStackTraceDepth ;
   ULONG CryptoExponent ;
   ULONG TimeZoneId ;
   ULONG Reserved2[8] ;
   NT_PRODUCT_TYPE NtProductType ;
   BOOLEAN ProductTypeIsValid ;
   ULONG NtMajorVersion ;
   ULONG NtMinorVersion ;
   BOOLEAN ProcessorFeatures[64] ;
   ULONG Reserved1 ;
   ULONG Reserved3 ;
   ULONG volatile   TimeSlip ;
   ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture ;
   LARGE_INTEGER SystemExpirationDate ;
   ULONG SuiteMask ;
   BOOLEAN KdDebuggerEnabled ;
};
#line 7899 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KUSER_SHARED_DATA KUSER_SHARED_DATA;
#line 8211 "C:/NTDDK/inc/ddk/ntddk.h"
typedef PVOID PASSIGNED_RESOURCE;
#line 27 "C:/NTDDK/inc/pshpack4.h"
#pragma pack(push,4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Generic_16 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Port_17 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Interrupt_18 {
   ULONG Level ;
   ULONG Vector ;
   ULONG Affinity ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Memory_19 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Dma_20 {
   ULONG Channel ;
   ULONG Port ;
   ULONG Reserved1 ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_DevicePrivate_21 {
   ULONG Data[3] ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_BusNumber_22 {
   ULONG Start ;
   ULONG Length ;
   ULONG Reserved ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_DeviceSpecificData_23 {
   ULONG DataSize ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion_u_15 {
   struct __anonstruct_Generic_16 Generic ;
   struct __anonstruct_Port_17 Port ;
   struct __anonstruct_Interrupt_18 Interrupt ;
   struct __anonstruct_Memory_19 Memory ;
   struct __anonstruct_Dma_20 Dma ;
   struct __anonstruct_DevicePrivate_21 DevicePrivate ;
   struct __anonstruct_BusNumber_22 BusNumber ;
   struct __anonstruct_DeviceSpecificData_23 DeviceSpecificData ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
   UCHAR Type ;
   UCHAR ShareDisposition ;
   USHORT Flags ;
   union __anonunion_u_15 u ;
};
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR CM_PARTIAL_RESOURCE_DESCRIPTOR;
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
struct _CM_PARTIAL_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1] ;
};
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST CM_PARTIAL_RESOURCE_LIST;
#line 8443 "C:/NTDDK/inc/ddk/ntddk.h"
struct _CM_FULL_RESOURCE_DESCRIPTOR {
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   CM_PARTIAL_RESOURCE_LIST PartialResourceList ;
};
#line 8443 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR CM_FULL_RESOURCE_DESCRIPTOR;
#line 8443 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR *PCM_FULL_RESOURCE_DESCRIPTOR;
#line 8454 "C:/NTDDK/inc/ddk/ntddk.h"
struct _CM_RESOURCE_LIST {
   ULONG Count ;
   CM_FULL_RESOURCE_DESCRIPTOR List[1] ;
};
#line 8454 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_RESOURCE_LIST *PCM_RESOURCE_LIST;
#line 27 "C:/NTDDK/inc/pshpack1.h"
#pragma pack(push,1)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 8844 "C:/NTDDK/inc/ddk/ntddk.h"
struct _CM_FLOPPY_DEVICE_DATA {
   USHORT Version ;
   USHORT Revision ;
   CHAR Size[8] ;
   ULONG MaxDensity ;
   ULONG MountDensity ;
   UCHAR StepRateHeadUnloadTime ;
   UCHAR HeadLoadTime ;
   UCHAR MotorOffTime ;
   UCHAR SectorLengthCode ;
   UCHAR SectorPerTrack ;
   UCHAR ReadWriteGapLength ;
   UCHAR DataTransferLength ;
   UCHAR FormatGapLength ;
   UCHAR FormatFillCharacter ;
   UCHAR HeadSettleTime ;
   UCHAR MotorSettleTime ;
   UCHAR MaximumTrackValue ;
   UCHAR DataTransferRate ;
};
#line 8844 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_FLOPPY_DEVICE_DATA *PCM_FLOPPY_DEVICE_DATA;
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Port_25 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Memory_26 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Interrupt_27 {
   ULONG MinimumVector ;
   ULONG MaximumVector ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Dma_28 {
   ULONG MinimumChannel ;
   ULONG MaximumChannel ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Generic_29 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_DevicePrivate_30 {
   ULONG Data[3] ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_BusNumber_31 {
   ULONG Length ;
   ULONG MinBusNumber ;
   ULONG MaxBusNumber ;
   ULONG Reserved ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_AssignedResource_32 {
   PASSIGNED_RESOURCE AssignedResource ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_SubAllocateFrom_33 {
   UCHAR Type ;
   UCHAR Reserved[3] ;
   PASSIGNED_RESOURCE AssignedResource ;
   PHYSICAL_ADDRESS Transformation ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_ConfigData_34 {
   ULONG Priority ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion_u_24 {
   struct __anonstruct_Port_25 Port ;
   struct __anonstruct_Memory_26 Memory ;
   struct __anonstruct_Interrupt_27 Interrupt ;
   struct __anonstruct_Dma_28 Dma ;
   struct __anonstruct_Generic_29 Generic ;
   struct __anonstruct_DevicePrivate_30 DevicePrivate ;
   struct __anonstruct_BusNumber_31 BusNumber ;
   struct __anonstruct_AssignedResource_32 AssignedResource ;
   struct __anonstruct_SubAllocateFrom_33 SubAllocateFrom ;
   struct __anonstruct_ConfigData_34 ConfigData ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
struct _IO_RESOURCE_DESCRIPTOR {
   UCHAR Option ;
   UCHAR Type ;
   UCHAR ShareDisposition ;
   UCHAR Spare1 ;
   USHORT Flags ;
   USHORT Spare2 ;
   union __anonunion_u_24 u ;
};
#line 8944 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_RESOURCE_DESCRIPTOR IO_RESOURCE_DESCRIPTOR;
#line 9027 "C:/NTDDK/inc/ddk/ntddk.h"
struct _IO_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   IO_RESOURCE_DESCRIPTOR Descriptors[1] ;
};
#line 9027 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_RESOURCE_LIST IO_RESOURCE_LIST;
#line 9036 "C:/NTDDK/inc/ddk/ntddk.h"
struct _IO_RESOURCE_REQUIREMENTS_LIST {
   ULONG ListSize ;
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   ULONG SlotNumber ;
   ULONG Reserved[3] ;
   ULONG AlternativeLists ;
   IO_RESOURCE_LIST List[1] ;
};
#line 9036 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST *PIO_RESOURCE_REQUIREMENTS_LIST;
#line 9111
enum _CONFIGURATION_TYPE {
    ArcSystem = 0,
    CentralProcessor = 1,
    FloatingPointProcessor = 2,
    PrimaryIcache = 3,
    PrimaryDcache = 4,
    SecondaryIcache = 5,
    SecondaryDcache = 6,
    SecondaryCache = 7,
    EisaAdapter = 8,
    TcAdapter = 9,
    ScsiAdapter = 10,
    DtiAdapter = 11,
    MultiFunctionAdapter = 12,
    DiskController = 13,
    TapeController = 14,
    CdromController = 15,
    WormController = 16,
    SerialController = 17,
    NetworkController = 18,
    DisplayController = 19,
    ParallelController = 20,
    PointerController = 21,
    KeyboardController = 22,
    AudioController = 23,
    OtherController = 24,
    DiskPeripheral = 25,
    FloppyDiskPeripheral = 26,
    TapePeripheral = 27,
    ModemPeripheral = 28,
    MonitorPeripheral = 29,
    PrinterPeripheral = 30,
    PointerPeripheral = 31,
    KeyboardPeripheral = 32,
    TerminalPeripheral = 33,
    OtherPeripheral = 34,
    LinePeripheral = 35,
    NetworkPeripheral = 36,
    SystemMemory = 37,
    DockingInformation = 38,
    RealModeIrqRoutingTable = 39,
    MaximumType = 40
} ;
#line 9111 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _CONFIGURATION_TYPE CONFIGURATION_TYPE;
#line 9111 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _CONFIGURATION_TYPE *PCONFIGURATION_TYPE;
#line 9170
enum _KWAIT_REASON {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrEventPair = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    Spare2 = 21,
    Spare3 = 22,
    Spare4 = 23,
    Spare5 = 24,
    Spare6 = 25,
    WrKernel = 26,
    MaximumWaitReason = 27
} ;
#line 9170 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _KWAIT_REASON KWAIT_REASON;
#line 9207 "C:/NTDDK/inc/ddk/ntddk.h"
struct _DISPATCHER_HEADER {
   UCHAR Type ;
   UCHAR Absolute ;
   UCHAR Size ;
   UCHAR Inserted ;
   LONG SignalState ;
   LIST_ENTRY WaitListHead ;
};
#line 9207 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _DISPATCHER_HEADER DISPATCHER_HEADER;
#line 9244 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KDEVICE_QUEUE {
   CSHORT Type ;
   CSHORT Size ;
   LIST_ENTRY DeviceListHead ;
   KSPIN_LOCK Lock ;
   BOOLEAN Busy ;
};
#line 9244 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KDEVICE_QUEUE KDEVICE_QUEUE;
#line 9252 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KDEVICE_QUEUE_ENTRY {
   LIST_ENTRY DeviceListEntry ;
   ULONG SortKey ;
   BOOLEAN Inserted ;
};
#line 9252 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KDEVICE_QUEUE_ENTRY KDEVICE_QUEUE_ENTRY;
#line 9263 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KEVENT {
   DISPATCHER_HEADER Header ;
};
#line 9263 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KEVENT KEVENT;
#line 9263 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KEVENT *PKEVENT;
#line 9263 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KEVENT *PRKEVENT;
#line 9294 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KSEMAPHORE {
   DISPATCHER_HEADER Header ;
   LONG Limit ;
};
#line 9294 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KSEMAPHORE KSEMAPHORE;
#line 9294 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KSEMAPHORE *PKSEMAPHORE;
#line 9294 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KSEMAPHORE *PRKSEMAPHORE;
#line 10057
enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6
} ;
#line 10057 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _MEMORY_CACHING_TYPE MEMORY_CACHING_TYPE;
#line 10115
enum _POOL_TYPE {
    NonPagedPool = 0,
    PagedPool = 1,
    NonPagedPoolMustSucceed = 2,
    DontUseThisType = 3,
    NonPagedPoolCacheAligned = 4,
    PagedPoolCacheAligned = 5,
    NonPagedPoolCacheAlignedMustS = 6,
    MaxPoolType = 7,
    NonPagedPoolSession = 32,
    PagedPoolSession = 33,
    NonPagedPoolMustSucceedSession = 34,
    DontUseThisTypeSession = 35,
    NonPagedPoolCacheAlignedSession = 36,
    PagedPoolCacheAlignedSession = 37,
    NonPagedPoolCacheAlignedMustSSession = 38
} ;
#line 10115 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _POOL_TYPE POOL_TYPE;
#line 10247 "C:/NTDDK/inc/ddk/ntddk.h"
struct _FAST_MUTEX {
   LONG Count ;
   PKTHREAD Owner ;
   ULONG Contention ;
   KEVENT Event ;
   ULONG OldIrql ;
};
#line 10247 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _FAST_MUTEX FAST_MUTEX;
#line 10247 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _FAST_MUTEX *PFAST_MUTEX;
#line 10588 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_35 {
   ULONG AllocateMisses ;
   ULONG AllocateHits ;
};
#line 10588 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_36 {
   ULONG FreeMisses ;
   ULONG FreeHits ;
};
#line 10588 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_37 {
   ULONG LastAllocateMisses ;
   ULONG LastAllocateHits ;
};
#line 10588 "C:/NTDDK/inc/ddk/ntddk.h"
struct _GENERAL_LOOKASIDE {
   SLIST_HEADER ListHead ;
   USHORT Depth ;
   USHORT MaximumDepth ;
   ULONG TotalAllocates ;
   union __anonunion____missing_field_name_35 __annonCompField7 ;
   ULONG TotalFrees ;
   union __anonunion____missing_field_name_36 __annonCompField8 ;
   POOL_TYPE Type ;
   ULONG Tag ;
   ULONG Size ;
   PVOID (*Allocate)(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) ;
   void (*Free)(PVOID Buffer ) ;
   LIST_ENTRY ListEntry ;
   ULONG LastTotalAllocates ;
   union __anonunion____missing_field_name_37 __annonCompField9 ;
   ULONG Future[2] ;
};
#line 10588 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _GENERAL_LOOKASIDE GENERAL_LOOKASIDE;
#line 10619 "C:/NTDDK/inc/ddk/ntddk.h"
struct _NPAGED_LOOKASIDE_LIST {
   GENERAL_LOOKASIDE L ;
   KSPIN_LOCK Lock ;
};
#line 10619 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _NPAGED_LOOKASIDE_LIST *PNPAGED_LOOKASIDE_LIST;
#line 11156 "C:/NTDDK/inc/ddk/ntddk.h"
typedef ULONG_PTR ERESOURCE_THREAD;
#line 11159 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_38 {
   LONG OwnerCount ;
   ULONG TableSize ;
};
#line 11159 "C:/NTDDK/inc/ddk/ntddk.h"
struct _OWNER_ENTRY {
   ERESOURCE_THREAD OwnerThread ;
   union __anonunion____missing_field_name_38 __annonCompField10 ;
};
#line 11159 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _OWNER_ENTRY OWNER_ENTRY;
#line 11159 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _OWNER_ENTRY *POWNER_ENTRY;
#line 11168 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_39 {
   PVOID Address ;
   ULONG_PTR CreatorBackTraceIndex ;
};
#line 11168 "C:/NTDDK/inc/ddk/ntddk.h"
struct _ERESOURCE {
   LIST_ENTRY SystemResourcesList ;
   POWNER_ENTRY OwnerTable ;
   SHORT ActiveCount ;
   USHORT Flag ;
   PKSEMAPHORE SharedWaiters ;
   PKEVENT ExclusiveWaiters ;
   OWNER_ENTRY OwnerThreads[2] ;
   ULONG ContentionCount ;
   USHORT NumberOfSharedWaiters ;
   USHORT NumberOfExclusiveWaiters ;
   union __anonunion____missing_field_name_39 __annonCompField11 ;
   KSPIN_LOCK SpinLock ;
};
#line 11884
enum _LOCK_OPERATION {
    IoReadAccess = 0,
    IoWriteAccess = 1,
    IoModifyAccess = 2
} ;
#line 11884 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _LOCK_OPERATION LOCK_OPERATION;
#line 11970
enum _MM_PAGE_PRIORITY {
    LowPagePriority = 0,
    NormalPagePriority = 16,
    HighPagePriority = 32
} ;
#line 11970 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _MM_PAGE_PRIORITY MM_PAGE_PRIORITY;
#line 12399
struct _DRIVER_OBJECT;
#line 12399
struct _DRIVER_OBJECT;
#line 12426 "C:/NTDDK/inc/ddk/ntddk.h"
struct _SECURITY_SUBJECT_CONTEXT {
   PACCESS_TOKEN ClientToken ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   PACCESS_TOKEN PrimaryToken ;
   PVOID ProcessAuditId ;
};
#line 12426 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SECURITY_SUBJECT_CONTEXT SECURITY_SUBJECT_CONTEXT;
#line 12448 "C:/NTDDK/inc/ddk/ntddk.h"
struct _INITIAL_PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[3] ;
};
#line 12448 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _INITIAL_PRIVILEGE_SET INITIAL_PRIVILEGE_SET;
#line 12462 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion_Privileges_40 {
   INITIAL_PRIVILEGE_SET InitialPrivilegeSet ;
   PRIVILEGE_SET PrivilegeSet ;
};
#line 12462 "C:/NTDDK/inc/ddk/ntddk.h"
struct _ACCESS_STATE {
   LUID OperationID ;
   BOOLEAN SecurityEvaluated ;
   BOOLEAN GenerateAudit ;
   BOOLEAN GenerateOnClose ;
   BOOLEAN PrivilegesAllocated ;
   ULONG Flags ;
   ACCESS_MASK RemainingDesiredAccess ;
   ACCESS_MASK PreviouslyGrantedAccess ;
   ACCESS_MASK OriginalDesiredAccess ;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   PVOID AuxData ;
   union __anonunion_Privileges_40 Privileges ;
   BOOLEAN AuditPrivileges ;
   UNICODE_STRING ObjectName ;
   UNICODE_STRING ObjectTypeName ;
};
#line 12462 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACCESS_STATE *PACCESS_STATE;
#line 12906
struct _DEVICE_OBJECT;
#line 12906
struct _DEVICE_OBJECT;
#line 12908
struct _DRIVER_OBJECT;
#line 12911
struct _FILE_OBJECT;
#line 12911
struct _FILE_OBJECT;
#line 12912
struct _IRP;
#line 12912
struct _IRP;
#line 12913
struct _SCSI_REQUEST_BLOCK;
#line 12913
struct _SCSI_REQUEST_BLOCK;
#line 12979 "C:/NTDDK/inc/ddk/ntddk.h"
typedef NTSTATUS (*PDRIVER_DISPATCH)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp );
#line 13289
struct _COMPRESSED_DATA_INFO;
#line 13350 "C:/NTDDK/inc/ddk/ntddk.h"
struct _FAST_IO_DISPATCH {
   ULONG SizeOfFastIoDispatch ;
   BOOLEAN (*FastIoCheckIfPossible)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , BOOLEAN Wait , ULONG LockKey ,
                                    BOOLEAN CheckForReadOperation , PIO_STATUS_BLOCK IoStatus ,
                                    struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                         PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                          ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                          PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryBasicInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                   PFILE_BASIC_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                   struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryStandardInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                      PFILE_STANDARD_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoLock)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                         BOOLEAN FailImmediately , BOOLEAN ExclusiveLock , PIO_STATUS_BLOCK IoStatus ,
                         struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockSingle)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                 PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                                 PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAll)(struct _FILE_OBJECT *FileObject , PEPROCESS ProcessId ,
                              PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAllByKey)(struct _FILE_OBJECT *FileObject , PVOID ProcessId ,
                                   ULONG Key , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoDeviceControl)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                  PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                  ULONG OutputBufferLength , ULONG IoControlCode ,
                                  PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   void (*AcquireFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*ReleaseFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*FastIoDetachDevice)(struct _DEVICE_OBJECT *SourceDevice , struct _DEVICE_OBJECT *TargetDevice ) ;
   BOOLEAN (*FastIoQueryNetworkOpenInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                         struct _FILE_NETWORK_OPEN_INFORMATION *Buffer ,
                                         struct _IO_STATUS_BLOCK *IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForModWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER EndingOffset ,
                                  struct _ERESOURCE **ResourceToRelease , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                      ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadComplete)(struct _FILE_OBJECT *FileObject , PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*PrepareMdlWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                              ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteComplete)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                               PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoReadCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                   ULONG Length , ULONG LockKey , PVOID Buffer , PMDL *MdlChain ,
                                   PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                   ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWriteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , ULONG LockKey , PVOID Buffer ,
                                    PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                    ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadCompleteCompressed)(struct _FILE_OBJECT *FileObject , PMDL MdlChain ,
                                        struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteCompleteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                         PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryOpen)(struct _IRP *Irp , PFILE_NETWORK_OPEN_INFORMATION NetworkInformation ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForModWrite)(struct _FILE_OBJECT *FileObject , struct _ERESOURCE *ResourceToRelease ,
                                  struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
};
#line 13350 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _FAST_IO_DISPATCH *PFAST_IO_DISPATCH;
#line 13386
enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3
} ;
#line 13386 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _IO_ALLOCATION_ACTION IO_ALLOCATION_ACTION;
#line 13410 "C:/NTDDK/inc/ddk/ntddk.h"
struct _IO_SECURITY_CONTEXT {
   PSECURITY_QUALITY_OF_SERVICE SecurityQos ;
   PACCESS_STATE AccessState ;
   ACCESS_MASK DesiredAccess ;
   ULONG FullCreateOptions ;
};
#line 13410 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_SECURITY_CONTEXT *PIO_SECURITY_CONTEXT;
#line 13434 "C:/NTDDK/inc/ddk/ntddk.h"
struct _VPB {
   CSHORT Type ;
   CSHORT Size ;
   USHORT Flags ;
   USHORT VolumeLabelLength ;
   struct _DEVICE_OBJECT *DeviceObject ;
   struct _DEVICE_OBJECT *RealDevice ;
   ULONG SerialNumber ;
   ULONG ReferenceCount ;
   WCHAR VolumeLabel[(32U * sizeof(WCHAR )) / sizeof(WCHAR )] ;
};
#line 13434 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _VPB *PVPB;
#line 13491 "C:/NTDDK/inc/ddk/ntddk.h"
struct _WAIT_CONTEXT_BLOCK {
   KDEVICE_QUEUE_ENTRY WaitQueueEntry ;
   IO_ALLOCATION_ACTION (*DeviceRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ,
                                         PVOID MapRegisterBase , PVOID Context ) ;
   PVOID DeviceContext ;
   ULONG NumberOfMapRegisters ;
   PVOID DeviceObject ;
   PVOID CurrentIrp ;
   PKDPC BufferChainingDpc ;
};
#line 13491 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _WAIT_CONTEXT_BLOCK WAIT_CONTEXT_BLOCK;
#line 13537 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion_Queue_43 {
   LIST_ENTRY ListEntry ;
   WAIT_CONTEXT_BLOCK Wcb ;
};
#line 13537
struct _DEVOBJ_EXTENSION;
#line 13537 "C:/NTDDK/inc/ddk/ntddk.h"
struct _DEVICE_OBJECT {
   CSHORT Type ;
   USHORT Size ;
   LONG ReferenceCount ;
   struct _DRIVER_OBJECT *DriverObject ;
   struct _DEVICE_OBJECT *NextDevice ;
   struct _DEVICE_OBJECT *AttachedDevice ;
   struct _IRP *CurrentIrp ;
   PIO_TIMER Timer ;
   ULONG Flags ;
   ULONG Characteristics ;
   PVPB Vpb ;
   PVOID DeviceExtension ;
   ULONG DeviceType ;
   CCHAR StackSize ;
   union __anonunion_Queue_43 Queue ;
   ULONG AlignmentRequirement ;
   KDEVICE_QUEUE DeviceQueue ;
   KDPC Dpc ;
   ULONG ActiveThreadCount ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   KEVENT DeviceLock ;
   USHORT SectorSize ;
   USHORT Spare1 ;
   struct _DEVOBJ_EXTENSION *DeviceObjectExtension ;
   PVOID Reserved ;
};
#line 13537 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _DEVICE_OBJECT DEVICE_OBJECT;
#line 13575 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
#line 13580 "C:/NTDDK/inc/ddk/ntddk.h"
struct _DEVOBJ_EXTENSION {
   CSHORT Type ;
   USHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 13608 "C:/NTDDK/inc/ddk/ntddk.h"
struct _DRIVER_EXTENSION {
   struct _DRIVER_OBJECT *DriverObject ;
   NTSTATUS (*AddDevice)(struct _DRIVER_OBJECT *DriverObject , struct _DEVICE_OBJECT *PhysicalDeviceObject ) ;
   ULONG Count ;
   UNICODE_STRING ServiceKeyName ;
};
#line 13608 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _DRIVER_EXTENSION *PDRIVER_EXTENSION;
#line 13645 "C:/NTDDK/inc/ddk/ntddk.h"
struct _DRIVER_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   ULONG Flags ;
   PVOID DriverStart ;
   ULONG DriverSize ;
   PVOID DriverSection ;
   PDRIVER_EXTENSION DriverExtension ;
   UNICODE_STRING DriverName ;
   PUNICODE_STRING HardwareDatabase ;
   PFAST_IO_DISPATCH FastIoDispatch ;
   NTSTATUS (*DriverInit)(struct _DRIVER_OBJECT *DriverObject , PUNICODE_STRING RegistryPath ) ;
   void (*DriverStartIo)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   void (*DriverUnload)(struct _DRIVER_OBJECT *DriverObject ) ;
   PDRIVER_DISPATCH MajorFunction[28] ;
};
#line 13645 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _DRIVER_OBJECT DRIVER_OBJECT;
#line 13706 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;
#line 13715 "C:/NTDDK/inc/ddk/ntddk.h"
struct _SECTION_OBJECT_POINTERS {
   PVOID DataSectionObject ;
   PVOID SharedCacheMap ;
   PVOID ImageSectionObject ;
};
#line 13715 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SECTION_OBJECT_POINTERS SECTION_OBJECT_POINTERS;
#line 13720 "C:/NTDDK/inc/ddk/ntddk.h"
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;
#line 13726 "C:/NTDDK/inc/ddk/ntddk.h"
struct _IO_COMPLETION_CONTEXT {
   PVOID Port ;
   PVOID Key ;
};
#line 13726 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_COMPLETION_CONTEXT *PIO_COMPLETION_CONTEXT;
#line 13759 "C:/NTDDK/inc/ddk/ntddk.h"
struct _FILE_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   PVPB Vpb ;
   PVOID FsContext ;
   PVOID FsContext2 ;
   PSECTION_OBJECT_POINTERS SectionObjectPointer ;
   PVOID PrivateCacheMap ;
   NTSTATUS FinalStatus ;
   struct _FILE_OBJECT *RelatedFileObject ;
   BOOLEAN LockOperation ;
   BOOLEAN DeletePending ;
   BOOLEAN ReadAccess ;
   BOOLEAN WriteAccess ;
   BOOLEAN DeleteAccess ;
   BOOLEAN SharedRead ;
   BOOLEAN SharedWrite ;
   BOOLEAN SharedDelete ;
   ULONG Flags ;
   UNICODE_STRING FileName ;
   LARGE_INTEGER CurrentByteOffset ;
   ULONG Waiters ;
   ULONG Busy ;
   PVOID LastLock ;
   KEVENT Lock ;
   KEVENT Event ;
   PIO_COMPLETION_CONTEXT CompletionContext ;
};
#line 13788 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _FILE_OBJECT *PFILE_OBJECT;
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion_AssociatedIrp_44 {
   struct _IRP *MasterIrp ;
   LONG IrpCount ;
   PVOID SystemBuffer ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_AsynchronousParameters_46 {
   void ( __attribute__((__stdcall__)) (*UserApcRoutine))(PVOID ApcContext , PIO_STATUS_BLOCK IoStatusBlock ,
                                                          ULONG Reserved ) ;
   PVOID UserApcContext ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion_Overlay_45 {
   struct __anonstruct_AsynchronousParameters_46 AsynchronousParameters ;
   LARGE_INTEGER AllocationSize ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct____missing_field_name_50 {
   PVOID DriverContext[4] ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_49 {
   KDEVICE_QUEUE_ENTRY DeviceQueueEntry ;
   struct __anonstruct____missing_field_name_50 __annonCompField14 ;
};
#line 13828
struct _IO_STACK_LOCATION;
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_52 {
   struct _IO_STACK_LOCATION *CurrentStackLocation ;
   ULONG PacketType ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct____missing_field_name_51 {
   LIST_ENTRY ListEntry ;
   union __anonunion____missing_field_name_52 __annonCompField16 ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Overlay_48 {
   union __anonunion____missing_field_name_49 __annonCompField15 ;
   PETHREAD Thread ;
   PCHAR AuxiliaryBuffer ;
   struct __anonstruct____missing_field_name_51 __annonCompField17 ;
   PFILE_OBJECT OriginalFileObject ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion_Tail_47 {
   struct __anonstruct_Overlay_48 Overlay ;
   KAPC Apc ;
   PVOID CompletionKey ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
struct _IRP {
   CSHORT Type ;
   USHORT Size ;
   PMDL MdlAddress ;
   ULONG Flags ;
   union __anonunion_AssociatedIrp_44 AssociatedIrp ;
   LIST_ENTRY ThreadListEntry ;
   IO_STATUS_BLOCK IoStatus ;
   KPROCESSOR_MODE RequestorMode ;
   BOOLEAN PendingReturned ;
   CHAR StackCount ;
   CHAR CurrentLocation ;
   BOOLEAN Cancel ;
   KIRQL CancelIrql ;
   CCHAR ApcEnvironment ;
   UCHAR AllocationFlags ;
   PIO_STATUS_BLOCK UserIosb ;
   PKEVENT UserEvent ;
   union __anonunion_Overlay_45 Overlay ;
   void (*CancelRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   PVOID UserBuffer ;
   union __anonunion_Tail_47 Tail ;
};
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IRP IRP;
#line 13828 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IRP *PIRP;
#line 14163
enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4
} ;
#line 14163 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _DEVICE_RELATION_TYPE DEVICE_RELATION_TYPE;
#line 14176
enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3
} ;
#line 14176 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE DEVICE_USAGE_NOTIFICATION_TYPE;
#line 14185 "C:/NTDDK/inc/ddk/ntddk.h"
struct _INTERFACE {
   USHORT Size ;
   USHORT Version ;
   PVOID Context ;
   void (*InterfaceReference)(PVOID Context ) ;
   void (*InterfaceDereference)(PVOID Context ) ;
};
#line 14185 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _INTERFACE *PINTERFACE;
#line 14196 "C:/NTDDK/inc/ddk/ntddk.h"
struct _DEVICE_CAPABILITIES {
   USHORT Size ;
   USHORT Version ;
   ULONG DeviceD1 : 1 ;
   ULONG DeviceD2 : 1 ;
   ULONG LockSupported : 1 ;
   ULONG EjectSupported : 1 ;
   ULONG Removable : 1 ;
   ULONG DockDevice : 1 ;
   ULONG UniqueID : 1 ;
   ULONG SilentInstall : 1 ;
   ULONG RawDeviceOK : 1 ;
   ULONG SurpriseRemovalOK : 1 ;
   ULONG WakeFromD0 : 1 ;
   ULONG WakeFromD1 : 1 ;
   ULONG WakeFromD2 : 1 ;
   ULONG WakeFromD3 : 1 ;
   ULONG HardwareDisabled : 1 ;
   ULONG NonDynamic : 1 ;
   ULONG WarmEjectSupported : 1 ;
   ULONG Reserved : 15 ;
   ULONG Address ;
   ULONG UINumber ;
   DEVICE_POWER_STATE DeviceState[7] ;
   SYSTEM_POWER_STATE SystemWake ;
   DEVICE_POWER_STATE DeviceWake ;
   ULONG D1Latency ;
   ULONG D2Latency ;
   ULONG D3Latency ;
};
#line 14196 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _DEVICE_CAPABILITIES *PDEVICE_CAPABILITIES;
#line 14229 "C:/NTDDK/inc/ddk/ntddk.h"
struct _POWER_SEQUENCE {
   ULONG SequenceD1 ;
   ULONG SequenceD2 ;
   ULONG SequenceD3 ;
};
#line 14229 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _POWER_SEQUENCE *PPOWER_SEQUENCE;
#line 14235
enum __anonenum_BUS_QUERY_ID_TYPE_53 {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4
} ;
#line 14235 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum __anonenum_BUS_QUERY_ID_TYPE_53 BUS_QUERY_ID_TYPE;
#line 14252
enum __anonenum_DEVICE_TEXT_TYPE_54 {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1
} ;
#line 14252 "C:/NTDDK/inc/ddk/ntddk.h"
typedef enum __anonenum_DEVICE_TEXT_TYPE_54 DEVICE_TEXT_TYPE;
#line 27 "C:/NTDDK/inc/pshpack4.h"
#pragma pack(push,4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Create_56 {
   PIO_SECURITY_CONTEXT SecurityContext ;
   ULONG Options ;
   USHORT FileAttributes ;
   USHORT ShareAccess ;
   ULONG EaLength ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Read_57 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Write_58 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_QueryFile_59 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct____missing_field_name_62 {
   BOOLEAN ReplaceIfExists ;
   BOOLEAN AdvanceOnly ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion____missing_field_name_61 {
   struct __anonstruct____missing_field_name_62 __annonCompField18 ;
   ULONG ClusterCount ;
   HANDLE DeleteHandle ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_SetFile_60 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
   PFILE_OBJECT FileObject ;
   union __anonunion____missing_field_name_61 __annonCompField19 ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_QueryVolume_63 {
   ULONG Length ;
   FS_INFORMATION_CLASS FsInformationClass ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_DeviceIoControl_64 {
   ULONG OutputBufferLength ;
   ULONG InputBufferLength ;
   ULONG IoControlCode ;
   PVOID Type3InputBuffer ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_QuerySecurity_65 {
   SECURITY_INFORMATION SecurityInformation ;
   ULONG Length ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_SetSecurity_66 {
   SECURITY_INFORMATION SecurityInformation ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_MountVolume_67 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_VerifyVolume_68 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Scsi_69 {
   struct _SCSI_REQUEST_BLOCK *Srb ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_QueryDeviceRelations_70 {
   DEVICE_RELATION_TYPE Type ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_QueryInterface_71 {
   GUID const   *InterfaceType ;
   USHORT Size ;
   USHORT Version ;
   PINTERFACE Interface ;
   PVOID InterfaceSpecificData ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_DeviceCapabilities_72 {
   PDEVICE_CAPABILITIES Capabilities ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_FilterResourceRequirements_73 {
   PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_ReadWriteConfig_74 {
   ULONG WhichSpace ;
   PVOID Buffer ;
   ULONG Offset ;
   ULONG Length ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_SetLock_75 {
   BOOLEAN Lock ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_QueryId_76 {
   BUS_QUERY_ID_TYPE IdType ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_QueryDeviceText_77 {
   DEVICE_TEXT_TYPE DeviceTextType ;
   LCID LocaleId ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_UsageNotification_78 {
   BOOLEAN InPath ;
   BOOLEAN Reserved[3] ;
   DEVICE_USAGE_NOTIFICATION_TYPE Type ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_WaitWake_79 {
   SYSTEM_POWER_STATE PowerState ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_PowerSequence_80 {
   PPOWER_SEQUENCE PowerSequence ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Power_81 {
   ULONG SystemContext ;
   POWER_STATE_TYPE Type ;
   POWER_STATE State ;
   POWER_ACTION ShutdownType ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_StartDevice_82 {
   PCM_RESOURCE_LIST AllocatedResources ;
   PCM_RESOURCE_LIST AllocatedResourcesTranslated ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_WMI_83 {
   ULONG_PTR ProviderId ;
   PVOID DataPath ;
   ULONG BufferSize ;
   PVOID Buffer ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct __anonstruct_Others_84 {
   PVOID Argument1 ;
   PVOID Argument2 ;
   PVOID Argument3 ;
   PVOID Argument4 ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
union __anonunion_Parameters_55 {
   struct __anonstruct_Create_56 Create ;
   struct __anonstruct_Read_57 Read ;
   struct __anonstruct_Write_58 Write ;
   struct __anonstruct_QueryFile_59 QueryFile ;
   struct __anonstruct_SetFile_60 SetFile ;
   struct __anonstruct_QueryVolume_63 QueryVolume ;
   struct __anonstruct_DeviceIoControl_64 DeviceIoControl ;
   struct __anonstruct_QuerySecurity_65 QuerySecurity ;
   struct __anonstruct_SetSecurity_66 SetSecurity ;
   struct __anonstruct_MountVolume_67 MountVolume ;
   struct __anonstruct_VerifyVolume_68 VerifyVolume ;
   struct __anonstruct_Scsi_69 Scsi ;
   struct __anonstruct_QueryDeviceRelations_70 QueryDeviceRelations ;
   struct __anonstruct_QueryInterface_71 QueryInterface ;
   struct __anonstruct_DeviceCapabilities_72 DeviceCapabilities ;
   struct __anonstruct_FilterResourceRequirements_73 FilterResourceRequirements ;
   struct __anonstruct_ReadWriteConfig_74 ReadWriteConfig ;
   struct __anonstruct_SetLock_75 SetLock ;
   struct __anonstruct_QueryId_76 QueryId ;
   struct __anonstruct_QueryDeviceText_77 QueryDeviceText ;
   struct __anonstruct_UsageNotification_78 UsageNotification ;
   struct __anonstruct_WaitWake_79 WaitWake ;
   struct __anonstruct_PowerSequence_80 PowerSequence ;
   struct __anonstruct_Power_81 Power ;
   struct __anonstruct_StartDevice_82 StartDevice ;
   struct __anonstruct_WMI_83 WMI ;
   struct __anonstruct_Others_84 Others ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
struct _IO_STACK_LOCATION {
   UCHAR MajorFunction ;
   UCHAR MinorFunction ;
   UCHAR Flags ;
   UCHAR Control ;
   union __anonunion_Parameters_55 Parameters ;
   PDEVICE_OBJECT DeviceObject ;
   PFILE_OBJECT FileObject ;
   NTSTATUS (*CompletionRoutine)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
   PVOID Context ;
};
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION IO_STACK_LOCATION;
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION *PIO_STACK_LOCATION;
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 14635 "C:/NTDDK/inc/ddk/ntddk.h"
struct _CONFIGURATION_INFORMATION {
   ULONG DiskCount ;
   ULONG FloppyCount ;
   ULONG CdRomCount ;
   ULONG TapeCount ;
   ULONG ScsiPortCount ;
   ULONG SerialCount ;
   ULONG ParallelCount ;
   BOOLEAN AtDiskPrimaryAddressClaimed ;
   BOOLEAN AtDiskSecondaryAddressClaimed ;
   ULONG Version ;
   ULONG MediumChangerCount ;
};
#line 14635 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CONFIGURATION_INFORMATION CONFIGURATION_INFORMATION;
#line 14635 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CONFIGURATION_INFORMATION *PCONFIGURATION_INFORMATION;
#line 18321 "C:/NTDDK/inc/ddk/ntddk.h"
struct _OBJECT_HANDLE_INFORMATION {
   ULONG HandleAttributes ;
   ACCESS_MASK GrantedAccess ;
};
#line 18321 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _OBJECT_HANDLE_INFORMATION *POBJECT_HANDLE_INFORMATION;
#line 248 "C:/NTDDK/inc/ntdddisk.h"
enum _MEDIA_TYPE {
    Unknown = 0,
    F5_1Pt2_512 = 1,
    F3_1Pt44_512 = 2,
    F3_2Pt88_512 = 3,
    F3_20Pt8_512 = 4,
    F3_720_512 = 5,
    F5_360_512 = 6,
    F5_320_512 = 7,
    F5_320_1024 = 8,
    F5_180_512 = 9,
    F5_160_512 = 10,
    RemovableMedia = 11,
    FixedMedia = 12,
    F3_120M_512 = 13,
    F3_640_512 = 14,
    F5_640_512 = 15,
    F5_720_512 = 16,
    F3_1Pt2_512 = 17,
    F3_1Pt23_1024 = 18,
    F5_1Pt23_1024 = 19,
    F3_128Mb_512 = 20,
    F3_230Mb_512 = 21,
    F8_256_128 = 22
} ;
#line 248 "C:/NTDDK/inc/ntdddisk.h"
typedef enum _MEDIA_TYPE MEDIA_TYPE;
#line 279 "C:/NTDDK/inc/ntdddisk.h"
struct _FORMAT_PARAMETERS {
   MEDIA_TYPE MediaType ;
   ULONG StartCylinderNumber ;
   ULONG EndCylinderNumber ;
   ULONG StartHeadNumber ;
   ULONG EndHeadNumber ;
};
#line 279 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _FORMAT_PARAMETERS FORMAT_PARAMETERS;
#line 279 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _FORMAT_PARAMETERS *PFORMAT_PARAMETERS;
#line 294 "C:/NTDDK/inc/ntdddisk.h"
typedef USHORT BAD_TRACK_NUMBER;
#line 295 "C:/NTDDK/inc/ntdddisk.h"
typedef USHORT *PBAD_TRACK_NUMBER;
#line 302 "C:/NTDDK/inc/ntdddisk.h"
struct _FORMAT_EX_PARAMETERS {
   MEDIA_TYPE MediaType ;
   ULONG StartCylinderNumber ;
   ULONG EndCylinderNumber ;
   ULONG StartHeadNumber ;
   ULONG EndHeadNumber ;
   USHORT FormatGapLength ;
   USHORT SectorsPerTrack ;
   USHORT SectorNumber[1] ;
};
#line 302 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _FORMAT_EX_PARAMETERS FORMAT_EX_PARAMETERS;
#line 302 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _FORMAT_EX_PARAMETERS *PFORMAT_EX_PARAMETERS;
#line 319 "C:/NTDDK/inc/ntdddisk.h"
struct _DISK_GEOMETRY {
   LARGE_INTEGER Cylinders ;
   MEDIA_TYPE MediaType ;
   ULONG TracksPerCylinder ;
   ULONG SectorsPerTrack ;
   ULONG BytesPerSector ;
};
#line 319 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _DISK_GEOMETRY DISK_GEOMETRY;
#line 319 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _DISK_GEOMETRY *PDISK_GEOMETRY;
#line 27 "C:/NTDDK/inc/pshpack1.h"
#pragma pack(push,1)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 27 "C:/NTDDK/inc/pshpack1.h"
#pragma pack(push,1)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 27 "C:/NTDDK/inc/pshpack1.h"
#pragma pack(push,1)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 27 "C:/NTDDK/inc/pshpack1.h"
#pragma pack(push,1)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 27 "C:/NTDDK/inc/pshpack1.h"
#pragma pack(push,1)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 164 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
struct _TRANSFER_BUFFER {
   PHYSICAL_ADDRESS Logical ;
   PVOID Virtual ;
};
#line 164 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _TRANSFER_BUFFER TRANSFER_BUFFER;
#line 180 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
struct _ACPI_FDI_DATA {
   ULONG DriveNumber ;
   ULONG DeviceType ;
   ULONG MaxCylinderNumber ;
   ULONG MaxSectorNumber ;
   ULONG MaxHeadNumber ;
   ULONG StepRateHeadUnloadTime ;
   ULONG HeadLoadTime ;
   ULONG MotorOffTime ;
   ULONG SectorLengthCode ;
   ULONG SectorPerTrack ;
   ULONG ReadWriteGapLength ;
   ULONG DataTransferLength ;
   ULONG FormatGapLength ;
   ULONG FormatFillCharacter ;
   ULONG HeadSettleTime ;
   ULONG MotorSettleTime ;
};
#line 180 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _ACPI_FDI_DATA ACPI_FDI_DATA;
#line 201
enum _ACPI_FDI_DEVICE_TYPE {
    CmosProblem = 0,
    Form525Capacity360 = 1,
    Form525Capacity1200 = 2,
    Form35Capacity720 = 3,
    Form35Capacity1440 = 4,
    Form35Capacity2880 = 5
} ;
#line 212 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
struct _FDC_INFO {
   UCHAR FloppyControllerType ;
   UCHAR SpeedsAvailable ;
   ULONG AdapterBufferSize ;
   INTERFACE_TYPE BusType ;
   ULONG BusNumber ;
   ULONG ControllerNumber ;
   ULONG PeripheralNumber ;
   ULONG UnitNumber ;
   ULONG MaxTransferSize ;
   BOOLEAN AcpiBios ;
   BOOLEAN AcpiFdiSupported ;
   ACPI_FDI_DATA AcpiFdiData ;
   ULONG BufferCount ;
   ULONG BufferSize ;
   TRANSFER_BUFFER BufferAddress[] ;
};
#line 212 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _FDC_INFO FDC_INFO;
#line 212 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _FDC_INFO *PFDC_INFO;
#line 240 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
struct _FDC_ENABLE_PARMS {
   UCHAR DriveOnValue ;
   USHORT TimeToWait ;
   BOOLEAN MotorStarted ;
};
#line 240 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _FDC_ENABLE_PARMS FDC_ENABLE_PARMS;
#line 252 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
struct _FDC_DISK_CHANGE_PARMS {
   UCHAR DriveStatus ;
   UCHAR DriveOnValue ;
};
#line 252 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _FDC_DISK_CHANGE_PARMS FDC_DISK_CHANGE_PARMS;
#line 261 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
struct _ISSUE_FDC_COMMAND_PARMS {
   PUCHAR FifoInBuffer ;
   PUCHAR FifoOutBuffer ;
   PVOID IoHandle ;
   ULONG IoOffset ;
   ULONG TransferBytes ;
   ULONG TimeOut ;
};
#line 261 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _ISSUE_FDC_COMMAND_PARMS ISSUE_FDC_COMMAND_PARMS;
#line 291 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
struct _SET_HD_BIT_PARMS {
   BOOLEAN DriveType144MB ;
   BOOLEAN Media144MB ;
   BOOLEAN More120MB ;
   UCHAR DeviceUnit ;
   BOOLEAN ChangedHdBit ;
};
#line 291 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _SET_HD_BIT_PARMS SET_HD_BIT_PARMS;
#line 202 "C:/NTDDK/inc/mountmgr.h"
struct _MOUNTDEV_NAME {
   USHORT NameLength ;
   WCHAR Name[1] ;
};
#line 202 "C:/NTDDK/inc/mountmgr.h"
typedef struct _MOUNTDEV_NAME MOUNTDEV_NAME;
#line 202 "C:/NTDDK/inc/mountmgr.h"
typedef struct _MOUNTDEV_NAME *PMOUNTDEV_NAME;
#line 38 "C:/NTDDK/inc/ddk/mountdev.h"
struct _MOUNTDEV_UNIQUE_ID {
   USHORT UniqueIdLength ;
   UCHAR UniqueId[1] ;
};
#line 38 "C:/NTDDK/inc/ddk/mountdev.h"
typedef struct _MOUNTDEV_UNIQUE_ID MOUNTDEV_UNIQUE_ID;
#line 38 "C:/NTDDK/inc/ddk/mountdev.h"
typedef struct _MOUNTDEV_UNIQUE_ID *PMOUNTDEV_UNIQUE_ID;
#line 66 "C:/NTDDK/inc/ddk/mountdev.h"
struct _MOUNTDEV_SUGGESTED_LINK_NAME {
   BOOLEAN UseOnlyIfThereAreNoOtherLinks ;
   USHORT NameLength ;
   WCHAR Name[1] ;
};
#line 66 "C:/NTDDK/inc/ddk/mountdev.h"
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME MOUNTDEV_SUGGESTED_LINK_NAME;
#line 66 "C:/NTDDK/inc/ddk/mountdev.h"
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME *PMOUNTDEV_SUGGESTED_LINK_NAME;
#line 105 "./flo_data.h"
struct _BOOT_SECTOR_INFO {
   UCHAR JumpByte[1] ;
   UCHAR Ignore1[2] ;
   UCHAR OemData[8] ;
   UCHAR BytesPerSector[2] ;
   UCHAR Ignore2[6] ;
   UCHAR NumberOfSectors[2] ;
   UCHAR MediaByte[1] ;
   UCHAR Ignore3[2] ;
   UCHAR SectorsPerTrack[2] ;
   UCHAR NumberOfHeads[2] ;
};
#line 105 "./flo_data.h"
typedef struct _BOOT_SECTOR_INFO *PBOOT_SECTOR_INFO;
#line 194
enum _DRIVE_MEDIA_TYPE {
    Drive360Media160 = 0,
    Drive360Media180 = 1,
    Drive360Media320 = 2,
    Drive360Media32X = 3,
    Drive360Media360 = 4,
    Drive720Media720 = 5,
    Drive120Media160 = 6,
    Drive120Media180 = 7,
    Drive120Media320 = 8,
    Drive120Media32X = 9,
    Drive120Media360 = 10,
    Drive120Media120 = 11,
    Drive144Media720 = 12,
    Drive144Media144 = 13,
    Drive288Media720 = 14,
    Drive288Media144 = 15,
    Drive288Media288 = 16
} ;
#line 194 "./flo_data.h"
typedef enum _DRIVE_MEDIA_TYPE DRIVE_MEDIA_TYPE;
#line 217
enum _DRIVE_MEDIA_TYPE_NEC98 {
    Drive360Media160Nec98 = 0,
    Drive360Media180Nec98 = 1,
    Drive360Media320Nec98 = 2,
    Drive360Media32XNec98 = 3,
    Drive360Media360Nec98 = 4,
    Drive120Media160Nec98 = 5,
    Drive120Media180Nec98 = 6,
    Drive120Media320Nec98 = 7,
    Drive120Media32XNec98 = 8,
    Drive120Media360Nec98 = 9,
    Drive120Media640Nec98 = 10,
    Drive120Media720Nec98 = 11,
    Drive120Media120Nec98 = 12,
    Drive120Media123Nec98 = 13,
    Drive144Media640Nec98 = 14,
    Drive144Media720Nec98 = 15,
    Drive144Media120Nec98 = 16,
    Drive144Media123Nec98 = 17,
    Drive144Media144Nec98 = 18,
    Drive12EMedia120Nec98 = 19,
    Drive12EMedia123Nec98 = 20
} ;
#line 217 "./flo_data.h"
typedef enum _DRIVE_MEDIA_TYPE_NEC98 DRIVE_MEDIA_TYPE_NEC98;
#line 260 "./flo_data.h"
struct _DRIVE_MEDIA_LIMITS {
   DRIVE_MEDIA_TYPE HighestDriveMediaType ;
   DRIVE_MEDIA_TYPE LowestDriveMediaType ;
};
#line 260 "./flo_data.h"
typedef struct _DRIVE_MEDIA_LIMITS DRIVE_MEDIA_LIMITS;
#line 260 "./flo_data.h"
typedef struct _DRIVE_MEDIA_LIMITS *PDRIVE_MEDIA_LIMITS;
#line 277 "./flo_data.h"
struct _DRIVE_MEDIA_LIMITS_NEC98 {
   DRIVE_MEDIA_TYPE_NEC98 HighestDriveMediaType ;
   DRIVE_MEDIA_TYPE_NEC98 LowestDriveMediaType ;
};
#line 277 "./flo_data.h"
typedef struct _DRIVE_MEDIA_LIMITS_NEC98 DRIVE_MEDIA_LIMITS_NEC98;
#line 298 "./flo_data.h"
struct _DRIVE_MEDIA_CONSTANTS {
   MEDIA_TYPE MediaType ;
   UCHAR StepRateHeadUnloadTime ;
   UCHAR HeadLoadTime ;
   UCHAR MotorOffTime ;
   UCHAR SectorLengthCode ;
   USHORT BytesPerSector ;
   UCHAR SectorsPerTrack ;
   UCHAR ReadWriteGapLength ;
   UCHAR FormatGapLength ;
   UCHAR FormatFillCharacter ;
   UCHAR HeadSettleTime ;
   USHORT MotorSettleTimeRead ;
   USHORT MotorSettleTimeWrite ;
   UCHAR MaximumTrack ;
   UCHAR CylinderShift ;
   UCHAR DataTransferRate ;
   UCHAR NumberOfHeads ;
   UCHAR DataLength ;
   UCHAR MediaByte ;
   UCHAR SkewDelta ;
};
#line 298 "./flo_data.h"
typedef struct _DRIVE_MEDIA_CONSTANTS DRIVE_MEDIA_CONSTANTS;
#line 298 "./flo_data.h"
typedef struct _DRIVE_MEDIA_CONSTANTS *PDRIVE_MEDIA_CONSTANTS;
#line 528 "./flo_data.h"
struct _DISKETTE_EXTENSION {
   KSPIN_LOCK FlCancelSpinLock ;
   PDEVICE_OBJECT UnderlyingPDO ;
   PDEVICE_OBJECT TargetObject ;
   BOOLEAN IsStarted ;
   BOOLEAN IsRemoved ;
   BOOLEAN HoldNewRequests ;
   LIST_ENTRY NewRequestQueue ;
   KSPIN_LOCK NewRequestQueueSpinLock ;
   PDEVICE_OBJECT DeviceObject ;
   KSEMAPHORE RequestSemaphore ;
   KSPIN_LOCK ListSpinLock ;
   FAST_MUTEX ThreadReferenceMutex ;
   LONG ThreadReferenceCount ;
   PKTHREAD FloppyThread ;
   LIST_ENTRY ListEntry ;
   BOOLEAN HardwareFailed ;
   UCHAR HardwareFailCount ;
   ULONG MaxTransferSize ;
   UCHAR FifoBuffer[10] ;
   PUCHAR IoBuffer ;
   PMDL IoBufferMdl ;
   ULONG IoBufferSize ;
   PDRIVER_OBJECT DriverObject ;
   DRIVE_MEDIA_TYPE LastDriveMediaType ;
   BOOLEAN FloppyControllerAllocated ;
   BOOLEAN ACPI_BIOS ;
   UCHAR DriveType ;
   ULONG BytesPerSector ;
   ULONG ByteCapacity ;
   MEDIA_TYPE MediaType ;
   DRIVE_MEDIA_TYPE DriveMediaType ;
   UCHAR DeviceUnit ;
   UCHAR DriveOnValue ;
   BOOLEAN IsReadOnly ;
   DRIVE_MEDIA_CONSTANTS BiosDriveMediaConstants ;
   DRIVE_MEDIA_CONSTANTS DriveMediaConstants ;
   UCHAR PerpendicularMode ;
   BOOLEAN ControllerConfigurable ;
   UNICODE_STRING DeviceName ;
   UNICODE_STRING InterfaceString ;
   UNICODE_STRING ArcName ;
   BOOLEAN ReleaseFdcWithMotorRunning ;
   BOOLEAN PoweringDown ;
   FAST_MUTEX PowerDownMutex ;
   FAST_MUTEX HoldNewReqMutex ;
};
#line 528 "./flo_data.h"
typedef struct _DISKETTE_EXTENSION DISKETTE_EXTENSION;
#line 584 "./flo_data.h"
typedef DISKETTE_EXTENSION *PDISKETTE_EXTENSION;
#line 591 "./flo_data.h"
struct _SENSE_DEVISE_STATUS_PTOS {
   UCHAR ST3_PTOS ;
};
#line 591 "./flo_data.h"
typedef struct _SENSE_DEVISE_STATUS_PTOS SENSE_DEVISE_STATUS_PTOS;
#line 591 "./flo_data.h"
typedef struct _SENSE_DEVISE_STATUS_PTOS *PSENSE_DEVISE_STATUS_PTOS;
#line 33 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"
#pragma pack(push,8)
#line 156
#pragma pack(pop)
#line 222 "C:/NTDDK/inc/ddk/ntddk.h"
struct _KAPC;
#line 292
struct _KDPC;
#line 27 "C:/NTDDK/inc/pshpack4.h"
#pragma pack(push,4)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 27 "C:/NTDDK/inc/pshpack4.h"
#pragma pack(push,4)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 27 "C:/NTDDK/inc/pshpack1.h"
#pragma pack(push,1)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 12399 "C:/NTDDK/inc/ddk/ntddk.h"
struct _DRIVER_OBJECT;
#line 12906
struct _DEVICE_OBJECT;
#line 12908
struct _DRIVER_OBJECT;
#line 12911
struct _FILE_OBJECT;
#line 12912
struct _IRP;
#line 12913
struct _SCSI_REQUEST_BLOCK;
#line 27 "C:/NTDDK/inc/pshpack4.h"
#pragma pack(push,4)
#line 30 "C:/NTDDK/inc/poppack.h"
#pragma pack(pop)
#line 17 "C:/NTDDK/inc/stdio.h"
#pragma once
#line 307
extern int ( __attribute__((__cdecl__)) sprintf)(char * , char const   *  , ...) ;
#line 351
extern int ( __attribute__((__cdecl__)) swprintf)(wchar_t * , wchar_t const   *  , ...) ;
#line 17 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"
#pragma once
#line 26 "C:/NTDDK/inc/ntdef.h"
#pragma once
#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"
#pragma once
#line 26 "C:/NTDDK/inc/basetsd.h"
#pragma once
#line 832 "C:/NTDDK/inc/ntdef.h"
#pragma warning(push)
#line 834
#pragma warning(disable:4035)
#line 835 "C:/NTDDK/inc/ntdef.h"
__inline ULONGLONG ( __attribute__((__stdcall__)) Int64ShllMod32___0)(ULONGLONG Value ,
                                                                      ULONG ShiftCount ) 
{ 

  {
#line 850
  return (0ULL);
}
}
#line 845 "C:/NTDDK/inc/ntdef.h"
__inline LONGLONG ( __attribute__((__stdcall__)) Int64ShraMod32___0)(LONGLONG Value ,
                                                                     ULONG ShiftCount ) 
{ 

  {
#line 860
  return (0LL);
}
}
#line 855 "C:/NTDDK/inc/ntdef.h"
__inline ULONGLONG ( __attribute__((__stdcall__)) Int64ShrlMod32___0)(ULONGLONG Value ,
                                                                      ULONG ShiftCount ) 
{ 

  {
#line 870
  return (0ULL);
}
}
#line 873
#pragma warning(pop)
#line 1094 "C:/NTDDK/inc/ntdef.h"
__inline void ListEntry32To64(PLIST_ENTRY32 l32 , PLIST_ENTRY64 l64 ) 
{ 

  {
#line 1101
  l64->Flink = (unsigned long long )((long long )((long )l32->Flink));
#line 1102
  l64->Blink = (unsigned long long )((long long )((long )l32->Blink));
#line 1103
  // return;
}
}
#line 1105 "C:/NTDDK/inc/ntdef.h"
__inline void ListEntry64To32(PLIST_ENTRY64 l64 , PLIST_ENTRY32 l32 ) 
{ 

  {
#line 1112
  l32->Flink = (unsigned long )l64->Flink;
#line 1113
  l32->Blink = (unsigned long )l64->Blink;
#line 1114
  // return;
}
}
#line 17 "C:/NTDDK/inc/string.h"
#pragma once
#line 93
extern void *( __attribute__((__cdecl__)) memcpy)(void * , void const   * , size_t  ) ;
#line 95
extern void *( __attribute__((__cdecl__)) memset)(void * , int  , size_t  ) ;
#line 110
extern void *( __attribute__((__cdecl__)) memmove)(void * , void const   * , size_t  ) ;
#line 101 "C:/NTDDK/inc/ddk/ntddk.h"
extern PKTHREAD ( __attribute__((__stdcall__)) KeGetCurrentThread)() ;
#line 25 "C:/NTDDK/inc/pshpack4.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 1136 "C:/NTDDK/inc/ddk/ntddk.h"
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) RtlQueryRegistryValues)(ULONG RelativeTo ,
                                                                                                PCWSTR Path ,
                                                                                                PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                                                                                PVOID Context ,
                                                                                                PVOID Environment ) ;
#line 1159
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) RtlDeleteRegistryValue)(ULONG RelativeTo ,
                                                                                                PCWSTR Path ,
                                                                                                PCWSTR ValueName ) ;
#line 1264
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) RtlInitString)(PSTRING DestinationString ,
                                                                                   PCSZ SourceString ) ;
#line 1280
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) RtlInitUnicodeString)(PUNICODE_STRING DestinationString ,
                                                                                          PCWSTR SourceString ) ;
#line 1335
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) RtlAnsiStringToUnicodeString)(PUNICODE_STRING DestinationString ,
                                                                                                      PANSI_STRING SourceString ,
                                                                                                      BOOLEAN AllocateDestinationString ) ;
#line 1394
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) RtlCopyUnicodeString)(PUNICODE_STRING DestinationString ,
                                                                                          PUNICODE_STRING SourceString ) ;
#line 1429
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) RtlFreeUnicodeString)(PUNICODE_STRING UnicodeString ) ;
#line 1516
 __attribute__((__dllimport__)) SIZE_T ( __attribute__((__stdcall__)) RtlCompareMemory)(void const   *Source1 ,
                                                                                        void const   *Source2 ,
                                                                                        SIZE_T Length ) ;
#line 1718 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlLargeIntegerAdd)(LARGE_INTEGER Addend1 ,
                                                                          LARGE_INTEGER Addend2 ) 
{ LARGE_INTEGER Sum ;

  {
#line 1728
  Sum.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
#line 1729
  return (Sum);
}
}
#line 1736 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlEnlargedIntegerMultiply)(LONG Multiplicand ,
                                                                                  LONG Multiplier ) 
{ LARGE_INTEGER Product ;

  {
#line 1746
  Product.QuadPart = (long long )((unsigned long long )((long long )Multiplicand) * (unsigned long long )Multiplier);
#line 1747
  return (Product);
}
}
#line 1754 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlEnlargedUnsignedMultiply)(ULONG Multiplicand ,
                                                                                   ULONG Multiplier ) 
{ LARGE_INTEGER Product ;

  {
#line 1764
  Product.QuadPart = (long long )((unsigned long long )Multiplicand * (unsigned long long )Multiplier);
#line 1765
  return (Product);
}
}
#line 1772 "C:/NTDDK/inc/ddk/ntddk.h"
__inline ULONG ( __attribute__((__stdcall__)) RtlEnlargedUnsignedDivide)(ULARGE_INTEGER Dividend ,
                                                                         ULONG Divisor ,
                                                                         PULONG Remainder ) 
{ ULONG Quotient ;

  {
#line 1783
  Quotient = (unsigned long )(Dividend.QuadPart / (ULONGLONG )Divisor);
#line 1784
  if ((unsigned int )((CHAR *)Remainder) != (unsigned int )((CHAR *)((void *)0))) {
#line 1786
    *Remainder = (unsigned long )(Dividend.QuadPart % (unsigned long long )Divisor);
  }
#line 1789
  return (Quotient);
}
}
#line 1796 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlLargeIntegerNegate)(LARGE_INTEGER Subtrahend ) 
{ LARGE_INTEGER Difference ;

  {
#line 1805
  Difference.QuadPart = - Subtrahend.QuadPart;
#line 1806
  return (Difference);
}
}
#line 1813 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlLargeIntegerSubtract)(LARGE_INTEGER Minuend ,
                                                                               LARGE_INTEGER Subtrahend ) 
{ LARGE_INTEGER Difference ;

  {
#line 1823
  Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
#line 1824
  return (Difference);
}
}
#line 1953
#pragma warning(push)
#line 1955
#pragma warning(disable:4035)
#line 1960 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlConvertLongToLargeInteger)(LONG SignedInteger ) 
{ 

  {
LARGE_INTEGER stub;
#line 1971
  return (stub);
}
}
#line 1973 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlConvertUlongToLargeInteger)(ULONG UnsignedInteger ) 
{ 

  {
LARGE_INTEGER stub;
#line 1984
  return (stub);
}
}
#line 1986 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlLargeIntegerShiftLeft)(LARGE_INTEGER LargeInteger ,
                                                                                CCHAR ShiftCount ) 
{ 

  {
LARGE_INTEGER stub;
#line 2013
  return (stub);
}
}
#line 2015 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlLargeIntegerShiftRight)(LARGE_INTEGER LargeInteger ,
                                                                                 CCHAR ShiftCount ) 
{ 

  {
LARGE_INTEGER stub;
#line 2024
  return (stub);
}
}
#line 2026 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LARGE_INTEGER ( __attribute__((__stdcall__)) RtlLargeIntegerArithmeticShift)(LARGE_INTEGER LargeInteger ,
                                                                                      CCHAR ShiftCount ) 
{ 

  {
LARGE_INTEGER stub;
#line 2035
  return (stub);
}
}
#line 2038
#pragma warning(pop)
#line 2796 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LUID ( __attribute__((__stdcall__)) RtlConvertLongToLuid)(LONG Long ) 
{ LUID TempLuid ;
  LARGE_INTEGER TempLi ;

  {
#line 2805
  TempLi = RtlConvertLongToLargeInteger(Long);
#line 2806
  TempLuid.LowPart = TempLi.__annonCompField1.LowPart;
#line 2807
  TempLuid.HighPart = TempLi.__annonCompField1.HighPart;
#line 2808
  return (TempLuid);
}
}
#line 2811 "C:/NTDDK/inc/ddk/ntddk.h"
__inline LUID ( __attribute__((__stdcall__)) RtlConvertUlongToLuid)(ULONG Ulong ) 
{ LUID TempLuid ;

  {
#line 2819
  TempLuid.LowPart = Ulong;
#line 2820
  TempLuid.HighPart = 0L;
#line 2821
  return (TempLuid);
}
}
#line 5211
extern  __attribute__((__dllimport__)) LONG ( __attribute__((__fastcall__)) InterlockedExchange)(PLONG Target ,
                                                                                                 LONG Value ) ;
#line 5253
#pragma warning(disable:4035)
#line 5271 "C:/NTDDK/inc/ddk/ntddk.h"
__inline ULONG KeGetCurrentProcessorNumber(void) 
{ 

  {
#line 5274
  return (0UL);
}
}
#line 7015
#pragma warning(push)
#line 7017
#pragma warning(disable:4164)
#line 7020
#pragma function(_enable)
#line 7021
#pragma function(_disable)
#line 7025
#pragma warning(pop)
#line 25 "C:/NTDDK/inc/pshpack4.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 25 "C:/NTDDK/inc/pshpack1.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 9415 "C:/NTDDK/inc/ddk/ntddk.h"
 __attribute__((__dllimport__)) void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
                                                       BOOLEAN State ) ;
#line 9451
 __attribute__((__dllimport__)) LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
                                                BOOLEAN Wait ) ;
#line 9483
 __attribute__((__dllimport__)) void KeInitializeSemaphore(PRKSEMAPHORE Semaphore ,
                                                           LONG Count , LONG Limit ) ;
#line 9497
 __attribute__((__dllimport__)) LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment ,
                                                        LONG Adjustment , BOOLEAN Wait ) ;
#line 9506
 __attribute__((__dllimport__)) NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
                                                                BOOLEAN Alertable ,
                                                                PLARGE_INTEGER Interval ) ;
#line 9527
extern  __attribute__((__dllimport__)) KPRIORITY KeSetPriorityThread(PKTHREAD Thread ,
                                                                     KPRIORITY Priority ) ;
#line 9681
 __attribute__((__dllimport__)) NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason ,
                                                               KPROCESSOR_MODE WaitMode ,
                                                               BOOLEAN Alertable ,
                                                               PLARGE_INTEGER Timeout ) ;
#line 9711
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) KeInitializeSpinLock)(PKSPIN_LOCK SpinLock ) ;
#line 9737
extern  __attribute__((__dllimport__)) KIRQL ( __attribute__((__fastcall__)) KfAcquireSpinLock)(PKSPIN_LOCK SpinLock ) ;
#line 9744
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) KfReleaseSpinLock)(PKSPIN_LOCK SpinLock ,
                                                                                        KIRQL NewIrql ) ;
#line 10159
 __attribute__((__dllimport__)) PVOID ( __attribute__((__stdcall__)) ExAllocatePoolWithTag)(POOL_TYPE PoolType ,
                                                                                            SIZE_T NumberOfBytes ,
                                                                                            ULONG Tag ) ;
#line 10236
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) ExFreePool)(PVOID P ) ;
#line 10315
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) ExAcquireFastMutex)(PFAST_MUTEX FastMutex ) ;
#line 10322
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) ExReleaseFastMutex)(PFAST_MUTEX FastMutex ) ;
#line 10406
 __attribute__((__dllimport__)) PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedInsertHeadList)(PLIST_ENTRY ListHead ,
                                                                                                          PLIST_ENTRY ListEntry ,
                                                                                                          PKSPIN_LOCK Lock ) ;
#line 10415
 __attribute__((__dllimport__)) PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedInsertTailList)(PLIST_ENTRY ListHead ,
                                                                                                          PLIST_ENTRY ListEntry ,
                                                                                                          PKSPIN_LOCK Lock ) ;
#line 10424
 __attribute__((__dllimport__)) PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedRemoveHeadList)(PLIST_ENTRY ListHead ,
                                                                                                          PKSPIN_LOCK Lock ) ;
#line 10547
extern  __attribute__((__dllimport__)) PSINGLE_LIST_ENTRY ( __attribute__((__fastcall__)) ExInterlockedPopEntrySList)(PSLIST_HEADER ListHead ,
                                                                                                                      PKSPIN_LOCK Lock ) ;
#line 10555
extern  __attribute__((__dllimport__)) PSINGLE_LIST_ENTRY ( __attribute__((__fastcall__)) ExInterlockedPushEntrySList)(PSLIST_HEADER ListHead ,
                                                                                                                       PSINGLE_LIST_ENTRY ListEntry ,
                                                                                                                       PKSPIN_LOCK Lock ) ;
#line 10643 "C:/NTDDK/inc/ddk/ntddk.h"
__inline PVOID ExAllocateFromNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside ) 
{ PVOID Entry ;
  PSINGLE_LIST_ENTRY tmp ;

  {
#line 10672
  (Lookaside->L.TotalAllocates) ++;
#line 10673
  tmp = ExInterlockedPopEntrySList(& Lookaside->L.ListHead, & Lookaside->Lock);
#line 10673
  Entry = (void *)tmp;
#line 10674
  if ((unsigned int )Entry == (unsigned int )((void *)0)) {
#line 10675
    (Lookaside->L.__annonCompField7.AllocateMisses) ++;
#line 10676
    Entry = (*(Lookaside->L.Allocate))(Lookaside->L.Type, Lookaside->L.Size, Lookaside->L.Tag);
  }
#line 10681
  return (Entry);
}
}
#line 10684 "C:/NTDDK/inc/ddk/ntddk.h"
__inline void ExFreeToNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside , PVOID Entry ) 
{ 

  {
#line 10713
  (Lookaside->L.TotalFrees) ++;
#line 10714
  if ((int )Lookaside->L.ListHead.__annonCompField3.Depth >= (int )Lookaside->L.Depth) {
#line 10715
    (Lookaside->L.__annonCompField8.FreeMisses) ++;
#line 10716
    (*(Lookaside->L.Free))(Entry);
  } else {
#line 10719
    ExInterlockedPushEntrySList(& Lookaside->L.ListHead, (struct _SINGLE_LIST_ENTRY *)Entry,
                                & Lookaside->Lock);
  }
#line 10724
  // return;
}
}
#line 11906
extern  __attribute__((__dllimport__)) void MmProbeAndLockPages(PMDL MemoryDescriptorList ,
                                                                KPROCESSOR_MODE AccessMode ,
                                                                LOCK_OPERATION Operation ) ;
#line 11915
 __attribute__((__dllimport__)) void MmUnlockPages(PMDL MemoryDescriptorList ) ;
#line 11979
 __attribute__((__dllimport__)) PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList ,
                                                                   KPROCESSOR_MODE AccessMode ,
                                                                   MEMORY_CACHING_TYPE CacheType ,
                                                                   PVOID BaseAddress ,
                                                                   ULONG BugCheckOnFailure ,
                                                                   MM_PAGE_PRIORITY Priority ) ;
#line 12084
 __attribute__((__dllimport__)) PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
                                                                 PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
#line 12101
 __attribute__((__dllimport__)) void MmFreeContiguousMemory(PVOID BaseAddress ) ;
#line 12172
 __attribute__((__dllimport__)) void MmResetDriverPaging(PVOID AddressWithinSection ) ;
#line 12179
 __attribute__((__dllimport__)) PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
#line 12552
 __attribute__((__dllimport__)) NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle ,
                                                              ULONG DesiredAccess ,
                                                              POBJECT_ATTRIBUTES ObjectAttributes ,
                                                              HANDLE ProcessHandle ,
                                                              PCLIENT_ID ClientId ,
                                                              void (*StartRoutine)(PVOID StartContext ) ,
                                                              PVOID StartContext ) ;
#line 12564
 __attribute__((__dllimport__)) NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;
#line 25 "C:/NTDDK/inc/pshpack4.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 14734 "C:/NTDDK/inc/ddk/ntddk.h"
 __attribute__((__dllimport__)) PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
                                                   BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota ,
                                                   PIRP Irp ) ;
#line 14807
 __attribute__((__dllimport__)) PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice ,
                                                                           PDEVICE_OBJECT TargetDevice ) ;
#line 14814
 __attribute__((__dllimport__)) PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
                                                                   PDEVICE_OBJECT DeviceObject ,
                                                                   PVOID Buffer ,
                                                                   ULONG Length ,
                                                                   PLARGE_INTEGER StartingOffset ,
                                                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 14825
 __attribute__((__dllimport__)) PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
                                                                   PDEVICE_OBJECT DeviceObject ,
                                                                   PVOID InputBuffer ,
                                                                   ULONG InputBufferLength ,
                                                                   PVOID OutputBuffer ,
                                                                   ULONG OutputBufferLength ,
                                                                   BOOLEAN InternalDeviceIoControl ,
                                                                   PKEVENT Event ,
                                                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 14875
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__fastcall__)) IofCallDriver)(PDEVICE_OBJECT DeviceObject ,
                                                                                        PIRP Irp ) ;
#line 14903
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) IofCompleteRequest)(PIRP Irp ,
                                                                                         CCHAR PriorityBoost ) ;
#line 14942
 __attribute__((__dllimport__)) NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
                                                        ULONG DeviceExtensionSize ,
                                                        PUNICODE_STRING DeviceName ,
                                                        ULONG DeviceType , ULONG DeviceCharacteristics ,
                                                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) ;
#line 14993
 __attribute__((__dllimport__)) NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName ,
                                                              PUNICODE_STRING DeviceName ) ;
#line 15057
 __attribute__((__dllimport__)) void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
#line 15063
 __attribute__((__dllimport__)) NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) ;
#line 15069
 __attribute__((__dllimport__)) void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
#line 15092
 __attribute__((__dllimport__)) void IoFreeIrp(PIRP Irp ) ;
#line 15098
 __attribute__((__dllimport__)) void IoFreeMdl(PMDL Mdl ) ;
#line 15110
 __attribute__((__dllimport__)) PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) ;
#line 15234
extern  __attribute__((__dllimport__)) void IoGetStackLimits(PULONG_PTR LowLimit ,
                                                             PULONG_PTR HighLimit ) ;
#line 15246 "C:/NTDDK/inc/ddk/ntddk.h"
__inline ULONG_PTR IoGetRemainingStackSize(void) 
{ ULONG_PTR Top ;
  ULONG_PTR Bottom ;

  {
#line 15255
  IoGetStackLimits(& Bottom, & Top);
#line 15256
  return ((unsigned long )(& Top) - Bottom);
}
}
#line 15426
 __attribute__((__dllimport__)) NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType ,
                                                                  PULONG BusNumber ,
                                                                  PCONFIGURATION_TYPE ControllerType ,
                                                                  PULONG ControllerNumber ,
                                                                  PCONFIGURATION_TYPE PeripheralType ,
                                                                  PULONG PeripheralNumber ,
                                                                  NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                             PUNICODE_STRING PathName ,
                                                                                             INTERFACE_TYPE BusType ,
                                                                                             ULONG BusNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                             CONFIGURATION_TYPE ControllerType ,
                                                                                             ULONG ControllerNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                             CONFIGURATION_TYPE PeripheralType ,
                                                                                             ULONG PeripheralNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                                                  PVOID Context ) ;
#line 15492
 __attribute__((__dllimport__)) void IoReleaseCancelSpinLock(KIRQL Irql ) ;
#line 15641
 __attribute__((__dllimport__)) void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) ;
#line 16436
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) IoRegisterDeviceInterface)(PDEVICE_OBJECT PhysicalDeviceObject ,
                                                                                                   GUID const   *InterfaceClassGuid ,
                                                                                                   PUNICODE_STRING ReferenceString ,
                                                                                                   PUNICODE_STRING SymbolicLinkName ) ;
#line 16456
 __attribute__((__dllimport__)) NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName ,
                                                                   BOOLEAN Enable ) ;
#line 17779
#pragma warning(disable:4200)
#line 17785
#pragma warning(default:4200)
#line 18271
 __attribute__((__dllimport__)) NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject ,
                                                      PIRP Irp ) ;
#line 18278
 __attribute__((__dllimport__)) void PoStartNextPowerIrp(PIRP Irp ) ;
#line 18326
 __attribute__((__dllimport__)) NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
                                                                   ACCESS_MASK DesiredAccess ,
                                                                   POBJECT_TYPE ObjectType ,
                                                                   KPROCESSOR_MODE AccessMode ,
                                                                   PVOID *Object ,
                                                                   POBJECT_HANDLE_INFORMATION HandleInformation ) ;
#line 18359
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) ObfDereferenceObject)(PVOID Object ) ;
#line 19155
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) ZwClose)(HANDLE Handle ) ;
#line 23 "C:/NTDDK/inc/ntdddisk.h"
#pragma once
#line 25 "C:/NTDDK/inc/pshpack1.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 25 "C:/NTDDK/inc/pshpack1.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 25 "C:/NTDDK/inc/pshpack1.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 25 "C:/NTDDK/inc/pshpack1.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 25 "C:/NTDDK/inc/pshpack1.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 13 "C:/NTDDK/inc/initguid.h"
#pragma once
#line 27 "C:/NTDDK/inc/mountmgr.h"
#pragma once
#line 212 "C:/NTDDK/inc/mountmgr.h"
 __attribute__((__selectany__)) struct _GUID  const  MOUNTDEV_MOUNTED_DEVICE_GUID  =    {1408590605UL,
    (unsigned short)46783, (unsigned short)4560, {(unsigned char)148, (unsigned char)242,
                                                  (unsigned char)0, (unsigned char)160,
                                                  (unsigned char)201, (unsigned char)30,
                                                  (unsigned char)251, (unsigned char)139}};
#line 28 "C:/NTDDK/inc/ddk/wdm/acpiioct.h"
#pragma once
#line 265 "./flo_data.h"
DRIVE_MEDIA_LIMITS _DriveMediaLimits[5]  = {      {4, 0}, 
        {11, 6}, 
        {5, 5}, 
        {13, 12}, 
        {16, 14}};
#line 282 "./flo_data.h"
DRIVE_MEDIA_LIMITS_NEC98 _DriveMediaLimits_NEC98[6]  = {      {4, 0}, 
        {13, 5}, 
        {11, 5}, 
        {18, 14}, 
        {18, 14}, 
        {20, 19}};
#line 292 "./flo_data.h"
PDRIVE_MEDIA_LIMITS DriveMediaLimits  ;
#line 334 "./flo_data.h"
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants[17]  = 
#line 334
  {      {10, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8,
      (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {9,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )252, (UCHAR )0}, 
        {7, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {8, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )4,
      (UCHAR )128, (UCHAR )240, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {6,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )250, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )253, (UCHAR )0}, 
        {5, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {10, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8,
      (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )1, (UCHAR )1, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {9,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )1, (UCHAR )1, (UCHAR )255, (UCHAR )252, (UCHAR )0}, 
        {7, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )1, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {8, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )4,
      (UCHAR )128, (UCHAR )240, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )1, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {6,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )625, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )1, (UCHAR )2, (UCHAR )255, (UCHAR )253, (UCHAR )0}, 
        {1, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )15,
      (UCHAR )27, (UCHAR )84, (UCHAR )246, (UCHAR )15, (USHORT )625, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )0}, 
        {5,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {2, (UCHAR )175, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )18,
      (UCHAR )27, (UCHAR )101, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )240, (UCHAR )3}, 
        {5,
      (UCHAR )225, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {2, (UCHAR )209, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )18,
      (UCHAR )27, (UCHAR )101, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )240, (UCHAR )3}, 
        {3,
      (UCHAR )161, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )36, (UCHAR )56,
      (UCHAR )83, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )3, (UCHAR )2, (UCHAR )255, (UCHAR )240, (UCHAR )6}};
#line 358 "./flo_data.h"
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants_NEC98[21]  = 
#line 358
  {      {10, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8,
      (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {9,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )252, (UCHAR )0}, 
        {7, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {8, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )4,
      (UCHAR )128, (UCHAR )240, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {6,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )250, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )253, (UCHAR )0}, 
        {10, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8,
      (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {9,
      (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )252, (UCHAR )0}, 
        {7, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8,
      (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {8,
      (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )4, (UCHAR )128,
      (UCHAR )240, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {6, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9,
      (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )253, (UCHAR )0}, 
        {15,
      (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8, (UCHAR )42,
      (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )251, (UCHAR )0}, 
        {16, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9,
      (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {1,
      (UCHAR )207, (UCHAR )36, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )15, (UCHAR )27,
      (UCHAR )84, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )0}, 
        {19, (UCHAR )207, (UCHAR )36, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )8,
      (UCHAR )53, (UCHAR )116, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )76, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {14,
      (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8, (UCHAR )42,
      (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )251, (UCHAR )0}, 
        {5, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9,
      (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {17,
      (UCHAR )207, (UCHAR )36, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )15, (UCHAR )27,
      (UCHAR )84, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )0}, 
        {18, (UCHAR )207, (UCHAR )36, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )8,
      (UCHAR )53, (UCHAR )116, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )76, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {2,
      (UCHAR )223, (UCHAR )36, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )18, (UCHAR )27,
      (UCHAR )108, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )240, (UCHAR )3}, 
        {1, (UCHAR )191, (UCHAR )50, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )15,
      (UCHAR )27, (UCHAR )84, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )0}, 
        {19,
      (UCHAR )191, (UCHAR )50, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )8, (UCHAR )53,
      (UCHAR )116, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )76,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )254, (UCHAR )0}};
#line 399 "./flo_data.h"
PDRIVE_MEDIA_CONSTANTS DriveMediaConstants  ;
#line 595 "./flo_data.h"
SENSE_DEVISE_STATUS_PTOS Result_Status3_PTOS[4]  ;
#line 603
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) ;
#line 609
void FloppyUnload(PDRIVER_OBJECT DriverObject ) ;
#line 614
NTSTATUS FlConfigCallBack(PVOID Context , PUNICODE_STRING PathName , INTERFACE_TYPE BusType ,
                          ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                          CONFIGURATION_TYPE ControllerType , ULONG ControllerNumber ,
                          PKEY_VALUE_FULL_INFORMATION *ControllerInformation , CONFIGURATION_TYPE PeripheralType ,
                          ULONG PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ;
#line 629
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 634
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 640
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 646
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 652
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 657
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 662
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN WriteOperation ,
                      BOOLEAN SetUpMedia , BOOLEAN IgnoreChange ) ;
#line 671
void FlFinishOperation(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) ;
#line 677
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 682
void FloppyThread(PVOID Context ) ;
#line 687
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN DriveStarted ) ;
#line 694
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) ;
#line 700
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension , PUCHAR FifoInBuffer ,
                        PUCHAR FifoOutBuffer , PMDL IoMdl , ULONG IoOffset , ULONG TransferBytes ) ;
#line 710
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension , PFORMAT_PARAMETERS FormatParameters ) ;
#line 724
NTSTATUS FlQueueIrpToThread(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) ;
#line 730
NTSTATUS FlInterpretError(UCHAR StatusRegister1 , UCHAR StatusRegister2 ) ;
#line 736
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension , ULONG BufferSize ) ;
#line 742
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 747
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension ,
                                          PBOOT_SECTOR_INFO BootSector ) ;
#line 753
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 758
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension , PMDL IoMdl , ULONG IoOffset ,
                          BOOLEAN WriteOperation , UCHAR Cylinder , UCHAR Head , UCHAR Sector ,
                          UCHAR NumberOfSectors , BOOLEAN NeedSeek ) ;
#line 771
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject , ULONG Ioctl , PVOID Data ) ;
#line 778
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) ;
#line 784
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 790
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 796
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
#line 803
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) ;
#line 809
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 815
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 820
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 826
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension , PFDC_INFO FdcInfo ) ;
#line 832
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 47 "floppy.c"
#pragma alloc_text(INIT,DriverEntry)
#line 49
#pragma alloc_text(PAGE,FloppyAddDevice)
#line 50
#pragma alloc_text(PAGE,FloppyPnp)
#line 51
#pragma alloc_text(PAGE,FloppyPower)
#line 52
#pragma alloc_text(PAGE,FlConfigCallBack)
#line 53
#pragma alloc_text(PAGE,FlInitializeControllerHardware)
#line 54
#pragma alloc_text(PAGE,FlInterpretError)
#line 55
#pragma alloc_text(PAGE,FlDatarateSpecifyConfigure)
#line 56
#pragma alloc_text(PAGE,FlRecalibrateDrive)
#line 57
#pragma alloc_text(PAGE,FlDetermineMediaType)
#line 58
#pragma alloc_text(PAGE,FlCheckBootSector)
#line 59
#pragma alloc_text(PAGE,FlConsolidateMediaTypeWithBootSector)
#line 60
#pragma alloc_text(PAGE,FlIssueCommand)
#line 61
#pragma alloc_text(PAGE,FlReadWriteTrack)
#line 62
#pragma alloc_text(PAGE,FlReadWrite)
#line 63
#pragma alloc_text(PAGE,FlFormat)
#line 64
#pragma alloc_text(PAGE,FlFinishOperation)
#line 65
#pragma alloc_text(PAGE,FlStartDrive)
#line 66
#pragma alloc_text(PAGE,FloppyThread)
#line 67
#pragma alloc_text(PAGE,FlAllocateIoBuffer)
#line 68
#pragma alloc_text(PAGE,FlFreeIoBuffer)
#line 69
#pragma alloc_text(PAGE,FloppyCreateClose)
#line 70
#pragma alloc_text(PAGE,FloppyDeviceControl)
#line 71
#pragma alloc_text(PAGE,FloppyReadWrite)
#line 72
#pragma alloc_text(PAGE,FlCheckFormatParameters)
#line 73
#pragma alloc_text(PAGE,FlFdcDeviceIo)
#line 74
#pragma alloc_text(PAGE,FlHdbit)
#line 95 "floppy.c"
#line 101 "floppy.c"
NTSTATUS myStatus  ;
#line 103 "floppy.c"
int s  ;

#line 111
#define  UNLOADED  0
#line 112
#define  NP  1
#line 113
#define  DC  2
#line 114
#define  SKIP1  3
#line 115
#define  SKIP2  4
#line 116
#define  MPR1  5
#line 117
#define  MPR3  6
#line 118
#define  IPC  7

#line 105 "floppy.c"
int pended  ;
#line 106 "floppy.c"
NTSTATUS (*compFptr)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context )  ;
#line 107 "floppy.c"
int compRegistered  ;
#line 108 "floppy.c"
int lowerDriverReturn  ;
#line 109 "floppy.c"
int setEventCalled  ;
#line 110 "floppy.c"
int customIrp  ;
#line 112 "floppy.c"
/*void _BLAST_init(void) 
{ 

  {
#line 121
  s = UNLOADED;
#line 122
  pended = 0;
#line 123
  compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))0;
#line 124
  compRegistered = 0;
#line 125
  lowerDriverReturn = 0;
#line 126
  setEventCalled = 0;
#line 127
  customIrp = 0;
#line 128
  // return;
}
}*/
#line 135 "floppy.c"
ULONG PagingReferenceCount  =    (ULONG )0;
#line 136 "floppy.c"
PFAST_MUTEX PagingMutex  =    (PFAST_MUTEX )((void *)0);
#line 139 "floppy.c"
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) 
{ NTSTATUS ntStatus ;
  PVOID tmp ;

  {
#line 170
  ntStatus = 0L;
#line 242
  while (1) {
#line 242
    break;
  }
#line 247
  DriverObject->MajorFunction[0] = & FloppyCreateClose;
#line 248
  DriverObject->MajorFunction[2] = & FloppyCreateClose;
#line 249
  DriverObject->MajorFunction[3] = & FloppyReadWrite;
#line 250
  DriverObject->MajorFunction[4] = & FloppyReadWrite;
#line 251
  DriverObject->MajorFunction[14] = & FloppyDeviceControl;
#line 252
  DriverObject->MajorFunction[27] = & FloppyPnp;
#line 253
  DriverObject->MajorFunction[22] = & FloppyPower;
#line 255
  DriverObject->DriverUnload = & FloppyUnload;
#line 257
  (DriverObject->DriverExtension)->AddDevice = & FloppyAddDevice;
#line 262
  tmp = ExAllocatePoolWithTag(0, (unsigned long )sizeof(FAST_MUTEX ), 1886350406UL);
#line 262
  PagingMutex = (struct _FAST_MUTEX *)tmp;
#line 264
  if ((unsigned int )PagingMutex == (unsigned int )((void *)0)) {
#line 266
    return (-1073741670L);
  }
#line 269
  PagingMutex->Count = 1L;
#line 269
  PagingMutex->Contention = 0UL;
#line 269
  KeInitializeEvent(& PagingMutex->Event, 1, (unsigned char)0);
#line 274
  MmPageEntireDriver((void *)(& DriverEntry));
#line 276
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 276
    DriveMediaLimits = (struct _DRIVE_MEDIA_LIMITS *)(_DriveMediaLimits_NEC98);
  } else {
#line 276
    DriveMediaLimits = _DriveMediaLimits;
  }
#line 279
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 279
    DriveMediaConstants = _DriveMediaConstants_NEC98;
  } else {
#line 279
    DriveMediaConstants = _DriveMediaConstants;
  }
#line 282
  return (ntStatus);
}
}
#line 285 "floppy.c"
void FloppyUnload(PDRIVER_OBJECT DriverObject ) 
{ 

  {
#line 308
  while (1) {
#line 308
    break;
  }
#line 318
  ExFreePool((void *)PagingMutex);
#line 320
  // return;
}
}
#line 323 "floppy.c"
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) 
{ NTSTATUS ntStatus ;
  PDEVICE_OBJECT deviceObject ;
  PDISKETTE_EXTENSION disketteExtension ;
  FDC_INFO fdcInfo ;
  UCHAR arcNameBuffer[256] ;
  STRING arcNameString ;
  WCHAR deviceNameBuffer[20] ;
  UNICODE_STRING deviceName ;
  USHORT i ;
  USHORT tmp ;
  PVOID tmp___0 ;
  PCONFIGURATION_INFORMATION tmp___1 ;

  {
#line 363
  ntStatus = 0L;
#line 365
  while (1) {
#line 365
    break;
  }
#line 370
  fdcInfo.BufferCount = 0UL;
#line 371
  fdcInfo.BufferSize = 0UL;
#line 373
  ntStatus = FlFdcDeviceIo(PhysicalDeviceObject, (unsigned long )(((7 << 16) | (770 << 2)) | 3),
                           (void *)(& fdcInfo));
#line 377
  if (ntStatus >= 0L) {
#line 379
    i = (USHORT )0;
#line 385
    while (1) {
#line 387
      tmp = i;
#line 387
      i = (USHORT )((int )i + 1);
#line 387
      swprintf(deviceNameBuffer, (wchar_t const   *)"\\\000D\000e\000v\000i\000c\000e\000\\\000F\000l\000o\000p\000p\000y\000%\000d\000",
               tmp);
#line 388
      RtlInitUnicodeString(& deviceName, (WCHAR const   *)(deviceNameBuffer));
#line 389
      ntStatus = IoCreateDevice(DriverObject, (unsigned long )sizeof(DISKETTE_EXTENSION ),
                                & deviceName, 7UL, 261UL, (unsigned char)0, & deviceObject);
#line 385
      if (! (ntStatus == -1073741771L)) {
#line 385
        break;
      }
    }
#line 401
    if (ntStatus >= 0L) {
#line 403
      disketteExtension = (DISKETTE_EXTENSION *)deviceObject->DeviceExtension;
#line 409
      while (1) {
#line 409
        break;
      }
#line 411
      tmp___0 = ExAllocatePoolWithTag(1, (unsigned long )deviceName.Length, 1886350406UL);
#line 411
      disketteExtension->DeviceName.Buffer = (WCHAR *)tmp___0;
#line 412
      if ((unsigned int )disketteExtension->DeviceName.Buffer == (unsigned int )((void *)0)) {
#line 414
        IoDeleteDevice(deviceObject);
#line 415
        return (-1073741670L);
      }
#line 417
      disketteExtension->DeviceName.Length = (unsigned short)0;
#line 418
      disketteExtension->DeviceName.MaximumLength = deviceName.Length;
#line 419
      RtlCopyUnicodeString(& disketteExtension->DeviceName, & deviceName);
#line 421
      tmp___1 = IoGetConfigurationInformation();
#line 421
      (tmp___1->FloppyCount) ++;
#line 429
      sprintf((char *)(arcNameBuffer), "%s(%d)disk(%d)fdisk(%d)", "\\ArcName\\multi",
              fdcInfo.BusNumber, fdcInfo.ControllerNumber, fdcInfo.PeripheralNumber);
#line 436
      RtlInitString(& arcNameString, (char const   *)(arcNameBuffer));
#line 438
      ntStatus = RtlAnsiStringToUnicodeString(& disketteExtension->ArcName, & arcNameString,
                                              (unsigned char)1);
#line 442
      if (ntStatus >= 0L) {
#line 444
        IoCreateSymbolicLink(& disketteExtension->ArcName, & deviceName);
      }
#line 447
      deviceObject->Flags |= 8208UL;
#line 449
      if (deviceObject->AlignmentRequirement < 1UL) {
#line 451
        deviceObject->AlignmentRequirement = 1UL;
      }
#line 454
      deviceObject->Flags &= 4294967167UL;
#line 456
      disketteExtension->DriverObject = DriverObject;
#line 459
      disketteExtension->UnderlyingPDO = PhysicalDeviceObject;
#line 464
      while (1) {
#line 464
        break;
      }
#line 466
      disketteExtension->TargetObject = IoAttachDeviceToDeviceStack(deviceObject,
                                                                    PhysicalDeviceObject);
#line 472
      while (1) {
#line 472
        break;
      }
#line 474
      KeInitializeSemaphore(& disketteExtension->RequestSemaphore, 0L, 2147483647L);
#line 478
      disketteExtension->PowerDownMutex.Count = 1L;
#line 478
      disketteExtension->PowerDownMutex.Contention = 0UL;
#line 478
      KeInitializeEvent(& disketteExtension->PowerDownMutex.Event, 1, (unsigned char)0);
#line 480
      KeInitializeSpinLock(& disketteExtension->ListSpinLock);
#line 482
      disketteExtension->ThreadReferenceMutex.Count = 1L;
#line 482
      disketteExtension->ThreadReferenceMutex.Contention = 0UL;
#line 482
      KeInitializeEvent(& disketteExtension->ThreadReferenceMutex.Event, 1, (unsigned char)0);
#line 484
      disketteExtension->HoldNewReqMutex.Count = 1L;
#line 484
      disketteExtension->HoldNewReqMutex.Contention = 0UL;
#line 484
      KeInitializeEvent(& disketteExtension->HoldNewReqMutex.Event, 1, (unsigned char)0);
#line 486
      disketteExtension->ListEntry.Blink = & disketteExtension->ListEntry;
#line 486
      disketteExtension->ListEntry.Flink = disketteExtension->ListEntry.Blink;
#line 488
      disketteExtension->ThreadReferenceCount = -1L;
#line 490
      disketteExtension->IsStarted = (unsigned char)0;
#line 491
      disketteExtension->IsRemoved = (unsigned char)0;
#line 492
      disketteExtension->HoldNewRequests = (unsigned char)0;
#line 493
      disketteExtension->NewRequestQueue.Blink = & disketteExtension->NewRequestQueue;
#line 493
      disketteExtension->NewRequestQueue.Flink = disketteExtension->NewRequestQueue.Blink;
#line 494
      KeInitializeSpinLock(& disketteExtension->NewRequestQueueSpinLock);
#line 495
      KeInitializeSpinLock(& disketteExtension->FlCancelSpinLock);
#line 497
      disketteExtension->FloppyControllerAllocated = (unsigned char)0;
#line 498
      disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
#line 499
      disketteExtension->DeviceObject = deviceObject;
#line 501
      disketteExtension->IsReadOnly = (unsigned char)0;
#line 503
      disketteExtension->MediaType = (enum _MEDIA_TYPE )-1;
#line 505
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 505
        disketteExtension->ControllerConfigurable = (unsigned char)0;
      } else {
#line 505
        disketteExtension->ControllerConfigurable = (unsigned char)1;
      }
    }
  }
#line 509
  return (ntStatus);
}
}
#line 512 "floppy.c"
NTSTATUS FlConfigCallBack(PVOID Context , PUNICODE_STRING PathName , INTERFACE_TYPE BusType ,
                          ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                          CONFIGURATION_TYPE ControllerType , ULONG ControllerNumber ,
                          PKEY_VALUE_FULL_INFORMATION *ControllerInformation , CONFIGURATION_TYPE PeripheralType ,
                          ULONG PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  ULONG i ;
  PCM_FULL_RESOURCE_DESCRIPTOR peripheralData ;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR partial ;
  PCM_FLOPPY_DEVICE_DATA fDeviceData ;
  UCHAR driveType ;
  PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants ;

  {
#line 577
  disketteExtension = (PDISKETTE_EXTENSION )Context;
#line 596
  if (! ((UCHAR *)*(PeripheralInformation + 1) + (*(PeripheralInformation + 1))->DataLength)) {
#line 600
    return (-1073741811L);
  }
#line 604
  peripheralData = (struct _CM_FULL_RESOURCE_DESCRIPTOR *)((UCHAR *)*(PeripheralInformation + 1) + (*(PeripheralInformation + 1))->DataOffset);
#line 619
  i = 0UL;
#line 619
  while (i < peripheralData->PartialResourceList.Count) {
#line 621
    partial = & peripheralData->PartialResourceList.PartialDescriptors[i];
#line 624
    if ((int )partial->Type == 5) {
#line 633
      biosDriveMediaConstants = & disketteExtension->BiosDriveMediaConstants;
#line 637
      fDeviceData = (struct _CM_FLOPPY_DEVICE_DATA *)(partial + 1);
#line 643
      switch ((int )fDeviceData->MaxDensity) {
      case 360: 
#line 645
      driveType = (unsigned char)0;
#line 645
      break;
      case 1200: 
#line 646
      driveType = (unsigned char)1;
#line 646
      break;
      case 1185: 
#line 647
      driveType = (unsigned char)1;
#line 647
      break;
      case 1423: 
#line 648
      driveType = (unsigned char)3;
#line 648
      break;
      case 1440: 
#line 649
      driveType = (unsigned char)3;
#line 649
      break;
      case 2880: 
#line 650
      driveType = (unsigned char)4;
#line 650
      break;
      case 1201: ;
#line 651
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 652
        driveType = (unsigned char)5;
#line 652
        break;
      }
      default: ;
#line 662
      while (1) {
#line 662
        break;
      }
#line 664
      driveType = (unsigned char)1;
#line 671
      while (1) {
#line 671
        break;
      }
#line 673
      break;
      }
#line 677
      disketteExtension->DriveType = driveType;
#line 684
      *biosDriveMediaConstants = *(DriveMediaConstants + (DriveMediaLimits + driveType)->HighestDriveMediaType);
#line 693
      if ((int )fDeviceData->Version >= 2) {
#line 698
        biosDriveMediaConstants->StepRateHeadUnloadTime = fDeviceData->StepRateHeadUnloadTime;
#line 701
        biosDriveMediaConstants->HeadLoadTime = fDeviceData->HeadLoadTime;
#line 704
        biosDriveMediaConstants->MotorOffTime = fDeviceData->MotorOffTime;
#line 707
        biosDriveMediaConstants->SectorLengthCode = fDeviceData->SectorLengthCode;
#line 712
        if ((int )fDeviceData->SectorPerTrack == 0) {
#line 716
          return (0L);
        }
#line 719
        if (fDeviceData->MaxDensity == 0UL) {
#line 727
          return (0L);
        }
#line 730
        biosDriveMediaConstants->SectorsPerTrack = fDeviceData->SectorPerTrack;
#line 733
        biosDriveMediaConstants->ReadWriteGapLength = fDeviceData->ReadWriteGapLength;
#line 736
        biosDriveMediaConstants->FormatGapLength = fDeviceData->FormatGapLength;
#line 739
        biosDriveMediaConstants->FormatFillCharacter = fDeviceData->FormatFillCharacter;
#line 742
        biosDriveMediaConstants->HeadSettleTime = fDeviceData->HeadSettleTime;
#line 745
        biosDriveMediaConstants->MotorSettleTimeRead = (unsigned short )(((int )fDeviceData->MotorSettleTime * 1000) / 8);
#line 748
        biosDriveMediaConstants->MotorSettleTimeWrite = (unsigned short )(((int )fDeviceData->MotorSettleTime * 1000) / 8);
#line 751
        if ((int )fDeviceData->MaximumTrackValue == 0) {
#line 755
          return (0L);
        }
#line 758
        biosDriveMediaConstants->MaximumTrack = fDeviceData->MaximumTrackValue;
#line 761
        biosDriveMediaConstants->DataLength = fDeviceData->DataTransferLength;
      }
    }
#line 619
    i ++;
  }
#line 767
  return (0L);
}
}
#line 770 "floppy.c"
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension , PFDC_INFO FdcInfo ) 
{ UCHAR driveType ;
  PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants ;

  {
#line 789
  biosDriveMediaConstants = & DisketteExtension->BiosDriveMediaConstants;
#line 792
  if (! FdcInfo->AcpiFdiSupported) {
#line 794
    return (-1073741823L);
  }
#line 802
  switch ((int )((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType)) {
  case 1: 
#line 804
  driveType = (unsigned char)0;
#line 804
  break;
  case 2: 
#line 805
  driveType = (unsigned char)1;
#line 805
  break;
  case 3: 
#line 806
  driveType = (unsigned char)2;
#line 806
  break;
  case 4: 
#line 807
  driveType = (unsigned char)3;
#line 807
  break;
  case 5: 
#line 808
  driveType = (unsigned char)4;
#line 808
  break;
  default: 
#line 810
  driveType = (unsigned char)1;
#line 810
  break;
  }
#line 814
  DisketteExtension->DriveType = driveType;
#line 821
  *biosDriveMediaConstants = *(DriveMediaConstants + (DriveMediaLimits + driveType)->HighestDriveMediaType);
#line 824
  biosDriveMediaConstants->StepRateHeadUnloadTime = (unsigned char )FdcInfo->AcpiFdiData.StepRateHeadUnloadTime;
#line 825
  biosDriveMediaConstants->HeadLoadTime = (unsigned char )FdcInfo->AcpiFdiData.HeadLoadTime;
#line 826
  biosDriveMediaConstants->MotorOffTime = (unsigned char )FdcInfo->AcpiFdiData.MotorOffTime;
#line 827
  biosDriveMediaConstants->SectorLengthCode = (unsigned char )FdcInfo->AcpiFdiData.SectorLengthCode;
#line 828
  biosDriveMediaConstants->SectorsPerTrack = (unsigned char )FdcInfo->AcpiFdiData.SectorPerTrack;
#line 829
  biosDriveMediaConstants->ReadWriteGapLength = (unsigned char )FdcInfo->AcpiFdiData.ReadWriteGapLength;
#line 830
  biosDriveMediaConstants->FormatGapLength = (unsigned char )FdcInfo->AcpiFdiData.FormatGapLength;
#line 831
  biosDriveMediaConstants->FormatFillCharacter = (unsigned char )FdcInfo->AcpiFdiData.FormatFillCharacter;
#line 832
  biosDriveMediaConstants->HeadSettleTime = (unsigned char )FdcInfo->AcpiFdiData.HeadSettleTime;
#line 833
  biosDriveMediaConstants->MotorSettleTimeRead = (unsigned short )(((int )((unsigned char )FdcInfo->AcpiFdiData.MotorSettleTime) * 1000) / 8);
#line 834
  biosDriveMediaConstants->MotorSettleTimeWrite = (unsigned short )(((int )((unsigned short )FdcInfo->AcpiFdiData.MotorSettleTime) * 1000) / 8);
#line 835
  biosDriveMediaConstants->MaximumTrack = (unsigned char )FdcInfo->AcpiFdiData.MaxCylinderNumber;
#line 836
  biosDriveMediaConstants->DataLength = (unsigned char )FdcInfo->AcpiFdiData.DataTransferLength;
#line 838
  return (0L);
}
}
#line 841 "floppy.c"
NTSTATUS FlQueueIrpToThread(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS status ;
  HANDLE threadHandle ;
  PIO_STACK_LOCATION irpSp ;
  OBJECT_ATTRIBUTES ObjAttributes ;

  {
#line 871
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 878
  ExAcquireFastMutex(& DisketteExtension->PowerDownMutex);
#line 879
  if ((int )DisketteExtension->PoweringDown == 1) {
#line 880
    ExReleaseFastMutex(& DisketteExtension->PowerDownMutex);
#line 882
    while (1) {
#line 882
      break;
    }
#line 884
    myStatus = -1073741101L;
#line 886
    Irp->IoStatus.__annonCompField4.Status = -1073741101L;
#line 887
    Irp->IoStatus.Information = 0UL;
#line 888
    return (-1073741101L);
  }
#line 890
  ExReleaseFastMutex(& DisketteExtension->PowerDownMutex);
#line 891
  while (1) {
#line 891
    break;
  }
#line 891
  ExAcquireFastMutex(& DisketteExtension->ThreadReferenceMutex);
#line 893
  (DisketteExtension->ThreadReferenceCount) ++;
#line 893
  if (DisketteExtension->ThreadReferenceCount == 0L) {
#line 896
    (DisketteExtension->ThreadReferenceCount) ++;
#line 898
    ExAcquireFastMutex(PagingMutex);
#line 898
    PagingReferenceCount ++;
#line 898
    if (PagingReferenceCount == 1UL) {
#line 898
      MmResetDriverPaging((void *)(& DriverEntry));
    }
#line 898
    ExReleaseFastMutex(PagingMutex);
#line 907
    ObjAttributes.Length = (unsigned long )sizeof(OBJECT_ATTRIBUTES );
#line 907
    ObjAttributes.RootDirectory = (void *)0;
#line 907
    ObjAttributes.Attributes = 512UL;
#line 907
    ObjAttributes.ObjectName = (UNICODE_STRING *)((void *)0);
#line 907
    ObjAttributes.SecurityDescriptor = (void *)0;
#line 907
    ObjAttributes.SecurityQualityOfService = (void *)0;
#line 909
    status = PsCreateSystemThread(& threadHandle, 0UL, & ObjAttributes, (void *)0L,
                                  (CLIENT_ID *)((void *)0), & FloppyThread, (void *)DisketteExtension);
#line 917
    if (! (status >= 0L)) {
#line 918
      DisketteExtension->ThreadReferenceCount = -1L;
#line 920
      ExAcquireFastMutex(PagingMutex);
#line 920
      PagingReferenceCount --;
#line 920
      if (PagingReferenceCount == 0UL) {
#line 920
        MmPageEntireDriver((void *)(& DriverEntry));
      }
#line 920
      ExReleaseFastMutex(PagingMutex);
#line 922
      ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex);
#line 923
      return (status);
    }
#line 926
    status = ObReferenceObjectByHandle(threadHandle, 1048576UL, (struct _OBJECT_TYPE *)((void *)0),
                                       (char)0, (PVOID *)(& DisketteExtension->FloppyThread),
                                       (struct _OBJECT_HANDLE_INFORMATION *)((void *)0));
#line 935
    ZwClose(threadHandle);
#line 937
    ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex);
#line 939
    if (! (status >= 0L)) {
#line 940
      return (status);
    }
  } else {
#line 944
    ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex);
  }
#line 947
  (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (unsigned char )((int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1);
#line 948
  if (pended == 0) {
#line 948
    pended = 1;
  } else {
#line 949
     assert(0);
  }
#line 952
  ExfInterlockedInsertTailList(& DisketteExtension->ListEntry, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                               & DisketteExtension->ListSpinLock);
#line 957
  KeReleaseSemaphore(& DisketteExtension->RequestSemaphore, 0L, 1L, (unsigned char)0);
#line 963
  return (259L);
}
}
#line 966 "floppy.c"
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ 

  {
#line 999
  while (1) {
#line 999
    break;
  }
#line 1007
  myStatus = 0L;
#line 1009
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 1010
  Irp->IoStatus.Information = 1UL;
#line 1010
  IofCompleteRequest(Irp, (char)0);
#line 1012
  return (0L);
}
}
#line 1015 "floppy.c"
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  PDISKETTE_EXTENSION disketteExtension ;
  PDISK_GEOMETRY outputBuffer ;
  NTSTATUS ntStatus ;
  ULONG outputBufferLength ;
  UCHAR i ;
  DRIVE_MEDIA_TYPE lowestDriveMediaType ;
  DRIVE_MEDIA_TYPE highestDriveMediaType ;
  ULONG formatExParametersSize ;
  PFORMAT_EX_PARAMETERS formatExParameters ;
  NTSTATUS tmp ;
  PMOUNTDEV_NAME mountName ;
  PMOUNTDEV_UNIQUE_ID uniqueId ;
  BOOLEAN tmp___0 ;
  PMOUNTDEV_SUGGESTED_LINK_NAME suggestedName ;
  WCHAR driveLetterNameBuffer[10] ;
  RTL_QUERY_REGISTRY_TABLE queryTable[2] ;
  PWSTR valueName ;
  UNICODE_STRING driveLetterName ;
  PVOID tmp___1 ;
  int tmp___2 ;

  {
#line 1054
  while (1) {
#line 1054
    break;
  }
#line 1056
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 1057
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 1062
  ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1063
  if (disketteExtension->HoldNewRequests) {
#line 1070
    if (irpSp->Parameters.DeviceIoControl.IoControlCode != (ULONG )((50 << 16) | (3 << 14))) {
#line 1072
      ntStatus = FloppyQueueRequest(disketteExtension, Irp);
#line 1074
      ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1075
      return (ntStatus);
    }
  }
#line 1078
  ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1083
  if (disketteExtension->IsRemoved) {
#line 1085
    Irp->IoStatus.Information = 0UL;
#line 1086
    Irp->IoStatus.__annonCompField4.Status = -1073741738L;
#line 1087
    myStatus = -1073741738L;
#line 1088
    IofCompleteRequest(Irp, (char)0);
#line 1089
    return (-1073741738L);
  }
#line 1095
  if (! disketteExtension->IsStarted) {
#line 1097
    if (s == NP) {
#line 1097
      s = SKIP1;
    } else {
#line 1098
       assert(0);
    }
#line 1099
    Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 1099
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 1100
    tmp = IofCallDriver(disketteExtension->TargetObject, Irp);
#line 1100
    return (tmp);
  }
#line 1103
  switch ((int )irpSp->Parameters.DeviceIoControl.IoControlCode) {
  case (77UL << 16) | (unsigned long )(2 << 2): ;
#line 1109
  while (1) {
#line 1109
    break;
  }
#line 1112
  if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(MOUNTDEV_NAME )) {
#line 1115
    ntStatus = -1073741811L;
#line 1116
    break;
  }
#line 1119
  mountName = (struct _MOUNTDEV_NAME *)Irp->AssociatedIrp.SystemBuffer;
#line 1120
  mountName->NameLength = disketteExtension->DeviceName.Length;
#line 1122
  if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )(sizeof(USHORT ) + (unsigned int )mountName->NameLength)) {
#line 1125
    ntStatus = -2147483643L;
#line 1126
    Irp->IoStatus.Information = (unsigned long )sizeof(MOUNTDEV_NAME );
#line 1127
    break;
  }
#line 1131
  memcpy((void *)(mountName->Name), (void const   *)disketteExtension->DeviceName.Buffer,
         (unsigned int )mountName->NameLength);
#line 1133
  ntStatus = 0L;
#line 1134
  Irp->IoStatus.Information = (unsigned long )(sizeof(USHORT ) + (unsigned int )mountName->NameLength);
#line 1135
  break;
  case 77UL << 16: ;
#line 1142
  while (1) {
#line 1142
    break;
  }
#line 1144
  if (! disketteExtension->InterfaceString.Buffer) {
#line 1148
    ntStatus = -1073741811L;
#line 1149
    break;
  } else {
#line 1144
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(MOUNTDEV_UNIQUE_ID )) {
#line 1148
      ntStatus = -1073741811L;
#line 1149
      break;
    }
  }
#line 1152
  uniqueId = (struct _MOUNTDEV_UNIQUE_ID *)Irp->AssociatedIrp.SystemBuffer;
#line 1153
  uniqueId->UniqueIdLength = disketteExtension->InterfaceString.Length;
#line 1156
  if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )(sizeof(USHORT ) + (unsigned int )uniqueId->UniqueIdLength)) {
#line 1159
    ntStatus = -2147483643L;
#line 1160
    Irp->IoStatus.Information = (unsigned long )sizeof(MOUNTDEV_UNIQUE_ID );
#line 1161
    break;
  }
#line 1166
  memcpy((void *)(uniqueId->UniqueId), (void const   *)disketteExtension->InterfaceString.Buffer,
         (unsigned int )uniqueId->UniqueIdLength);
#line 1168
  ntStatus = 0L;
#line 1169
  Irp->IoStatus.Information = (unsigned long )(sizeof(USHORT ) + (unsigned int )uniqueId->UniqueIdLength);
#line 1171
  break;
  case ((7 << 16) | (3 << 14)) | (6 << 2): ;
  case ((7 << 16) | (3 << 14)) | (11 << 2): ;
#line 1181
  if (irpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG )sizeof(FORMAT_PARAMETERS )) {
#line 1187
    while (1) {
#line 1187
      break;
    }
#line 1189
    ntStatus = -1073741811L;
#line 1190
    break;
  }
#line 1197
  tmp___0 = FlCheckFormatParameters(disketteExtension, (struct _FORMAT_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer);
#line 1197
  if (! tmp___0) {
#line 1204
    while (1) {
#line 1204
      break;
    }
#line 1206
    ntStatus = -1073741811L;
#line 1207
    break;
  }
#line 1214
  if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (3 << 14)) | (11 << 2))) {
#line 1217
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG )sizeof(FORMAT_EX_PARAMETERS )) {
#line 1220
      ntStatus = -1073741811L;
#line 1221
      break;
    }
#line 1224
    formatExParameters = (struct _FORMAT_EX_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
#line 1226
    formatExParametersSize = (unsigned long )((long )(& ((FORMAT_EX_PARAMETERS *)0)->SectorNumber)) + (unsigned long )((unsigned int )formatExParameters->SectorsPerTrack * sizeof(USHORT ));
#line 1230
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < formatExParametersSize) {
#line 1235
      ntStatus = -1073741811L;
#line 1236
      break;
    } else {
#line 1230
      if ((int )formatExParameters->FormatGapLength >= 256) {
#line 1235
        ntStatus = -1073741811L;
#line 1236
        break;
      } else {
#line 1230
        if ((int )formatExParameters->SectorsPerTrack >= 256) {
#line 1235
          ntStatus = -1073741811L;
#line 1236
          break;
        }
      }
    }
  }
  case ((7 << 16) | (1 << 14)) | (512 << 2): ;
  case ((45 << 16) | (1 << 14)) | (512 << 2): ;
  case 7 << 16: ;
  case (7 << 16) | (9 << 2): ;
#line 1267
  while (1) {
#line 1267
    break;
  }
#line 1269
  ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
#line 1271
  break;
  case (7 << 16) | (768 << 2): ;
  case (45 << 16) | (768 << 2): ;
#line 1279
  while (1) {
#line 1279
    break;
  }
#line 1281
  lowestDriveMediaType = (DriveMediaLimits + disketteExtension->DriveType)->LowestDriveMediaType;
#line 1283
  highestDriveMediaType = (DriveMediaLimits + disketteExtension->DriveType)->HighestDriveMediaType;
#line 1286
  outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
#line 1294
  if (outputBufferLength < (ULONG )sizeof(DISK_GEOMETRY )) {
#line 1299
    while (1) {
#line 1299
      break;
    }
#line 1301
    ntStatus = -1073741789L;
#line 1302
    break;
  }
#line 1311
  ntStatus = 0L;
#line 1313
  if (outputBufferLength < (ULONG )(sizeof(DISK_GEOMETRY ) * (unsigned int )(((int )highestDriveMediaType - (int )lowestDriveMediaType) + 1))) {
#line 1324
    while (1) {
#line 1324
      break;
    }
#line 1326
    ntStatus = -2147483643L;
#line 1328
    highestDriveMediaType = (enum _DRIVE_MEDIA_TYPE )((ULONG )((int )lowestDriveMediaType - 1) + outputBufferLength / (ULONG )sizeof(DISK_GEOMETRY ));
  }
#line 1334
  outputBuffer = (struct _DISK_GEOMETRY *)Irp->AssociatedIrp.SystemBuffer;
#line 1336
  i = (unsigned char )lowestDriveMediaType;
#line 1336
  while ((int )i <= (int )((unsigned char )highestDriveMediaType)) {
#line 1341
    outputBuffer->MediaType = (DriveMediaConstants + i)->MediaType;
#line 1342
    outputBuffer->Cylinders.__annonCompField1.LowPart = (unsigned long )((int )(DriveMediaConstants + i)->MaximumTrack + 1);
#line 1344
    outputBuffer->Cylinders.__annonCompField1.HighPart = 0L;
#line 1345
    outputBuffer->TracksPerCylinder = (unsigned long )(DriveMediaConstants + i)->NumberOfHeads;
#line 1347
    outputBuffer->SectorsPerTrack = (unsigned long )(DriveMediaConstants + i)->SectorsPerTrack;
#line 1349
    outputBuffer->BytesPerSector = (unsigned long )(DriveMediaConstants + i)->BytesPerSector;
#line 1367
    while (1) {
#line 1367
      break;
    }
#line 1368
    outputBuffer ++;
#line 1370
    Irp->IoStatus.Information += (ULONG_PTR )sizeof(DISK_GEOMETRY );
#line 1336
    i = (UCHAR )((int )i + 1);
  }
#line 1373
  break;
  case (77UL << 16) | (unsigned long )(3 << 2): ;
#line 1378
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 1387
    while (1) {
#line 1387
      break;
    }
#line 1389
    if (! (DeviceObject->Characteristics & 1UL)) {
#line 1391
      ntStatus = -1073741275L;
#line 1392
      break;
    }
#line 1395
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(MOUNTDEV_SUGGESTED_LINK_NAME )) {
#line 1398
      ntStatus = -1073741811L;
#line 1399
      break;
    }
#line 1402
    tmp___1 = ExAllocatePoolWithTag(1, (unsigned long )(sizeof(WCHAR ) * 64U), 1886350406UL);
#line 1402
    valueName = (WCHAR *)tmp___1;
#line 1404
    if (! valueName) {
#line 1405
      ntStatus = -1073741670L;
#line 1406
      break;
    }
#line 1409
    memset((void *)valueName, 0, sizeof(WCHAR ) * 64U);
#line 1412
    memcpy((void *)valueName, (void const   *)disketteExtension->DeviceName.Buffer,
           (unsigned int )disketteExtension->DeviceName.Length);
#line 1414
    driveLetterName.Buffer = driveLetterNameBuffer;
#line 1415
    driveLetterName.MaximumLength = (unsigned short)20;
#line 1416
    driveLetterName.Length = (unsigned short)0;
#line 1418
    memset((void *)(queryTable), 0, 2U * sizeof(RTL_QUERY_REGISTRY_TABLE ));
#line 1419
    queryTable[0].Flags = 36UL;
#line 1421
    queryTable[0].Name = valueName;
#line 1422
    queryTable[0].EntryContext = (void *)(& driveLetterName);
#line 1424
    ntStatus = RtlQueryRegistryValues(0UL, (WCHAR const   *)"\\\000R\000e\000g\000i\000s\000t\000r\000y\000\\\000M\000a\000c\000h\000i\000n\000e\000\\\000S\000y\000s\000t\000e\000m\000\\\000D\000I\000S\000K\000",
                                      queryTable, (void *)0, (void *)0);
#line 1428
    if (! (ntStatus >= 0L)) {
#line 1429
      ExFreePool((void *)valueName);
#line 1430
      break;
    }
#line 1433
    if ((int )driveLetterName.Length != 4) {
#line 1438
      ntStatus = -1073741275L;
#line 1439
      ExFreePool((void *)valueName);
#line 1440
      break;
    } else {
#line 1433
      if ((int )*(driveLetterName.Buffer + 0) < 65) {
#line 1438
        ntStatus = -1073741275L;
#line 1439
        ExFreePool((void *)valueName);
#line 1440
        break;
      } else {
#line 1433
        if ((int )*(driveLetterName.Buffer + 0) > 90) {
#line 1438
          ntStatus = -1073741275L;
#line 1439
          ExFreePool((void *)valueName);
#line 1440
          break;
        } else {
#line 1433
          if ((int )*(driveLetterName.Buffer + 1) != 58) {
#line 1438
            ntStatus = -1073741275L;
#line 1439
            ExFreePool((void *)valueName);
#line 1440
            break;
          }
        }
      }
    }
#line 1443
    suggestedName = (struct _MOUNTDEV_SUGGESTED_LINK_NAME *)Irp->AssociatedIrp.SystemBuffer;
#line 1444
    suggestedName->UseOnlyIfThereAreNoOtherLinks = (unsigned char)1;
#line 1445
    suggestedName->NameLength = (unsigned short)28;
#line 1447
    Irp->IoStatus.Information = (unsigned long )((long )(& ((MOUNTDEV_SUGGESTED_LINK_NAME *)0)->Name) + 28L);
#line 1450
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < Irp->IoStatus.Information) {
#line 1453
      Irp->IoStatus.Information = (unsigned long )sizeof(MOUNTDEV_SUGGESTED_LINK_NAME );
#line 1455
      ntStatus = -2147483643L;
#line 1456
      ExFreePool((void *)valueName);
#line 1457
      break;
    }
#line 1460
    RtlDeleteRegistryValue(0UL, (WCHAR const   *)"\\\000R\000e\000g\000i\000s\000t\000r\000y\000\\\000M\000a\000c\000h\000i\000n\000e\000\\\000S\000y\000s\000t\000e\000m\000\\\000D\000I\000S\000K\000",
                           (WCHAR const   *)valueName);
#line 1464
    ExFreePool((void *)valueName);
#line 1466
    memcpy((void *)(suggestedName->Name), (void const   *)"\\\000D\000o\000s\000D\000e\000v\000i\000c\000e\000s\000\\\000",
           24U);
#line 1467
    suggestedName->Name[12] = *(driveLetterName.Buffer + 0);
#line 1468
    suggestedName->Name[13] = (unsigned short )':';
#line 1470
    break;
  }
  case (7 << 16) | (248 << 2): ;
#line 1478
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 1482
    while (1) {
#line 1482
      break;
    }
#line 1488
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(SENSE_DEVISE_STATUS_PTOS )) {
#line 1494
      while (1) {
#line 1494
        break;
      }
#line 1496
      ntStatus = -1073741811L;
#line 1497
      break;
    }
#line 1507
    while (1) {
#line 1507
      break;
    }
#line 1510
    ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
#line 1512
    break;
  }
  default: ;
#line 1533
  if (s == NP) {
#line 1533
    s = SKIP1;
  } else {
#line 1534
    assert(0);
  }
#line 1535
  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 1535
  (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 1536
  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
#line 1537
  return (ntStatus);
  }
#line 1541
  if (ntStatus != 259L) {
#line 1543
    Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 1544
    myStatus = ntStatus;
#line 1546
    if (! (ntStatus >= 0L)) {
#line 1546
      if (ntStatus == -1073741661L) {
#line 1546
        tmp___2 = 1;
      } else {
#line 1546
        if (ntStatus == -1073741643L) {
#line 1546
          tmp___2 = 1;
        } else {
#line 1546
          if (ntStatus == -1073741662L) {
#line 1546
            tmp___2 = 1;
          } else {
#line 1546
            if (ntStatus == -1073741805L) {
#line 1546
              tmp___2 = 1;
            } else {
#line 1546
              if (ntStatus == -2147483626L) {
#line 1546
                tmp___2 = 1;
              } else {
#line 1546
                if (ntStatus == -1073741804L) {
#line 1546
                  tmp___2 = 1;
                } else {
#line 1546
                  if (ntStatus == -1073741806L) {
#line 1546
                    tmp___2 = 1;
                  } else {
#line 1546
                    tmp___2 = 0;
                  }
                }
              }
            }
          }
        }
      }
#line 1546
      if ((unsigned char )tmp___2) {
#line 1547
        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
      }
    }
#line 1550
    IofCompleteRequest(Irp, (char)0);
  }
#line 1553
  return (ntStatus);
}
}
#line 1556 "floppy.c"
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  KEVENT doneEvent ;
  PIO_STACK_LOCATION irpSp___0 ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___1 ;
  PCONFIGURATION_INFORMATION tmp ;

  {
#line 1580
  ntStatus = 0L;
#line 1583
  while (1) {
#line 1583
    break;
  }
#line 1588
  ExAcquireFastMutex(PagingMutex);
#line 1588
  PagingReferenceCount ++;
#line 1588
  if (PagingReferenceCount == 1UL) {
#line 1588
    MmResetDriverPaging((void *)(& DriverEntry));
  }
#line 1588
  ExReleaseFastMutex(PagingMutex);
#line 1591
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 1593
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 1595
  if (disketteExtension->IsRemoved) {
#line 1601
    Irp->IoStatus.Information = 0UL;
#line 1602
    Irp->IoStatus.__annonCompField4.Status = -1073741738L;
#line 1603
    myStatus = -1073741738L;
#line 1605
    IofCompleteRequest(Irp, (char)0);
#line 1606
    return (-1073741738L);
  }
#line 1607
  switch ((int )irpSp->MinorFunction) {
  case 0: 
#line 1611
  ntStatus = FloppyStartDevice(DeviceObject, Irp);
#line 1612
  break;
  case 5: ;
  case 1: ;
#line 1617
  if ((int )irpSp->MinorFunction == 5) {
#line 1618
    while (1) {
#line 1618
      break;
    }
  } else {
#line 1620
    while (1) {
#line 1620
      break;
    }
  }
#line 1623
  if (! disketteExtension->IsStarted) {
#line 1627
    if (s == NP) {
#line 1627
      s = SKIP1;
    } else {
#line 1627
      assert(0);
    }
#line 1628
    Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 1628
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 1629
    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
#line 1631
    return (ntStatus);
  }
#line 1637
  ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1638
  disketteExtension->HoldNewRequests = (unsigned char)1;
#line 1639
  ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1646
  ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
#line 1652
  if (ntStatus == 259L) {
#line 1656
    KeWaitForSingleObject((void *)disketteExtension->FloppyThread, 0, (char)0, (unsigned char)0,
                          (LARGE_INTEGER *)((void *)0));
#line 1666
    if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {
#line 1667
      ObfDereferenceObject((void *)disketteExtension->FloppyThread);
    }
#line 1670
    disketteExtension->FloppyThread = (struct _KTHREAD *)((void *)0);
#line 1672
    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 1673
    myStatus = 0L;
#line 1674
    if (s == NP) {
#line 1673
      s = SKIP1;
    } else {
#line 1673
       assert(0);
    }
#line 1674
    Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 1674
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 1675
    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
  } else {
#line 1682
    ntStatus = -1073741823L;
#line 1683
    Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 1684
    myStatus = ntStatus;
#line 1686
    Irp->IoStatus.Information = 0UL;
#line 1687
    IofCompleteRequest(Irp, (char)0);
  }
#line 1689
  break;
  case 6: ;
  case 3: ;
#line 1692
  if ((int )irpSp->MinorFunction == 6) {
#line 1693
    while (1) {
#line 1693
      break;
    }
  } else {
#line 1695
    while (1) {
#line 1695
      break;
    }
  }
#line 1698
  if (! disketteExtension->IsStarted) {
#line 1706
    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 1707
    myStatus = 0L;
#line 1709
    if (s == NP) {
#line 1707
      s = SKIP1;
    } else {
#line 1707
      assert(0);
    }
#line 1708
    Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 1708
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 1709
    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
  } else {
#line 1718
    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 1719
    myStatus = 0L;
#line 1723
    irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 1723
    nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 1723
    memcpy((void *)nextIrpSp, (void const   *)irpSp___0, (unsigned int )((long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine)));
#line 1723
    nextIrpSp->Control = (unsigned char)0;
#line 1729
    KeInitializeEvent(& doneEvent, 1, (unsigned char)0);
#line 1733
    if (s != NP) {
#line 1733
      assert(0);
    } else {
#line 1735
      if (compRegistered != 0) {
#line 1735
        assert(0);
      } else {
#line 1737
        compRegistered = 1;
#line 1738
        compFptr = & FloppyPnpComplete;
      }
    }
#line 1744
    irpSp___1 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 1744
    irpSp___1->CompletionRoutine = & FloppyPnpComplete;
#line 1744
    irpSp___1->Context = (void *)(& doneEvent);
#line 1744
    irpSp___1->Control = (unsigned char)0;
#line 1744
    irpSp___1->Control = (unsigned char)64;
#line 1744
    irpSp___1->Control = (unsigned char )((int )irpSp___1->Control | 128);
#line 1744
    irpSp___1->Control = (unsigned char )((int )irpSp___1->Control | 32);
#line 1746
    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
#line 1748
    if (ntStatus == 259L) {
#line 1750
      KeWaitForSingleObject((void *)(& doneEvent), 0, (char)0, (unsigned char)0, (LARGE_INTEGER *)((void *)0));
#line 1757
      ntStatus = myStatus;
    }
#line 1759
    ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1760
    disketteExtension->HoldNewRequests = (unsigned char)0;
#line 1761
    ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1766
    FloppyProcessQueuedRequests(disketteExtension);
#line 1772
    Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 1773
    myStatus = ntStatus;
#line 1775
    Irp->IoStatus.Information = 0UL;
#line 1776
    IofCompleteRequest(Irp, (char)0);
  }
#line 1778
  break;
  case 4: ;
#line 1780
  while (1) {
#line 1780
    break;
  }
#line 1782
  disketteExtension->IsStarted = (unsigned char)0;
#line 1784
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 1785
  myStatus = 0L;
#line 1786
  if (s == NP) {
#line 1785
    s = SKIP1;
  } else {
#line 1785
    assert(0);
  }
#line 1786
  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 1786
  (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 1787
  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
#line 1789
  break;
  case 2: ;
#line 1793
  while (1) {
#line 1793
    break;
  }
#line 1800
  ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1801
  disketteExtension->HoldNewRequests = (unsigned char)0;
#line 1802
  ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
#line 1804
  disketteExtension->IsStarted = (unsigned char)0;
#line 1805
  disketteExtension->IsRemoved = (unsigned char)1;
#line 1815
  FloppyProcessQueuedRequests(disketteExtension);
#line 1820
  if (s == NP) {
#line 1820
    s = SKIP1;
  } else {
#line 1820
    assert(0);
  }
#line 1821
  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 1821
  (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 1822
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 1823
  myStatus = 0L;
#line 1824
  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
#line 1828
  if ((unsigned int )disketteExtension->InterfaceString.Buffer != (unsigned int )((void *)0)) {
#line 1830
    IoSetDeviceInterfaceState(& disketteExtension->InterfaceString, (unsigned char)0);
#line 1833
    RtlFreeUnicodeString(& disketteExtension->InterfaceString);
#line 1834
    RtlInitUnicodeString(& disketteExtension->InterfaceString, (WCHAR const   *)((void *)0));
  }
#line 1837
  RtlFreeUnicodeString(& disketteExtension->DeviceName);
#line 1838
  RtlInitUnicodeString(& disketteExtension->DeviceName, (WCHAR const   *)((void *)0));
#line 1840
  if ((int )disketteExtension->ArcName.Length != 0) {
#line 1842
    IoDeleteSymbolicLink(& disketteExtension->ArcName);
#line 1843
    RtlFreeUnicodeString(& disketteExtension->ArcName);
#line 1844
    RtlInitUnicodeString(& disketteExtension->ArcName, (WCHAR const   *)((void *)0));
  }
#line 1850
  IoDetachDevice(disketteExtension->TargetObject);
#line 1855
  IoDeleteDevice(DeviceObject);
#line 1857
  tmp = IoGetConfigurationInformation();
#line 1857
  (tmp->FloppyCount) --;
#line 1859
  break;
  default: ;
#line 1862
  while (1) {
#line 1862
    break;
  }
#line 1863
  if (s == NP) {
#line 1863
    s = SKIP1;
  } else {
#line 1863
    assert(0);
  }
#line 1864
  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 1864
  (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 1865
  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
  }
#line 1871
  ExAcquireFastMutex(PagingMutex);
#line 1871
  PagingReferenceCount --;
#line 1871
  if (PagingReferenceCount == 0UL) {
#line 1871
    MmPageEntireDriver((void *)(& DriverEntry));
  }
#line 1871
  ExReleaseFastMutex(PagingMutex);
#line 1873
  return (ntStatus);
}
}
#line 1876 "floppy.c"
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ NTSTATUS ntStatus ;
  NTSTATUS pnpStatus ;
  KEVENT doneEvent ;
  FDC_INFO fdcInfo ;
  CONFIGURATION_TYPE Dc ;
  CONFIGURATION_TYPE Fp ;
  PDISKETTE_EXTENSION disketteExtension ;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION irpSp___0 ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___1 ;
  INTERFACE_TYPE InterfaceType ;

  {
#line 1887
  Dc = 13;
#line 1888
  Fp = 26;
#line 1890
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 1891
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 1893
  while (1) {
#line 1893
    break;
  }
#line 1894
  while (1) {
#line 1894
    break;
  }
#line 1895
  while (1) {
#line 1895
    break;
  }
#line 1900
  KeInitializeEvent(& doneEvent, 0, (unsigned char)0);
#line 1902
  irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 1902
  nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 1902
  memcpy((void *)nextIrpSp, (void const   *)irpSp___0, (unsigned int )((long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine)));
#line 1902
  nextIrpSp->Control = (unsigned char)0;
#line 1904
  if (s != NP) {
#line 1904
    assert(0);
  } else {
#line 1906
    if (compRegistered != 0) {
#line 1906
      assert(0);
    } else {
#line 1908
      compRegistered = 1;
#line 1909
      compFptr = & FloppyPnpComplete;
    }
  }
#line 1915
  irpSp___1 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 1915
  irpSp___1->CompletionRoutine = & FloppyPnpComplete;
#line 1915
  irpSp___1->Context = (void *)(& doneEvent);
#line 1915
  irpSp___1->Control = (unsigned char)0;
#line 1915
  irpSp___1->Control = (unsigned char)64;
#line 1915
  irpSp___1->Control = (unsigned char )((int )irpSp___1->Control | 128);
#line 1915
  irpSp___1->Control = (unsigned char )((int )irpSp___1->Control | 32);
#line 1917
  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
#line 1919
  if (ntStatus == 259L) {
#line 1921
    ntStatus = KeWaitForSingleObject((void *)(& doneEvent), 0, (char)0, (unsigned char)0,
                                     (LARGE_INTEGER *)((void *)0));
#line 1930
    ntStatus = myStatus;
  }
#line 1932
  fdcInfo.BufferCount = 0UL;
#line 1933
  fdcInfo.BufferSize = 0UL;
#line 1935
  ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (770 << 2)) | 3),
                           (void *)(& fdcInfo));
#line 1939
  if (ntStatus >= 0L) {
#line 1941
    disketteExtension->MaxTransferSize = fdcInfo.MaxTransferSize;
#line 1943
    if (fdcInfo.AcpiBios) {
#line 1943
      if (fdcInfo.AcpiFdiSupported) {
#line 1946
        ntStatus = FlAcpiConfigureFloppy(disketteExtension, & fdcInfo);
#line 1948
        if ((int )disketteExtension->DriveType == 4) {
#line 1950
          disketteExtension->PerpendicularMode = (unsigned char )((int )disketteExtension->PerpendicularMode | (1 << fdcInfo.PeripheralNumber));
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1957
      if ((int )disketteExtension->DriveType == 4) {
#line 1959
        disketteExtension->PerpendicularMode = (unsigned char )((int )disketteExtension->PerpendicularMode | (1 << fdcInfo.PeripheralNumber));
      }
#line 1966
      InterfaceType = (enum _INTERFACE_TYPE )0;
#line 1966
      while ((int )InterfaceType < 16) {
#line 1970
        fdcInfo.BusType = InterfaceType;
#line 1971
        ntStatus = IoQueryDeviceDescription(& fdcInfo.BusType, & fdcInfo.BusNumber,
                                            & Dc, & fdcInfo.ControllerNumber, & Fp,
                                            & fdcInfo.PeripheralNumber, & FlConfigCallBack,
                                            (void *)disketteExtension);
#line 1980
        if (ntStatus >= 0L) {
#line 1985
          while (1) {
#line 1985
            break;
          }
#line 1986
          break;
        }
#line 1966
        InterfaceType = (INTERFACE_TYPE )((int )InterfaceType + 1);
      }
    }
#line 1991
    if (ntStatus >= 0L) {
#line 1993
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 1994
        disketteExtension->DeviceUnit = (unsigned char )fdcInfo.UnitNumber;
#line 1995
        disketteExtension->DriveOnValue = (unsigned char )fdcInfo.UnitNumber;
      } else {
#line 1997
        disketteExtension->DeviceUnit = (unsigned char )fdcInfo.PeripheralNumber;
#line 1998
        disketteExtension->DriveOnValue = (unsigned char )(fdcInfo.PeripheralNumber | (unsigned long )(16 << fdcInfo.PeripheralNumber));
      }
#line 2002
      pnpStatus = IoRegisterDeviceInterface(disketteExtension->UnderlyingPDO, (GUID const   *)((GUID *)(& MOUNTDEV_MOUNTED_DEVICE_GUID)),
                                            (UNICODE_STRING *)((void *)0), & disketteExtension->InterfaceString);
#line 2007
      if (pnpStatus >= 0L) {
#line 2009
        pnpStatus = IoSetDeviceInterfaceState(& disketteExtension->InterfaceString,
                                              (unsigned char)1);
      }
#line 2013
      disketteExtension->IsStarted = (unsigned char)1;
#line 2015
      ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
#line 2016
      disketteExtension->HoldNewRequests = (unsigned char)0;
#line 2017
      ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
#line 2019
      FloppyProcessQueuedRequests(disketteExtension);
    }
  }
#line 2023
  Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 2024
  myStatus = ntStatus;
#line 2025
  IofCompleteRequest(Irp, (char)0);
#line 2026
  return (ntStatus);
}
}
#line 2029 "floppy.c"
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) 
{ 

  {
#line 2043
  KeSetEvent((struct _KEVENT *)Context, 1L, (unsigned char)0);
#line 2047
  return (-1073741802L);
}
}
#line 2050 "floppy.c"
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  PIO_STACK_LOCATION irpSp ;
  POWER_STATE_TYPE type ;
  POWER_STATE state ;
  BOOLEAN WaitForCompletion ;

  {
#line 2071
  ntStatus = myStatus;
#line 2075
  WaitForCompletion = (BOOLEAN )1;
#line 2077
  while (1) {
#line 2077
    break;
  }
#line 2079
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 2080
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 2082
  type = irpSp->Parameters.Power.Type;
#line 2083
  state = irpSp->Parameters.Power.State;
#line 2085
  switch ((int )irpSp->MinorFunction) {
  case 3: ;
#line 2090
  while (1) {
#line 2090
    break;
  }
#line 2092
  if ((int )type == 0) {
#line 2092
    if ((int )state.SystemState > 5) {
#line 2097
      ntStatus = 0L;
#line 2098
      break;
    }
  }
#line 2107
  ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 2108
  if (disketteExtension->ThreadReferenceCount >= 0L) {
#line 2109
    ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 2111
    while (1) {
#line 2111
      break;
    }
#line 2113
    PoStartNextPowerIrp(Irp);
#line 2114
    Irp->IoStatus.Information = 0UL;
#line 2115
    Irp->IoStatus.__annonCompField4.Status = -2147483631L;
#line 2116
    myStatus = -2147483631L;
#line 2117
    IofCompleteRequest(Irp, (char)0);
#line 2118
    return (-2147483631L);
  }
#line 2120
  ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 2122
  ntStatus = 0L;
#line 2123
  break;
  case 2: ;
#line 2131
  if ((int )type == 0) {
#line 2132
    ExAcquireFastMutex(& disketteExtension->PowerDownMutex);
#line 2133
    if ((int )state.SystemState == 1) {
#line 2134
      while (1) {
#line 2134
        break;
      }
#line 2135
      disketteExtension->PoweringDown = (unsigned char)0;
#line 2136
      WaitForCompletion = (unsigned char)0;
    } else {
#line 2138
      while (1) {
#line 2138
        break;
      }
#line 2139
      WaitForCompletion = (unsigned char)1;
#line 2140
      disketteExtension->PoweringDown = (unsigned char)1;
    }
#line 2142
    ExReleaseFastMutex(& disketteExtension->PowerDownMutex);
#line 2147
    if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {
#line 2147
      if ((int )WaitForCompletion == 1) {
#line 2149
        KeWaitForSingleObject((void *)disketteExtension->FloppyThread, 0, (char)0,
                              (unsigned char)0, (LARGE_INTEGER *)((void *)0));
      }
    }
  }
#line 2157
  while (1) {
#line 2157
    break;
  }
#line 2158
  ntStatus = 0L;
#line 2159
  break;
  default: ;
#line 2163
  break;
  }
#line 2168
  PoStartNextPowerIrp(Irp);
#line 2169
  if (s == NP) {
#line 2169
    s = SKIP1;
  } else {
#line 2169
     assert(0);
  }
#line 2170
  Irp->CurrentLocation = (CHAR )((int )Irp->CurrentLocation + 1);
#line 2170
  (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) ++;
#line 2171
  ntStatus = PoCallDriver(disketteExtension->TargetObject, Irp);
#line 2173
  return (ntStatus);
}
}
#line 2176 "floppy.c"
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  NTSTATUS ntStatus ;
  PDISKETTE_EXTENSION disketteExtension ;

  {
#line 2208
  while (1) {
#line 2208
    break;
  }
#line 2210
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 2212
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 2218
  ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
#line 2219
  if (disketteExtension->HoldNewRequests) {
#line 2221
    ntStatus = FloppyQueueRequest(disketteExtension, Irp);
#line 2223
    ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
#line 2224
    return (ntStatus);
  }
#line 2226
  ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
#line 2232
  if (disketteExtension->IsRemoved) {
    goto _L;
  } else {
#line 2232
    if (! disketteExtension->IsStarted) {
      _L: /* CIL Label */ 
#line 2234
      if (disketteExtension->IsRemoved) {
#line 2235
        ntStatus = -1073741738L;
      } else {
#line 2237
        ntStatus = -1073741823L;
      }
#line 2239
      Irp->IoStatus.Information = 0UL;
#line 2240
      Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 2241
      myStatus = ntStatus;
#line 2242
      IofCompleteRequest(Irp, (char)0);
#line 2243
      return (ntStatus);
    }
  }
#line 2245
  if ((int )disketteExtension->MediaType > 0) {
#line 2245
    if (irpSp->Parameters.Read.ByteOffset.__annonCompField1.LowPart + irpSp->Parameters.Read.Length > disketteExtension->ByteCapacity) {
      goto _L___1;
    } else {
#line 2245
      if ((irpSp->Parameters.Read.Length & (disketteExtension->BytesPerSector - 1UL)) != 0UL) {
        _L___1: /* CIL Label */ 
#line 2252
        while (1) {
#line 2252
          break;
        }
#line 2261
        while (1) {
#line 2261
          break;
        }
#line 2263
        ntStatus = -1073741811L;
      } else {
        goto _L___0;
      }
    }
  } else {
    _L___0: /* CIL Label */ 
#line 2272
    if (irpSp->Parameters.Read.Length) {
#line 2279
      while (1) {
#line 2279
        break;
      }
#line 2281
      ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
    } else {
#line 2288
      Irp->IoStatus.Information = 0UL;
#line 2289
      Irp->IoStatus.__annonCompField4.Status = 0L;
#line 2290
      myStatus = 0L;
#line 2291
      while (1) {
#line 2291
        break;
      }
#line 2292
      IofCompleteRequest(Irp, (char)0);
#line 2293
      return (0L);
    }
  }
#line 2297
  if (ntStatus != 259L) {
#line 2298
    Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 2299
    myStatus = ntStatus;
#line 2301
    while (1) {
#line 2301
      break;
    }
#line 2302
    IofCompleteRequest(Irp, (char)0);
  }
#line 2305
  return (ntStatus);
}
}
#line 2308 "floppy.c"
NTSTATUS FlInterpretError(UCHAR StatusRegister1 , UCHAR StatusRegister2 ) 
{ 

  {
#line 2335
  if ((int )StatusRegister1 & 32) {
    goto _L;
  } else {
#line 2335
    if ((int )StatusRegister2 & 32) {
      _L: /* CIL Label */ 
#line 2341
      while (1) {
#line 2341
        break;
      }
#line 2342
      return (-1073741761L);
    }
  }
#line 2345
  if ((int )StatusRegister1 & 16) {
#line 2350
    while (1) {
#line 2350
      break;
    }
#line 2351
    return (-1073741764L);
  }
#line 2354
  if ((int )StatusRegister1 & 4) {
    goto _L___0;
  } else {
#line 2354
    if ((int )StatusRegister1 & 128) {
      _L___0: /* CIL Label */ 
#line 2360
      while (1) {
#line 2360
        break;
      }
#line 2361
      return (-1073741803L);
    }
  }
#line 2364
  if ((int )StatusRegister2 & 1) {
    goto _L___1;
  } else {
#line 2364
    if ((int )StatusRegister2 & 2) {
      goto _L___1;
    } else {
#line 2364
      if ((int )StatusRegister2 & 64) {
        _L___1: /* CIL Label */ 
#line 2371
        while (1) {
#line 2371
          break;
        }
#line 2372
        return (-1073741668L);
      }
    }
  }
#line 2375
  if ((int )StatusRegister1 & 2) {
#line 2380
    while (1) {
#line 2380
      break;
    }
#line 2381
    return (-1073741662L);
  }
#line 2384
  if ((int )StatusRegister1 & 1) {
#line 2389
    while (1) {
#line 2389
      break;
    }
#line 2390
    return (-1073741467L);
  }
#line 2394
  if ((int )StatusRegister2 & 16) {
#line 2399
    while (1) {
#line 2399
      break;
    }
#line 2400
    return (-1073741466L);
  }
#line 2412
  while (1) {
#line 2412
    break;
  }
#line 2413
  return (-1073741465L);
}
}
#line 2416 "floppy.c"
void FlFinishOperation(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  int tmp ;

  {
#line 2454
  while (1) {
#line 2454
    break;
  }
#line 2461
  if (myStatus != 0L) {
#line 2461
    if (DisketteExtension->HardwareFailed) {
#line 2464
      DisketteExtension->HardwareFailCount = (UCHAR )((int )DisketteExtension->HardwareFailCount + 1);
#line 2465
      if ((int )DisketteExtension->HardwareFailCount < 2) {
#line 2475
        ntStatus = FlInitializeControllerHardware(DisketteExtension);
#line 2477
        if (ntStatus >= 0L) {
#line 2482
          while (1) {
#line 2482
            break;
          }
#line 2490
          DisketteExtension->MediaType = (enum _MEDIA_TYPE )-1;
#line 2496
          while (1) {
#line 2496
            break;
          }
#line 2498
          ExAcquireFastMutex(& DisketteExtension->ThreadReferenceMutex);
#line 2500
          (DisketteExtension->ThreadReferenceCount) ++;
#line 2501
          ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex);
#line 2503
          ExfInterlockedInsertHeadList(& DisketteExtension->ListEntry, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                                       & DisketteExtension->ListSpinLock);
#line 2508
          // return;
        }
#line 2514
        while (1) {
#line 2514
          break;
        }
      }
    }
  }
#line 2524
  DisketteExtension->HardwareFailCount = (unsigned char)0;
#line 2541
  if (! (myStatus >= 0L)) {
#line 2541
    if (myStatus == -1073741661L) {
#line 2541
      tmp = 1;
    } else {
#line 2541
      if (myStatus == -1073741643L) {
#line 2541
        tmp = 1;
      } else {
#line 2541
        if (myStatus == -1073741662L) {
#line 2541
          tmp = 1;
        } else {
#line 2541
          if (myStatus == -1073741805L) {
#line 2541
            tmp = 1;
          } else {
#line 2541
            if (myStatus == -2147483626L) {
#line 2541
              tmp = 1;
            } else {
#line 2541
              if (myStatus == -1073741804L) {
#line 2541
                tmp = 1;
              } else {
#line 2541
                if (myStatus == -1073741806L) {
#line 2541
                  tmp = 1;
                } else {
#line 2541
                  tmp = 0;
                }
              }
            }
          }
        }
      }
    }
#line 2541
    if ((unsigned char )tmp) {
#line 2535
      IoSetHardErrorOrVerifyDevice(Irp, DisketteExtension->DeviceObject);
    }
  }
#line 2549
  if (myStatus != 0L) {
#line 2549
    if (myStatus != -2147483626L) {
#line 2549
      if (myStatus != -1073741805L) {
#line 2551
        while (1) {
#line 2551
          break;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 2558
    while (1) {
#line 2558
      break;
    }
  }
#line 2564
  while (1) {
#line 2564
    break;
  }
#line 2569
  while (1) {
#line 2569
    break;
  }
#line 2579
  IofCompleteRequest(Irp, (char)1);
#line 2580
  // return;
}
}
#line 2582 "floppy.c"
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN WriteOperation ,
                      BOOLEAN SetUpMedia , BOOLEAN IgnoreChange ) 
{ LARGE_INTEGER delay ;
  BOOLEAN motorStarted ;
  UCHAR driveStatus ;
  NTSTATUS ntStatus ;
  FDC_ENABLE_PARMS fdcEnableParms ;
  FDC_DISK_CHANGE_PARMS fdcDiskChangeParms ;

  {
#line 2630
  ntStatus = 0L;
#line 2637
  while (1) {
#line 2637
    break;
  }
#line 2654
  *(DriveMediaConstants + (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType) = DisketteExtension->BiosDriveMediaConstants;
#line 2657
  if ((int )DisketteExtension->MediaType == -1) {
#line 2659
    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + 0);
  } else {
#line 2657
    if ((int )DisketteExtension->MediaType == 0) {
#line 2659
      DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + 0);
    }
  }
#line 2669
  fdcEnableParms.DriveOnValue = DisketteExtension->DriveOnValue;
#line 2670
  if (WriteOperation) {
#line 2671
    fdcEnableParms.TimeToWait = DisketteExtension->DriveMediaConstants.MotorSettleTimeWrite;
  } else {
#line 2674
    fdcEnableParms.TimeToWait = DisketteExtension->DriveMediaConstants.MotorSettleTimeRead;
  }
#line 2678
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (774 << 2)) | 3),
                           (void *)(& fdcEnableParms));
#line 2682
  motorStarted = fdcEnableParms.MotorStarted;
#line 2684
  if (ntStatus >= 0L) {
#line 2686
    fdcDiskChangeParms.DriveOnValue = DisketteExtension->DriveOnValue;
#line 2688
    ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (776 << 2)) | 3),
                             (void *)(& fdcDiskChangeParms));
#line 2692
    driveStatus = fdcDiskChangeParms.DriveStatus;
  }
#line 2695
  if (! (ntStatus >= 0L)) {
#line 2696
    return (ntStatus);
  }
#line 2708
  if ((int )DisketteExtension->DriveType == 0) {
#line 2708
    if (motorStarted) {
      goto _L___1;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 2708
    if ((int )DisketteExtension->DriveType != 0) {
#line 2708
      if ((int )driveStatus & 128) {
        _L___1: /* CIL Label */ 
#line 2716
        while (1) {
#line 2716
          break;
        }
#line 2718
        DisketteExtension->MediaType = (enum _MEDIA_TYPE )-1;
#line 2725
        if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
#line 2727
          if (Irp) {
#line 2728
            IoSetHardErrorOrVerifyDevice(Irp, DisketteExtension->DeviceObject);
          }
#line 2731
          (DisketteExtension->DeviceObject)->Flags |= 2UL;
        }
#line 2741
        if ((int )DisketteExtension->DriveType != 0) {
#line 2743
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 2749
            DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 2750
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 2752
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                      0UL, 0UL);
#line 2759
            if (! (ntStatus >= 0L)) {
#line 2764
              while (1) {
#line 2764
                break;
              }
#line 2766
              return (ntStatus);
            }
#line 2769
            if ((int )DisketteExtension->FifoBuffer[0] & 32) {
#line 2771
              driveStatus = (unsigned char)127;
            } else {
#line 2775
              driveStatus = (unsigned char)128;
            }
#line 2778
            if ((int )driveStatus & 128) {
#line 2788
              while (1) {
#line 2788
                break;
              }
#line 2795
              if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
#line 2797
                (DisketteExtension->DeviceObject)->Flags &= 4294967293UL;
              }
#line 2801
              return (-1073741805L);
            }
          }
#line 2815
          DisketteExtension->FifoBuffer[0] = (unsigned char)16;
#line 2816
          DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 2817
          DisketteExtension->FifoBuffer[2] = (unsigned char)1;
#line 2819
          ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                    0UL, 0UL);
#line 2826
          if (! (ntStatus >= 0L)) {
#line 2829
            while (1) {
#line 2829
              break;
            }
#line 2831
            return (ntStatus);
          } else {
#line 2835
            if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
              goto _L;
            } else {
#line 2835
              if ((int )DisketteExtension->FifoBuffer[1] != 1) {
                _L: /* CIL Label */ 
#line 2841
                while (1) {
#line 2841
                  break;
                }
#line 2843
                DisketteExtension->HardwareFailed = (unsigned char)1;
#line 2845
                return (-1073741464L);
              }
            }
          }
#line 2853
          DisketteExtension->FifoBuffer[0] = (unsigned char)16;
#line 2854
          DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 2855
          DisketteExtension->FifoBuffer[2] = (unsigned char)0;
#line 2862
          delay.__annonCompField1.LowPart = 4294966396UL;
#line 2863
          delay.__annonCompField1.HighPart = -1L;
#line 2864
          KeDelayExecutionThread((char)0, (unsigned char)0, & delay);
#line 2865
          ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                    0UL, 0UL);
#line 2875
          delay.__annonCompField1.LowPart = 4294967291UL;
#line 2876
          delay.__annonCompField1.HighPart = -1L;
#line 2877
          KeDelayExecutionThread((char)0, (unsigned char)0, & delay);
#line 2879
          if (! (ntStatus >= 0L)) {
#line 2882
            while (1) {
#line 2882
              break;
            }
#line 2884
            return (ntStatus);
          } else {
#line 2888
            if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
              goto _L___0;
            } else {
#line 2888
              if ((int )DisketteExtension->FifoBuffer[1] != 0) {
                _L___0: /* CIL Label */ 
#line 2894
                while (1) {
#line 2894
                  break;
                }
#line 2896
                DisketteExtension->HardwareFailed = (unsigned char)1;
#line 2898
                return (-1073741464L);
              }
            }
          }
#line 2903
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 2909
            DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 2910
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 2912
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                      0UL, 0UL);
#line 2919
            if (! (ntStatus >= 0L)) {
#line 2924
              while (1) {
#line 2924
                break;
              }
#line 2926
              return (ntStatus);
            }
#line 2929
            if ((int )DisketteExtension->FifoBuffer[0] & 32) {
#line 2931
              driveStatus = (unsigned char)127;
            } else {
#line 2935
              driveStatus = (unsigned char)128;
            }
          } else {
#line 2939
            ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (776 << 2)) | 3),
                                     (void *)(& fdcDiskChangeParms));
#line 2943
            driveStatus = fdcDiskChangeParms.DriveStatus;
#line 2945
            if (! (ntStatus >= 0L)) {
#line 2946
              return (ntStatus);
            }
          }
#line 2950
          if ((int )driveStatus & 128) {
#line 2960
            while (1) {
#line 2960
              break;
            }
#line 2967
            if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
#line 2969
              (DisketteExtension->DeviceObject)->Flags &= 4294967293UL;
            }
#line 2973
            return (-1073741805L);
          }
        }
#line 2982
        if ((int )IgnoreChange == 0) {
#line 2984
          if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
#line 2994
            while (1) {
#line 2994
              break;
            }
#line 2996
            return (-2147483626L);
          } else {
#line 3000
            return (-1073741435L);
          }
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 3004
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3006
        FlHdbit(DisketteExtension);
      }
    }
  }
#line 3011
  if (SetUpMedia) {
#line 3013
    if ((int )DisketteExtension->MediaType == -1) {
#line 3015
      ntStatus = FlDetermineMediaType(DisketteExtension);
    } else {
#line 3019
      if ((int )DisketteExtension->MediaType == 0) {
#line 3029
        while (1) {
#line 3029
          break;
        }
#line 3030
        return (-1073741804L);
      } else {
#line 3034
        if ((int )DisketteExtension->DriveMediaType != (int )DisketteExtension->LastDriveMediaType) {
#line 3042
          ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
#line 3043
          if (! (ntStatus >= 0L)) {
#line 3050
            while (1) {
#line 3050
              break;
            }
          }
        }
      }
    }
  }
#line 3063
  if (WriteOperation) {
#line 3063
    if (ntStatus >= 0L) {
#line 3065
      DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 3066
      DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 3068
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                0UL, 0UL);
#line 3075
      if (! (ntStatus >= 0L)) {
#line 3080
        while (1) {
#line 3080
          break;
        }
#line 3082
        return (ntStatus);
      }
#line 3085
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3089
        if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
#line 3094
          while (1) {
#line 3094
            break;
          }
#line 3095
          return (-1073741805L);
        }
      }
#line 3099
      if ((int )DisketteExtension->FifoBuffer[0] & 64) {
#line 3104
        while (1) {
#line 3104
          break;
        }
#line 3105
        return (-1073741662L);
      }
    }
  }
#line 3109
  return (ntStatus);
}
}
#line 3112 "floppy.c"
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;

  {
#line 3142
  ntStatus = 0L;
#line 3148
  if (DisketteExtension->ControllerConfigurable) {
#line 3150
    DisketteExtension->FifoBuffer[0] = (unsigned char)17;
#line 3151
    DisketteExtension->FifoBuffer[1] = (unsigned char)0;
#line 3153
    DisketteExtension->FifoBuffer[2] = (unsigned char)15;
#line 3154
    DisketteExtension->FifoBuffer[2] = (unsigned char )((int )DisketteExtension->FifoBuffer[2] + 16);
#line 3156
    if (! DisketteExtension->DriveMediaConstants.CylinderShift) {
#line 3157
      DisketteExtension->FifoBuffer[2] = (unsigned char )((int )DisketteExtension->FifoBuffer[2] + 64);
    }
#line 3160
    DisketteExtension->FifoBuffer[3] = (unsigned char)0;
#line 3162
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (struct _MDL *)((void *)0), 0UL, 0UL);
#line 3169
    if (ntStatus == -1073741661L) {
#line 3171
      DisketteExtension->ControllerConfigurable = (unsigned char)0;
#line 3172
      ntStatus = 0L;
    }
  }
#line 3181
  if (ntStatus >= 0L) {
    goto _L;
  } else {
#line 3181
    if (ntStatus == -1073741661L) {
      _L: /* CIL Label */ 
#line 3184
      DisketteExtension->FifoBuffer[0] = (unsigned char)13;
#line 3185
      DisketteExtension->FifoBuffer[1] = DisketteExtension->DriveMediaConstants.StepRateHeadUnloadTime;
#line 3188
      DisketteExtension->FifoBuffer[2] = DisketteExtension->DriveMediaConstants.HeadLoadTime;
#line 3191
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                0UL, 0UL);
#line 3198
      if (ntStatus >= 0L) {
#line 3204
        ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (777 << 2)) | 3),
                                 (void *)(& DisketteExtension->DriveMediaConstants.DataTransferRate));
#line 3214
        if (ntStatus >= 0L) {
#line 3216
          ntStatus = FlRecalibrateDrive(DisketteExtension);
        }
      } else {
#line 3222
        while (1) {
#line 3222
          break;
        }
      }
    } else {
#line 3228
      while (1) {
#line 3228
        break;
      }
    }
  }
#line 3231
  if (ntStatus >= 0L) {
#line 3233
    DisketteExtension->LastDriveMediaType = DisketteExtension->DriveMediaType;
  } else {
#line 3238
    DisketteExtension->LastDriveMediaType = (enum _DRIVE_MEDIA_TYPE )0;
#line 3242
    while (1) {
#line 3242
      break;
    }
  }
#line 3245
  return (ntStatus);
}
}
#line 3248 "floppy.c"
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  UCHAR recalibrateCount ;
  UCHAR fifoBuffer[2] ;

  {
#line 3278
  recalibrateCount = (unsigned char)0;
#line 3280
  while (1) {
#line 3286
    DisketteExtension->FifoBuffer[0] = (unsigned char)11;
#line 3287
    DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 3289
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (struct _MDL *)((void *)0), 0UL, 0UL);
#line 3296
    if (! (ntStatus >= 0L)) {
#line 3301
      while (1) {
#line 3301
        break;
      }
    }
#line 3305
    if (ntStatus >= 0L) {
#line 3307
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3313
        fifoBuffer[0] = DisketteExtension->FifoBuffer[0];
#line 3314
        fifoBuffer[1] = DisketteExtension->FifoBuffer[1];
#line 3319
        DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 3320
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 3322
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                  0UL, 0UL);
#line 3329
        if (! (ntStatus >= 0L)) {
#line 3334
          while (1) {
#line 3334
            break;
          }
#line 3336
          return (ntStatus);
        }
#line 3339
        DisketteExtension->FifoBuffer[0] = fifoBuffer[0];
#line 3340
        DisketteExtension->FifoBuffer[1] = fifoBuffer[1];
      }
#line 3344
      if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
        goto _L;
      } else {
#line 3344
        if ((int )DisketteExtension->FifoBuffer[1] != 0) {
          _L: /* CIL Label */ 
#line 3350
          while (1) {
#line 3350
            break;
          }
#line 3352
          DisketteExtension->HardwareFailed = (unsigned char)1;
#line 3354
          ntStatus = -1073741464L;
        }
      }
    }
#line 3358
    recalibrateCount = (UCHAR )((int )recalibrateCount + 1);
#line 3280
    if (! (ntStatus >= 0L)) {
#line 3280
      if (! ((int )recalibrateCount < 2)) {
#line 3280
        break;
      }
    } else {
#line 3280
      break;
    }
  }
#line 3365
  while (1) {
#line 3365
    break;
  }
#line 3367
  return (ntStatus);
}
}
#line 3370 "floppy.c"
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  BOOLEAN mediaTypesExhausted ;
  ULONG retries ;
  USHORT sectorLengthCode ;
  PBOOT_SECTOR_INFO bootSector ;
  LARGE_INTEGER offset ;
  PIRP irp ;
  int tmp ;
  PVOID tmp___0 ;
  int tmp___1 ;

  {
#line 3400
  retries = (ULONG )0;
#line 3410
  while (1) {
#line 3410
    break;
  }
#line 3412
  DisketteExtension->IsReadOnly = (unsigned char)0;
#line 3418
  retries = 0UL;
#line 3418
  while (retries < 3UL) {
#line 3420
    if (retries) {
#line 3432
      while (1) {
#line 3432
        break;
      }
#line 3433
      FlInitializeControllerHardware(DisketteExtension);
    }
#line 3443
    DisketteExtension->DriveMediaType = (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType;
#line 3445
    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
#line 3448
    mediaTypesExhausted = (unsigned char)0;
#line 3450
    while (1) {
#line 3452
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3453
        sectorLengthCode = (unsigned short )(DriveMediaConstants + DisketteExtension->DriveMediaType)->SectorLengthCode;
#line 3455
        FlHdbit(DisketteExtension);
      }
#line 3459
      ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
#line 3461
      if (! (ntStatus >= 0L)) {
#line 3471
        while (1) {
#line 3471
          break;
        }
#line 3472
        mediaTypesExhausted = (unsigned char)1;
      } else {
#line 3481
        driveMediaConstants = DriveMediaConstants + DisketteExtension->DriveMediaType;
#line 3488
        DisketteExtension->FifoBuffer[1] = (unsigned char )((int )DisketteExtension->DeviceUnit | (((int )driveMediaConstants->NumberOfHeads - 1) << 2));
#line 3492
        DisketteExtension->FifoBuffer[0] = (unsigned char)84;
#line 3495
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                  0UL, 0UL);
#line 3502
        if (! (ntStatus >= 0L)) {
          goto _L;
        } else {
#line 3502
          if (((int )DisketteExtension->FifoBuffer[0] & -33) != (int )((unsigned char )((int )DisketteExtension->DeviceUnit | (((int )driveMediaConstants->NumberOfHeads - 1) << 2)))) {
            goto _L;
          } else {
#line 3502
            if ((int )DisketteExtension->FifoBuffer[1] != 0) {
              goto _L;
            } else {
#line 3502
              if ((int )DisketteExtension->FifoBuffer[2] != 0) {
                goto _L;
              } else {
#line 3502
                if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3502
                  if ((int )DisketteExtension->FifoBuffer[6] != (int )sectorLengthCode) {
                    _L: /* CIL Label */ 
#line 3522
                    while (1) {
#line 3522
                      break;
                    }
#line 3524
                    DisketteExtension->DriveMediaType = (DRIVE_MEDIA_TYPE )((int )DisketteExtension->DriveMediaType - 1);
#line 3525
                    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
#line 3528
                    if (ntStatus != -1073741661L) {
#line 3530
                      ntStatus = -1073741804L;
                    }
#line 3538
                    if ((int )((char )DisketteExtension->DriveMediaType) < (int )((char )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType)) {
#line 3542
                      DisketteExtension->MediaType = 0;
#line 3543
                      mediaTypesExhausted = (unsigned char)1;
#line 3548
                      while (1) {
#line 3548
                        break;
                      }
                    }
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ 
#line 3553
                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3558
                    DisketteExtension->MediaType = driveMediaConstants->MediaType;
#line 3560
                    DisketteExtension->BytesPerSector = (unsigned long )driveMediaConstants->BytesPerSector;
#line 3566
                    while (1) {
#line 3566
                      break;
                    }
#line 3568
                    DisketteExtension->ByteCapacity = (unsigned long )((((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads);
#line 3578
                    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
#line 3588
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3588
                      tmp = 1024;
                    } else {
#line 3588
                      tmp = 512;
                    }
#line 3588
                    tmp___0 = ExAllocatePoolWithTag(4, (unsigned long )tmp, 1886350406UL);
#line 3588
                    bootSector = (struct _BOOT_SECTOR_INFO *)tmp___0;
#line 3589
                    if (! bootSector) {
#line 3590
                      return (-1073741670L);
                    }
#line 3593
                    offset.__annonCompField1.HighPart = 0L;
#line 3593
                    offset.__annonCompField1.LowPart = (unsigned long )offset.__annonCompField1.HighPart;
#line 3594
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3594
                      tmp___1 = 1024;
                    } else {
#line 3594
                      tmp___1 = 512;
                    }
#line 3594
                    irp = IoBuildAsynchronousFsdRequest(3UL, DisketteExtension->DeviceObject,
                                                        (void *)bootSector, (unsigned long )tmp___1,
                                                        & offset, (struct _IO_STATUS_BLOCK *)((void *)0));
#line 3600
                    if (! irp) {
#line 3603
                      while (1) {
#line 3603
                        break;
                      }
#line 3604
                      ExFreePool((void *)bootSector);
#line 3605
                      return (-1073741670L);
                    }
#line 3607
                    irp->CurrentLocation = (CHAR )((int )irp->CurrentLocation - 1);
#line 3608
                    (irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) --;
#line 3613
                    ntStatus = FlReadWrite(DisketteExtension, irp, (unsigned char)1);
#line 3618
                    while (1) {
#line 3618
                      break;
                    }
#line 3620
                    MmUnlockPages(irp->MdlAddress);
#line 3621
                    IoFreeMdl(irp->MdlAddress);
#line 3622
                    IoFreeIrp(irp);
#line 3623
                    ExFreePool((void *)bootSector);
#line 3625
                    if (! (ntStatus >= 0L)) {
#line 3642
                      while (1) {
#line 3642
                        break;
                      }
#line 3644
                      DisketteExtension->DriveMediaType = (DRIVE_MEDIA_TYPE )((int )DisketteExtension->DriveMediaType - 1);
#line 3646
                      DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
#line 3649
                      if (ntStatus != -1073741661L) {
#line 3651
                        ntStatus = -1073741804L;
                      }
#line 3660
                      if ((int )((char )DisketteExtension->DriveMediaType) < (int )((char )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType)) {
#line 3664
                        DisketteExtension->MediaType = 0;
#line 3665
                        mediaTypesExhausted = (unsigned char)1;
#line 3670
                        while (1) {
#line 3670
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 3450
      if (! (ntStatus >= 0L)) {
#line 3450
        if (! (! mediaTypesExhausted)) {
#line 3450
          break;
        }
      } else {
#line 3450
        break;
      }
    }
#line 3680
    if (ntStatus >= 0L) {
#line 3689
      while (1) {
#line 3689
        break;
      }
#line 3690
      break;
    }
#line 3418
    retries ++;
  }
#line 3694
  if (! (ntStatus >= 0L)) {
    goto _L___1;
  } else {
#line 3694
    if (mediaTypesExhausted) {
      _L___1: /* CIL Label */ 
#line 3701
      while (1) {
#line 3701
        break;
      }
#line 3702
      return (ntStatus);
    }
  }
#line 3705
  DisketteExtension->MediaType = driveMediaConstants->MediaType;
#line 3706
  DisketteExtension->BytesPerSector = (unsigned long )driveMediaConstants->BytesPerSector;
#line 3708
  DisketteExtension->ByteCapacity = (unsigned long )((((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads);
#line 3720
  while (1) {
#line 3720
    break;
  }
#line 3725
  DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + DisketteExtension->DriveMediaType);
#line 3731
  FlCheckBootSector(DisketteExtension);
#line 3733
  return (ntStatus);
}
}
#line 3736 "floppy.c"
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension , ULONG BufferSize ) 
{ BOOLEAN allocateContiguous ;
  LARGE_INTEGER maxDmaAddress ;
  PVOID tmp ;
  PVOID tmp___0 ;

  {
#line 3764
  if (DisketteExtension->IoBuffer) {
#line 3765
    if (DisketteExtension->IoBufferSize >= BufferSize) {
#line 3766
      // return;
    }
#line 3768
    FlFreeIoBuffer(DisketteExtension);
  }
#line 3771
  if (BufferSize > DisketteExtension->MaxTransferSize) {
#line 3772
    allocateContiguous = (unsigned char)1;
  } else {
#line 3774
    allocateContiguous = (unsigned char)0;
  }
#line 3777
  if (allocateContiguous) {
#line 3778
    maxDmaAddress.QuadPart = 16777215LL;
#line 3779
    tmp = MmAllocateContiguousMemory(BufferSize, maxDmaAddress);
#line 3779
    DisketteExtension->IoBuffer = (UCHAR *)tmp;
  } else {
#line 3782
    tmp___0 = ExAllocatePoolWithTag(4, BufferSize, 1886350406UL);
#line 3782
    DisketteExtension->IoBuffer = (UCHAR *)tmp___0;
  }
#line 3786
  if (! DisketteExtension->IoBuffer) {
#line 3787
    // return;
  }
#line 3790
  DisketteExtension->IoBufferMdl = IoAllocateMdl((void *)DisketteExtension->IoBuffer,
                                                 BufferSize, (unsigned char)0, (unsigned char)0,
                                                 (struct _IRP *)((void *)0));
#line 3792
  if (! DisketteExtension->IoBufferMdl) {
#line 3793
    if (allocateContiguous) {
#line 3794
      MmFreeContiguousMemory((void *)DisketteExtension->IoBuffer);
    } else {
#line 3796
      ExFreePool((void *)DisketteExtension->IoBuffer);
    }
#line 3798
    DisketteExtension->IoBuffer = (UCHAR *)((void *)0);
#line 3799
    // return;
  }
#line 3803
  MmProbeAndLockPages(DisketteExtension->IoBufferMdl, (char)0, 2);
#line 3809
  while (1) {
#line 3809
    break;
  }
#line 3810
  if (allocateContiguous) {
#line 3811
    MmFreeContiguousMemory((void *)DisketteExtension->IoBuffer);
  } else {
#line 3813
    ExFreePool((void *)DisketteExtension->IoBuffer);
  }
#line 3815
  DisketteExtension->IoBuffer = (UCHAR *)((void *)0);
#line 3816
  // return;
#line 3819
  DisketteExtension->IoBufferSize = BufferSize;
}
}
#line 3822 "floppy.c"
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension ) 
{ BOOLEAN contiguousBuffer ;

  {
#line 3846
  if (! DisketteExtension->IoBuffer) {
#line 3847
    // return;
  }
#line 3850
  if (DisketteExtension->IoBufferSize > DisketteExtension->MaxTransferSize) {
#line 3853
    contiguousBuffer = (unsigned char)1;
  } else {
#line 3855
    contiguousBuffer = (unsigned char)0;
  }
#line 3858
  DisketteExtension->IoBufferSize = 0UL;
#line 3860
  MmUnlockPages(DisketteExtension->IoBufferMdl);
#line 3861
  IoFreeMdl(DisketteExtension->IoBufferMdl);
#line 3862
  DisketteExtension->IoBufferMdl = (struct _MDL *)((void *)0);
#line 3863
  if (contiguousBuffer) {
#line 3864
    MmFreeContiguousMemory((void *)DisketteExtension->IoBuffer);
  } else {
#line 3866
    ExFreePool((void *)DisketteExtension->IoBuffer);
  }
#line 3868
  DisketteExtension->IoBuffer = (UCHAR *)((void *)0);
#line 3869
  // return;
}
}
#line 3871 "floppy.c"
void FloppyThread(PVOID Context ) 
{ PIRP irp ;
  PIO_STACK_LOCATION irpSp ;
  PLIST_ENTRY request ;
  PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  NTSTATUS waitStatus ;
  LARGE_INTEGER queueWait ;
  LARGE_INTEGER acquireWait ;
  PKTHREAD tmp ;
  PDISK_GEOMETRY outputBuffer ;
  PSENSE_DEVISE_STATUS_PTOS outputBuffer___0 ;

  {
#line 3904
  disketteExtension = (PDISKETTE_EXTENSION )Context;
#line 3905
  ntStatus = 0L;
#line 3915
  tmp = KeGetCurrentThread();
#line 3915
  KeSetPriorityThread(tmp, 16L);
#line 3917
  queueWait.QuadPart = -30000000LL;
#line 3918
  acquireWait.QuadPart = -150000000LL;
#line 3920
  while (1) {
#line 3929
    waitStatus = KeWaitForSingleObject((void *)(& disketteExtension->RequestSemaphore),
                                       0, (char)0, (unsigned char)0, & queueWait);
#line 3936
    if (waitStatus == 258L) {
#line 3938
      if (! ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1)) {
#line 3938
        if (disketteExtension->FloppyControllerAllocated) {
#line 3943
          while (1) {
#line 3943
            break;
          }
#line 3944
          FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (775 << 2)) | 3),
                        (void *)0);
#line 3948
          FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (769 << 2)) | 3),
                        (void *)disketteExtension->DeviceObject);
#line 3952
          disketteExtension->FloppyControllerAllocated = (unsigned char)0;
        }
      }
#line 3956
      ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 3958
      if (disketteExtension->ThreadReferenceCount == 0L) {
#line 3959
        disketteExtension->ThreadReferenceCount = -1L;
#line 3969
        if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {
#line 3971
          ObfDereferenceObject((void *)disketteExtension->FloppyThread);
#line 3972
          disketteExtension->FloppyThread = (struct _KTHREAD *)((void *)0);
        }
#line 3975
        ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 3977
        if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3978
          if (disketteExtension->ReleaseFdcWithMotorRunning) {
#line 3979
            ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (768 << 2)) | 3),
                                     (void *)(& acquireWait));
#line 3984
            FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (775 << 2)) | 3),
                          (void *)0);
#line 3988
            FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (769 << 2)) | 3),
                          (void *)disketteExtension->DeviceObject);
#line 3992
            disketteExtension->FloppyControllerAllocated = (unsigned char)0;
#line 3993
            disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
          }
        }
#line 3997
        ExAcquireFastMutex(PagingMutex);
#line 3997
        PagingReferenceCount --;
#line 3997
        if (PagingReferenceCount == 0UL) {
#line 3997
          MmPageEntireDriver((void *)(& DriverEntry));
        }
#line 3997
        ExReleaseFastMutex(PagingMutex);
#line 4001
        while (1) {
#line 4001
          break;
        }
#line 4002
        PsTerminateSystemThread(0L);
      }
#line 4005
      ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex);
      goto __Cont;
    }
#line 4009
    while (1) {
#line 4009
      request = ExfInterlockedRemoveHeadList(& disketteExtension->ListEntry, & disketteExtension->ListSpinLock);
#line 4009
      if (! request) {
#line 4009
        break;
      }
#line 4013
      ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 4015
      (disketteExtension->ThreadReferenceCount) --;
#line 4016
      ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 4018
      disketteExtension->HardwareFailed = (unsigned char)0;
#line 4020
      irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
#line 4026
      ExAcquireFastMutex(& disketteExtension->PowerDownMutex);
#line 4027
      if ((int )disketteExtension->PoweringDown == 1) {
#line 4028
        ExReleaseFastMutex(& disketteExtension->PowerDownMutex);
#line 4030
        while (1) {
#line 4030
          break;
        }
#line 4032
        irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
#line 4033
        irp->IoStatus.__annonCompField4.Status = -1073741101L;
#line 4034
        irp->IoStatus.Information = 0UL;
#line 4035
        IofCompleteRequest(irp, (char)0);
#line 4036
        continue;
      }
#line 4038
      ExReleaseFastMutex(& disketteExtension->PowerDownMutex);
#line 4039
      while (1) {
#line 4039
        break;
      }
#line 4041
      irpSp = irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 4047
      while (1) {
#line 4047
        break;
      }
#line 4048
      switch ((int )irpSp->MajorFunction) {
      case 27: ;
#line 4052
      while (1) {
#line 4052
        break;
      }
#line 4054
      if ((int )irpSp->MinorFunction == 1) {
        goto _L;
      } else {
#line 4054
        if ((int )irpSp->MinorFunction == 5) {
          _L: /* CIL Label */ 
#line 4057
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4058
            if (disketteExtension->ReleaseFdcWithMotorRunning) {
#line 4059
              FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (768 << 2)) | 3),
                            (void *)(& acquireWait));
#line 4063
              disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
#line 4064
              disketteExtension->FloppyControllerAllocated = (unsigned char)1;
            }
          }
#line 4068
          if (disketteExtension->FloppyControllerAllocated) {
#line 4070
            FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (775 << 2)) | 3),
                          (void *)0);
#line 4074
            FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (769 << 2)) | 3),
                          (void *)disketteExtension->DeviceObject);
#line 4078
            disketteExtension->FloppyControllerAllocated = (unsigned char)0;
          }
#line 4082
          ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 4084
          disketteExtension->ThreadReferenceCount = -1L;
#line 4085
          ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 4087
          ExAcquireFastMutex(PagingMutex);
#line 4087
          PagingReferenceCount --;
#line 4087
          if (PagingReferenceCount == 0UL) {
#line 4087
            MmPageEntireDriver((void *)(& DriverEntry));
          }
#line 4087
          ExReleaseFastMutex(PagingMutex);
#line 4089
          PsTerminateSystemThread(0L);
        } else {
#line 4093
          ntStatus = -1073741808L;
        }
      }
#line 4095
      break;
      case 3: ;
      case 4: ;
#line 4108
      if (! disketteExtension->FloppyControllerAllocated) {
#line 4110
        ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (768 << 2)) | 3),
                                 (void *)(& acquireWait));
#line 4115
        if (ntStatus >= 0L) {
#line 4116
          disketteExtension->FloppyControllerAllocated = (unsigned char)1;
#line 4117
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4117
            disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
          }
        } else {
#line 4119
          break;
        }
      }
#line 4128
      if ((disketteExtension->DeviceObject)->Flags & 2UL) {
#line 4128
        if (! ((int )irpSp->Flags & 2)) {
#line 4136
          while (1) {
#line 4136
            break;
          }
#line 4145
          ntStatus = -2147483626L;
        } else {
#line 4149
          ntStatus = FlReadWrite(disketteExtension, irp, (unsigned char)0);
        }
      } else {
#line 4149
        ntStatus = FlReadWrite(disketteExtension, irp, (unsigned char)0);
      }
#line 4153
      break;
      case 14: ;
#line 4161
      if (! disketteExtension->FloppyControllerAllocated) {
#line 4163
        ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (768 << 2)) | 3),
                                 (void *)(& acquireWait));
#line 4168
        if (ntStatus >= 0L) {
#line 4169
          disketteExtension->FloppyControllerAllocated = (unsigned char)1;
#line 4170
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4170
            disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
          }
        } else {
#line 4172
          break;
        }
      }
#line 4180
      if ((disketteExtension->DeviceObject)->Flags & 2UL) {
#line 4180
        if (! ((int )irpSp->Flags & 2)) {
#line 4188
          while (1) {
#line 4188
            break;
          }
#line 4196
          ntStatus = -2147483626L;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 4200
        switch ((int )irpSp->Parameters.DeviceIoControl.IoControlCode) {
        case ((45 << 16) | (1 << 14)) | (512 << 2): ;
        case ((7 << 16) | (1 << 14)) | (512 << 2): ;
#line 4215
        while (1) {
#line 4215
          break;
        }
#line 4223
        ntStatus = FlStartDrive(disketteExtension, irp, (unsigned char)0, (unsigned char)0,
                                (unsigned char )(! (! ((int )irpSp->Flags & 2))));
#line 4231
        break;
        case (7 << 16) | (9 << 2): ;
#line 4244
        while (1) {
#line 4244
          break;
        }
#line 4246
        if (disketteExtension->IsReadOnly) {
#line 4248
          ntStatus = -1073741811L;
        } else {
#line 4252
          ntStatus = FlStartDrive(disketteExtension, irp, (unsigned char)1, (unsigned char)0,
                                  (unsigned char)1);
        }
#line 4260
        break;
        case 7 << 16: ;
#line 4268
        while (1) {
#line 4268
          break;
        }
#line 4276
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (ULONG )sizeof(DISK_GEOMETRY )) {
#line 4280
          ntStatus = -1073741811L;
        } else {
#line 4284
          ntStatus = FlStartDrive(disketteExtension, irp, (unsigned char)0, (unsigned char)1,
                                  (unsigned char )(! (! ((int )irpSp->Flags & 2))));
        }
#line 4299
        if (ntStatus >= 0L) {
          goto _L___0;
        } else {
#line 4299
          if (ntStatus == -1073741804L) {
            _L___0: /* CIL Label */ 
#line 4302
            outputBuffer = (struct _DISK_GEOMETRY *)irp->AssociatedIrp.SystemBuffer;
#line 4310
            ntStatus = 0L;
#line 4312
            outputBuffer->MediaType = disketteExtension->MediaType;
#line 4320
            if ((int )disketteExtension->MediaType == 0) {
#line 4326
              while (1) {
#line 4326
                break;
              }
#line 4333
              outputBuffer->Cylinders.__annonCompField1.LowPart = 0UL;
#line 4334
              outputBuffer->Cylinders.__annonCompField1.HighPart = 0L;
#line 4335
              outputBuffer->TracksPerCylinder = 0UL;
#line 4336
              outputBuffer->SectorsPerTrack = 0UL;
#line 4337
              outputBuffer->BytesPerSector = 0UL;
            } else {
#line 4349
              while (1) {
#line 4349
                break;
              }
#line 4350
              outputBuffer->Cylinders.__annonCompField1.LowPart = (unsigned long )((int )disketteExtension->DriveMediaConstants.MaximumTrack + 1);
#line 4354
              outputBuffer->Cylinders.__annonCompField1.HighPart = 0L;
#line 4356
              outputBuffer->TracksPerCylinder = (unsigned long )disketteExtension->DriveMediaConstants.NumberOfHeads;
#line 4360
              outputBuffer->SectorsPerTrack = (unsigned long )disketteExtension->DriveMediaConstants.SectorsPerTrack;
#line 4364
              outputBuffer->BytesPerSector = (unsigned long )disketteExtension->DriveMediaConstants.BytesPerSector;
            }
#line 4384
            while (1) {
#line 4384
              break;
            }
          }
        }
#line 4388
        irp->IoStatus.Information = (unsigned long )sizeof(DISK_GEOMETRY );
#line 4391
        break;
        case ((7 << 16) | (3 << 14)) | (11 << 2): ;
        case ((7 << 16) | (3 << 14)) | (6 << 2): ;
#line 4400
        while (1) {
#line 4400
          break;
        }
#line 4407
        ntStatus = FlStartDrive(disketteExtension, irp, (unsigned char)1, (unsigned char)0,
                                (unsigned char)0);
#line 4420
        if (ntStatus >= 0L) {
          goto _L___1;
        } else {
#line 4420
          if (ntStatus == -1073741804L) {
            _L___1: /* CIL Label */ 
#line 4432
            FlAllocateIoBuffer(disketteExtension, 4096UL);
#line 4435
            if (disketteExtension->IoBuffer) {
#line 4436
              ntStatus = FlFormat(disketteExtension, irp);
            } else {
#line 4439
              ntStatus = -1073741670L;
            }
          }
        }
#line 4443
        break;
        case (7 << 16) | (248 << 2): ;
#line 4448
        if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4449
          disketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 4450
          disketteExtension->FifoBuffer[1] = disketteExtension->DeviceUnit;
#line 4452
          ntStatus = FlIssueCommand(disketteExtension, disketteExtension->FifoBuffer,
                                    disketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                    0UL, 0UL);
#line 4459
          if (ntStatus >= 0L) {
#line 4461
            outputBuffer___0 = (struct _SENSE_DEVISE_STATUS_PTOS *)irp->AssociatedIrp.SystemBuffer;
#line 4463
            outputBuffer___0->ST3_PTOS = Result_Status3_PTOS[0].ST3_PTOS;
#line 4466
            irp->IoStatus.Information = (unsigned long )sizeof(SENSE_DEVISE_STATUS_PTOS );
          }
#line 4468
          break;
        }
        }
      }
#line 4475
      break;
      default: ;
#line 4483
      while (1) {
#line 4483
        break;
      }
#line 4485
      ntStatus = -1073741822L;
      }
#line 4490
      if (ntStatus == -2147483631L) {
#line 4496
        while (1) {
#line 4498
          disketteExtension->HardwareFailed = (unsigned char)0;
#line 4500
          irp->IoStatus.__annonCompField4.Status = -2147483631L;
#line 4502
          IofCompleteRequest(irp, (char)1);
#line 4504
          request = ExfInterlockedRemoveHeadList(& disketteExtension->ListEntry, & disketteExtension->ListSpinLock);
#line 4508
          if (! request) {
#line 4509
            break;
          }
#line 4512
          ExAcquireFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 4515
          (disketteExtension->ThreadReferenceCount) --;
#line 4516
          ExReleaseFastMutex(& disketteExtension->ThreadReferenceMutex);
#line 4519
          irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
        }
      } else {
#line 4531
        irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 4536
        if (disketteExtension->IoBuffer) {
#line 4537
          FlFreeIoBuffer(disketteExtension);
        }
#line 4540
        FlFinishOperation(irp, disketteExtension);
      }
    }
#line 4546
    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4547
      if (disketteExtension->FloppyControllerAllocated) {
#line 4548
        FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (769 << 2)) | 3),
                      (void *)disketteExtension->DeviceObject);
#line 4552
        disketteExtension->FloppyControllerAllocated = (unsigned char)0;
#line 4553
        disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)1;
      }
    }
    __Cont: /* CIL Label */ ;
  }
}
}
#line 4560 "floppy.c"
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension ,
                                          PBOOT_SECTOR_INFO BootSector ) 
{ USHORT bpbNumberOfSectors ;
  USHORT bpbNumberOfHeads ;
  USHORT bpbSectorsPerTrack ;
  USHORT bpbBytesPerSector ;
  USHORT bpbMediaByte ;
  USHORT bpbMaximumTrack ;
  MEDIA_TYPE bpbMediaType ;
  ULONG i ;
  ULONG n ;
  PDRIVE_MEDIA_CONSTANTS readidDriveMediaConstants ;
  BOOLEAN changeToBpbMedia ;
  int tmp ;
  SIZE_T tmp___0 ;

  {
#line 4598
  while (1) {
#line 4598
    break;
  }
#line 4600
  if ((int )BootSector->JumpByte[0] != 235) {
#line 4600
    if ((int )BootSector->JumpByte[0] != 233) {
#line 4604
      // return;
    }
  }
#line 4607
  bpbNumberOfSectors = (unsigned short )((int )BootSector->NumberOfSectors[1] * 256 + (int )BootSector->NumberOfSectors[0]);
#line 4609
  bpbNumberOfHeads = (unsigned short )((int )BootSector->NumberOfHeads[1] * 256 + (int )BootSector->NumberOfHeads[0]);
#line 4611
  bpbSectorsPerTrack = (unsigned short )((int )BootSector->SectorsPerTrack[1] * 256 + (int )BootSector->SectorsPerTrack[0]);
#line 4613
  bpbBytesPerSector = (unsigned short )((int )BootSector->BytesPerSector[1] * 256 + (int )BootSector->BytesPerSector[0]);
#line 4615
  bpbMediaByte = (unsigned short )BootSector->MediaByte[0];
#line 4617
  if (! bpbNumberOfHeads) {
#line 4619
    // return;
  } else {
#line 4617
    if (! bpbSectorsPerTrack) {
#line 4619
      // return;
    }
  }
#line 4622
  bpbMaximumTrack = (unsigned short )(((int )bpbNumberOfSectors / (int )bpbNumberOfHeads) / (int )bpbSectorsPerTrack - 1);
#line 4628
  bpbMediaType = 0;
#line 4629
  i = 0UL;
#line 4629
  while (1) {
#line 4629
    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4629
      tmp = 21;
    } else {
#line 4629
      tmp = 17;
    }
#line 4629
    if (! (i < (unsigned long )tmp)) {
#line 4629
      break;
    }
#line 4631
    if ((int )bpbBytesPerSector == (int )(DriveMediaConstants + i)->BytesPerSector) {
#line 4631
      if ((int )bpbSectorsPerTrack == (int )(DriveMediaConstants + i)->SectorsPerTrack) {
#line 4631
        if ((int )bpbMaximumTrack == (int )(DriveMediaConstants + i)->MaximumTrack) {
#line 4631
          if ((int )bpbNumberOfHeads == (int )(DriveMediaConstants + i)->NumberOfHeads) {
#line 4631
            if ((int )bpbMediaByte == (int )(DriveMediaConstants + i)->MediaByte) {
#line 4637
              bpbMediaType = (DriveMediaConstants + i)->MediaType;
#line 4638
              break;
            }
          }
        }
      }
    }
#line 4629
    i ++;
  }
#line 4647
  if ((int )DisketteExtension->DriveType == 3) {
#line 4648
    switch ((int )bpbMediaType) {
    case 15: 
#line 4649
    bpbMediaType = 14;
#line 4649
    break;
    case 16: 
#line 4650
    bpbMediaType = 5;
#line 4650
    break;
    case 1: 
#line 4651
    bpbMediaType = 17;
#line 4651
    break;
    case 19: 
#line 4652
    bpbMediaType = 18;
#line 4652
    break;
    default: ;
#line 4653
    break;
    }
  }
#line 4660
  while (1) {
#line 4660
    break;
  }
#line 4665
  while (1) {
#line 4665
    break;
  }
#line 4666
  if ((int )bpbMediaType == (int )DisketteExtension->MediaType) {
#line 4670
    changeToBpbMedia = (unsigned char)0;
#line 4674
    while (1) {
#line 4674
      break;
    }
  } else {
#line 4682
    readidDriveMediaConstants = & DisketteExtension->DriveMediaConstants;
#line 4684
    if ((int )bpbBytesPerSector == (int )readidDriveMediaConstants->BytesPerSector) {
#line 4684
      if ((int )bpbSectorsPerTrack < 256) {
#line 4684
        if ((int )bpbMaximumTrack == (int )readidDriveMediaConstants->MaximumTrack) {
#line 4684
          if ((int )bpbNumberOfHeads <= (int )readidDriveMediaConstants->NumberOfHeads) {
#line 4689
            changeToBpbMedia = (unsigned char)1;
          } else {
#line 4692
            changeToBpbMedia = (unsigned char)0;
          }
        } else {
#line 4692
          changeToBpbMedia = (unsigned char)0;
        }
      } else {
#line 4692
        changeToBpbMedia = (unsigned char)0;
      }
    } else {
#line 4692
      changeToBpbMedia = (unsigned char)0;
    }
#line 4699
    while (1) {
#line 4699
      break;
    }
#line 4706
    if ((int )bpbMediaType == 0) {
#line 4707
      bpbMediaType = readidDriveMediaConstants->MediaType;
#line 4708
      DisketteExtension->DriveMediaConstants.SkewDelta = (unsigned char)0;
    }
  }
#line 4712
  if (changeToBpbMedia) {
#line 4717
    i = (unsigned long )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType;
#line 4718
    n = (unsigned long )(DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType;
#line 4719
    while (i <= n) {
#line 4721
      if ((int )bpbMediaType == (int )(DriveMediaConstants + i)->MediaType) {
#line 4722
        DisketteExtension->DriveMediaType = (enum _DRIVE_MEDIA_TYPE )i;
#line 4723
        break;
      }
#line 4719
      i ++;
    }
#line 4727
    DisketteExtension->MediaType = bpbMediaType;
#line 4728
    DisketteExtension->ByteCapacity = (unsigned long )((int )bpbNumberOfSectors * (int )bpbBytesPerSector);
#line 4729
    DisketteExtension->DriveMediaConstants.SectorsPerTrack = (unsigned char )bpbSectorsPerTrack;
#line 4731
    DisketteExtension->DriveMediaConstants.NumberOfHeads = (unsigned char )bpbNumberOfHeads;
#line 4737
    tmp___0 = RtlCompareMemory((void const   *)(BootSector->OemData), (void const   *)"MSDMF3.",
                               7UL);
#line 4737
    if (tmp___0 == 7UL) {
#line 4738
      DisketteExtension->IsReadOnly = (unsigned char)1;
    }
  }
#line 4741
  // return;
}
}
#line 4743 "floppy.c"
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension ) 
{ PBOOT_SECTOR_INFO bootSector ;
  LARGE_INTEGER offset ;
  PIRP irp ;
  NTSTATUS status ;
  int tmp ;
  PVOID tmp___0 ;
  int tmp___1 ;

  {
#line 4776
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4776
    tmp = 1024;
  } else {
#line 4776
    tmp = 512;
  }
#line 4776
  tmp___0 = ExAllocatePoolWithTag(4, (unsigned long )tmp, 1886350406UL);
#line 4776
  bootSector = (struct _BOOT_SECTOR_INFO *)tmp___0;
#line 4777
  if (! bootSector) {
#line 4778
    // return;
  }
#line 4781
  offset.__annonCompField1.HighPart = 0L;
#line 4781
  offset.__annonCompField1.LowPart = (unsigned long )offset.__annonCompField1.HighPart;
#line 4782
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4782
    tmp___1 = 1024;
  } else {
#line 4782
    tmp___1 = 512;
  }
#line 4782
  irp = IoBuildAsynchronousFsdRequest(3UL, DisketteExtension->DeviceObject, (void *)bootSector,
                                      (unsigned long )tmp___1, & offset, (struct _IO_STATUS_BLOCK *)((void *)0));
#line 4788
  if (! irp) {
#line 4789
    ExFreePool((void *)bootSector);
#line 4790
    // return;
  }
#line 4792
  irp->CurrentLocation = (CHAR )((int )irp->CurrentLocation - 1);
#line 4793
  (irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation) --;
#line 4798
  status = FlReadWrite(DisketteExtension, irp, (unsigned char)1);
#line 4800
  MmUnlockPages(irp->MdlAddress);
#line 4801
  IoFreeMdl(irp->MdlAddress);
#line 4802
  IoFreeIrp(irp);
#line 4803
  ExFreePool((void *)bootSector);
#line 4804
  // return;
}
}
#line 4806 "floppy.c"
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension , PMDL IoMdl , ULONG IoOffset ,
                          BOOLEAN WriteOperation , UCHAR Cylinder , UCHAR Head , UCHAR Sector ,
                          UCHAR NumberOfSectors , BOOLEAN NeedSeek ) 
{ PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  ULONG byteToSectorShift ;
  ULONG transferBytes ;
  LARGE_INTEGER headSettleTime ;
  NTSTATUS status ;
  ULONG seekRetry ;
  ULONG ioRetry ;
  BOOLEAN recalibrateDrive ;
  UCHAR i ;

  {
#line 4859
  recalibrateDrive = (BOOLEAN )0;
#line 4869
  while (1) {
#line 4869
    break;
  }
#line 4871
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
#line 4872
  byteToSectorShift = (unsigned long )(7 + (int )driveMediaConstants->SectorLengthCode);
#line 4874
  transferBytes = (unsigned long )NumberOfSectors << byteToSectorShift;
#line 4876
  headSettleTime.__annonCompField1.LowPart = (unsigned long )(- (10000 * (int )driveMediaConstants->HeadSettleTime));
#line 4877
  headSettleTime.__annonCompField1.HighPart = -1L;
#line 4879
  seekRetry = 0UL;
#line 4879
  ioRetry = 0UL;
#line 4879
  while (seekRetry < 3UL) {
#line 4881
    if (recalibrateDrive) {
#line 4888
      while (1) {
#line 4888
        break;
      }
#line 4889
      FlRecalibrateDrive(DisketteExtension);
    }
#line 4894
    if (recalibrateDrive) {
      goto _L___0;
    } else {
#line 4894
      if (NeedSeek) {
#line 4894
        if (! DisketteExtension->ControllerConfigurable) {
          goto _L___0;
        } else {
#line 4894
          if ((int )driveMediaConstants->CylinderShift != 0) {
            _L___0: /* CIL Label */ 
#line 4899
            DisketteExtension->FifoBuffer[0] = (unsigned char)16;
#line 4900
            DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )Head << 2) | (int )DisketteExtension->DeviceUnit);
#line 4902
            DisketteExtension->FifoBuffer[2] = (unsigned char )((int )Cylinder << (int )driveMediaConstants->CylinderShift);
#line 4905
            status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                    0UL, 0UL);
#line 4912
            if (status >= 0L) {
#line 4916
              if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
#line 4920
                DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4921
                status = -1073741464L;
              } else {
#line 4916
                if ((int )DisketteExtension->FifoBuffer[1] != (int )Cylinder << (int )driveMediaConstants->CylinderShift) {
#line 4920
                  DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4921
                  status = -1073741464L;
                }
              }
#line 4924
              if (status >= 0L) {
#line 4928
                KeDelayExecutionThread((char)0, (unsigned char)0, & headSettleTime);
#line 4932
                DisketteExtension->FifoBuffer[0] = (unsigned char)84;
#line 4934
                DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )Head << 2) | (int )DisketteExtension->DeviceUnit);
#line 4937
                status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                        DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                        0UL, 0UL);
#line 4944
                if (status >= 0L) {
#line 4946
                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4947
                    if ((int )DisketteExtension->FifoBuffer[0] & 8) {
#line 4948
                      return (-1073741661L);
                    }
                  }
#line 4952
                  if ((int )DisketteExtension->FifoBuffer[0] != (((int )Head << 2) | (int )DisketteExtension->DeviceUnit)) {
#line 4958
                    DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4960
                    status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
                  } else {
#line 4952
                    if ((int )DisketteExtension->FifoBuffer[1] != 0) {
#line 4958
                      DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4960
                      status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                DisketteExtension->FifoBuffer[2]);
                    } else {
#line 4952
                      if ((int )DisketteExtension->FifoBuffer[2] != 0) {
#line 4958
                        DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4960
                        status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                  DisketteExtension->FifoBuffer[2]);
                      } else {
#line 4952
                        if ((int )DisketteExtension->FifoBuffer[3] != (int )Cylinder) {
#line 4958
                          DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4960
                          status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                    DisketteExtension->FifoBuffer[2]);
                        }
                      }
                    }
                  }
                } else {
#line 4968
                  while (1) {
#line 4968
                    break;
                  }
                }
              }
            } else {
#line 4975
              while (1) {
#line 4975
                break;
              }
            }
          } else {
#line 4980
            status = 0L;
          }
        }
      } else {
#line 4980
        status = 0L;
      }
    }
#line 4983
    if (! (status >= 0L)) {
#line 4990
      while (1) {
#line 4990
        break;
      }
#line 4991
      recalibrateDrive = (unsigned char)1;
      goto __Cont;
    }
#line 4995
    while (1) {
#line 5001
      DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )Head << 2) | (int )DisketteExtension->DeviceUnit);
#line 5003
      DisketteExtension->FifoBuffer[2] = Cylinder;
#line 5004
      DisketteExtension->FifoBuffer[3] = Head;
#line 5005
      DisketteExtension->FifoBuffer[4] = (unsigned char )((int )Sector + 1);
#line 5006
      DisketteExtension->FifoBuffer[5] = driveMediaConstants->SectorLengthCode;
#line 5008
      DisketteExtension->FifoBuffer[6] = (unsigned char )((int )Sector + (int )NumberOfSectors);
#line 5009
      DisketteExtension->FifoBuffer[7] = driveMediaConstants->ReadWriteGapLength;
#line 5011
      DisketteExtension->FifoBuffer[8] = driveMediaConstants->DataLength;
#line 5013
      if (WriteOperation) {
#line 5014
        DisketteExtension->FifoBuffer[0] = (unsigned char)66;
      } else {
#line 5017
        DisketteExtension->FifoBuffer[0] = (unsigned char)64;
      }
#line 5021
      status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              IoMdl, IoOffset, transferBytes);
#line 5028
      if (status >= 0L) {
#line 5030
        if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5031
          if ((int )DisketteExtension->FifoBuffer[0] & 8) {
#line 5032
            return (-1073741661L);
          }
        }
#line 5036
        if (((int )DisketteExtension->FifoBuffer[0] & 192) != 0) {
#line 5036
          if (((int )DisketteExtension->FifoBuffer[0] & 192) != 64) {
#line 5044
            DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5046
            status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
          } else {
#line 5036
            if ((int )DisketteExtension->FifoBuffer[1] != 128) {
#line 5044
              DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5046
              status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
            } else {
#line 5036
              if ((int )DisketteExtension->FifoBuffer[2] != 0) {
#line 5044
                DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5046
                status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
              } else {
                goto _L___1;
              }
            }
          }
        } else {
          _L___1: /* CIL Label */ 
#line 5054
          if ((int )DisketteExtension->FifoBuffer[5] != 1) {
#line 5056
            DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5057
            status = -1073741465L;
          }
        }
      } else {
#line 5064
        while (1) {
#line 5064
          break;
        }
      }
#line 5067
      if (status >= 0L) {
#line 5068
        break;
      }
#line 5071
      if (ioRetry >= 2UL) {
#line 5073
        while (1) {
#line 5073
          break;
        }
#line 5074
        break;
      }
#line 4995
      ioRetry ++;
    }
#line 5078
    if (status >= 0L) {
#line 5079
      break;
    }
#line 5083
    recalibrateDrive = (unsigned char)1;
    __Cont: /* CIL Label */ 
#line 4879
    seekRetry ++;
  }
#line 5086
  if (! (status >= 0L)) {
#line 5086
    if ((int )NumberOfSectors > 1) {
#line 5091
      while (1) {
#line 5091
        break;
      }
#line 5093
      i = (unsigned char)0;
#line 5093
      while ((int )i < (int )NumberOfSectors) {
#line 5094
        status = FlReadWriteTrack(DisketteExtension, IoMdl, IoOffset + ((unsigned long )i << byteToSectorShift),
                                  WriteOperation, Cylinder, Head, (unsigned char )((int )Sector + (int )i),
                                  (unsigned char)1, (unsigned char)0);
#line 5104
        if (! (status >= 0L)) {
#line 5108
          while (1) {
#line 5108
            break;
          }
#line 5110
          DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5111
          break;
        }
#line 5093
        i = (UCHAR )((int )i + 1);
      }
    }
  }
#line 5116
  return (status);
}
}
#line 5119 "floppy.c"
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN DriveStarted ) 
{ PIO_STACK_LOCATION irpSp ;
  BOOLEAN writeOperation ;
  NTSTATUS status ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  ULONG byteToSectorShift ;
  ULONG currentSector ;
  ULONG firstSector ;
  ULONG lastSector ;
  ULONG trackSize ;
  UCHAR sectorsPerTrack ;
  UCHAR numberOfHeads ;
  UCHAR currentHead ;
  UCHAR currentCylinder ;
  UCHAR trackSector ;
  PCHAR userBuffer ;
  UCHAR skew ;
  UCHAR skewDelta ;
  UCHAR numTransferSectors ;
  PMDL mdl ;
  PCHAR ioBuffer ;
  ULONG ioOffset ;
  PVOID tmp___0 ;

  {
#line 5169
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 5177
  while (1) {
#line 5177
    break;
  }
#line 5181
  if ((int )irpSp->MajorFunction == 4) {
#line 5182
    if (DisketteExtension->IsReadOnly) {
#line 5183
      while (1) {
#line 5183
        break;
      }
#line 5184
      return (-1073741811L);
    }
#line 5186
    writeOperation = (unsigned char)1;
  } else {
#line 5188
    writeOperation = (unsigned char)0;
  }
#line 5191
  while (1) {
#line 5191
    break;
  }
#line 5195
  if (DriveStarted) {
#line 5196
    status = 0L;
  } else {
#line 5198
    status = FlStartDrive(DisketteExtension, Irp, writeOperation, (unsigned char)1,
                          (unsigned char )(! (! ((int )irpSp->Flags & 2))));
  }
#line 5206
  if (! (status >= 0L)) {
#line 5210
    while (1) {
#line 5210
      break;
    }
#line 5211
    return (status);
  }
#line 5214
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5216
    FlHdbit(DisketteExtension);
  }
#line 5220
  if ((int )DisketteExtension->MediaType == 0) {
#line 5221
    while (1) {
#line 5221
      break;
    }
#line 5222
    return (-1073741804L);
  }
#line 5228
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
#line 5230
  byteToSectorShift = (unsigned long )(7 + (int )driveMediaConstants->SectorLengthCode);
#line 5232
  firstSector = irpSp->Parameters.Read.ByteOffset.__annonCompField1.LowPart >> byteToSectorShift;
#line 5234
  lastSector = firstSector + (irpSp->Parameters.Read.Length >> byteToSectorShift);
#line 5236
  sectorsPerTrack = driveMediaConstants->SectorsPerTrack;
#line 5237
  numberOfHeads = driveMediaConstants->NumberOfHeads;
#line 5238
  if ((int )(Irp->MdlAddress)->MdlFlags & 5) {
#line 5238
    userBuffer = (CHAR *)(Irp->MdlAddress)->MappedSystemVa;
  } else {
#line 5238
    tmp___0 = MmMapLockedPagesSpecifyCache(Irp->MdlAddress, (char)0, 1, (void *)0,
                                           0UL, 32);
#line 5238
    userBuffer = (CHAR *)tmp___0;
  }
#line 5240
  if ((unsigned int )userBuffer == (unsigned int )((void *)0)) {
#line 5243
    while (1) {
#line 5243
      break;
    }
#line 5244
    return (-1073741670L);
  }
#line 5247
  trackSize = (unsigned long )sectorsPerTrack << byteToSectorShift;
#line 5249
  skew = (unsigned char)0;
#line 5250
  skewDelta = driveMediaConstants->SkewDelta;
#line 5251
  currentSector = firstSector;
#line 5251
  while (currentSector < lastSector) {
#line 5257
    currentCylinder = (unsigned char )((currentSector / (ULONG )sectorsPerTrack) / (ULONG )numberOfHeads);
#line 5258
    trackSector = (unsigned char )(currentSector % (unsigned long )sectorsPerTrack);
#line 5259
    currentHead = (unsigned char )((currentSector / (ULONG )sectorsPerTrack) % (unsigned long )numberOfHeads);
#line 5260
    numTransferSectors = (unsigned char )((int )sectorsPerTrack - (int )trackSector);
#line 5261
    if (lastSector - currentSector < (ULONG )numTransferSectors) {
#line 5262
      numTransferSectors = (unsigned char )(lastSector - currentSector);
    }
#line 5272
    if (trackSize > DisketteExtension->MaxTransferSize) {
#line 5276
      while (1) {
#line 5276
        break;
      }
#line 5277
      FlAllocateIoBuffer(DisketteExtension, trackSize);
#line 5278
      if (! DisketteExtension->IoBuffer) {
#line 5282
        while (1) {
#line 5282
          break;
        }
#line 5283
        return (-1073741670L);
      }
#line 5285
      mdl = DisketteExtension->IoBufferMdl;
#line 5286
      ioBuffer = (CHAR *)DisketteExtension->IoBuffer;
#line 5287
      ioOffset = 0UL;
#line 5288
      if (writeOperation) {
#line 5292
        memmove((void *)ioBuffer, (void const   *)(userBuffer + ((currentSector - firstSector) << byteToSectorShift)),
                (unsigned int )((unsigned long )numTransferSectors << byteToSectorShift));
      }
    } else {
#line 5295
      mdl = Irp->MdlAddress;
#line 5296
      ioOffset = (currentSector - firstSector) << byteToSectorShift;
    }
#line 5307
    if ((int )skew >= (int )numTransferSectors + (int )trackSector) {
#line 5308
      skew = (unsigned char)0;
    }
#line 5311
    if ((int )skew < (int )trackSector) {
#line 5312
      skew = trackSector;
    }
#line 5317
    status = FlReadWriteTrack(DisketteExtension, mdl, ioOffset + (((unsigned long )skew - (unsigned long )trackSector) << byteToSectorShift),
                              writeOperation, currentCylinder, currentHead, skew,
                              (unsigned char )(((int )numTransferSectors + (int )trackSector) - (int )skew),
                              (unsigned char)1);
#line 5330
    if (status >= 0L) {
#line 5330
      if ((int )skew > (int )trackSector) {
#line 5331
        status = FlReadWriteTrack(DisketteExtension, mdl, ioOffset, writeOperation,
                                  currentCylinder, currentHead, trackSector, (unsigned char )((int )skew - (int )trackSector),
                                  (unsigned char)0);
      } else {
#line 5341
        skew = (unsigned char )(((int )numTransferSectors + (int )trackSector) % (int )sectorsPerTrack);
      }
    } else {
#line 5341
      skew = (unsigned char )(((int )numTransferSectors + (int )trackSector) % (int )sectorsPerTrack);
    }
#line 5344
    if (! (status >= 0L)) {
#line 5345
      break;
    }
#line 5353
    if (! writeOperation) {
#line 5353
      if (trackSize > DisketteExtension->MaxTransferSize) {
#line 5359
        memmove((void *)(userBuffer + ((currentSector - firstSector) << byteToSectorShift)),
                (void const   *)ioBuffer, (unsigned int )((unsigned long )numTransferSectors << byteToSectorShift));
      }
    }
#line 5367
    skew = (unsigned char )(((int )skew + (int )skewDelta) % (int )sectorsPerTrack);
#line 5251
    currentSector += (ULONG )numTransferSectors;
  }
#line 5370
  Irp->IoStatus.Information = (currentSector - firstSector) << byteToSectorShift;
#line 5377
  if (status >= 0L) {
#line 5377
    if (firstSector == 0UL) {
#line 5378
      FlConsolidateMediaTypeWithBootSector(DisketteExtension, (struct _BOOT_SECTOR_INFO *)userBuffer);
    }
  }
#line 5385
  while (1) {
#line 5385
    break;
  }
#line 5386
  return (status);
}
}
#line 5389 "floppy.c"
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) 
{ LARGE_INTEGER headSettleTime ;
  PIO_STACK_LOCATION irpSp ;
  PBAD_TRACK_NUMBER badTrackBuffer ;
  PFORMAT_PARAMETERS formatParameters ;
  PFORMAT_EX_PARAMETERS formatExParameters ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  NTSTATUS ntStatus ;
  ULONG badTrackBufferLength ;
  DRIVE_MEDIA_TYPE driveMediaType ;
  UCHAR driveStatus ;
  UCHAR numberOfBadTracks ;
  UCHAR currentTrack ;
  UCHAR endTrack ;
  UCHAR whichSector ;
  UCHAR retryCount ;
  BOOLEAN bufferOverflow ;
  FDC_DISK_CHANGE_PARMS fdcDiskChangeParms ;
  ULONG length ;
  UCHAR tmp ;

  {
#line 5429
  numberOfBadTracks = (UCHAR )0;
#line 5434
  bufferOverflow = (BOOLEAN )0;
#line 5440
  while (1) {
#line 5440
    break;
  }
#line 5442
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 5443
  formatParameters = (struct _FORMAT_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
#line 5444
  if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (3 << 14)) | (11 << 2))) {
#line 5446
    formatExParameters = (struct _FORMAT_EX_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
  } else {
#line 5449
    formatExParameters = (struct _FORMAT_EX_PARAMETERS *)((void *)0);
  }
#line 5464
  while (1) {
#line 5464
    break;
  }
#line 5466
  badTrackBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
#line 5475
  driveMediaType = (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType;
#line 5478
  while (1) {
#line 5478
    if ((int )(DriveMediaConstants + driveMediaType)->MediaType != (int )formatParameters->MediaType) {
#line 5478
      if (! ((int )driveMediaType > (int )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType)) {
#line 5478
        break;
      }
    } else {
#line 5478
      break;
    }
#line 5483
    driveMediaType = (DRIVE_MEDIA_TYPE )((int )driveMediaType - 1);
  }
#line 5486
  driveMediaConstants = DriveMediaConstants + driveMediaType;
#line 5493
  DisketteExtension->MediaType = formatParameters->MediaType;
#line 5494
  DisketteExtension->DriveMediaType = driveMediaType;
#line 5495
  DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + driveMediaType);
#line 5498
  if (formatExParameters) {
#line 5499
    DisketteExtension->DriveMediaConstants.SectorsPerTrack = (unsigned char )formatExParameters->SectorsPerTrack;
#line 5501
    DisketteExtension->DriveMediaConstants.FormatGapLength = (unsigned char )formatExParameters->FormatGapLength;
  }
#line 5505
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
#line 5507
  DisketteExtension->BytesPerSector = (unsigned long )driveMediaConstants->BytesPerSector;
#line 5509
  DisketteExtension->ByteCapacity = (unsigned long )((((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads);
#line 5515
  currentTrack = (unsigned char )(formatParameters->StartCylinderNumber * (ULONG )driveMediaConstants->NumberOfHeads + formatParameters->StartHeadNumber);
#line 5519
  endTrack = (unsigned char )(formatParameters->EndCylinderNumber * (ULONG )driveMediaConstants->NumberOfHeads + formatParameters->EndHeadNumber);
#line 5528
  while (1) {
#line 5528
    break;
  }
#line 5535
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5537
    FlHdbit(DisketteExtension);
  }
#line 5541
  if ((int )DisketteExtension->LastDriveMediaType != (int )driveMediaType) {
#line 5543
    ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
#line 5545
    if (! (ntStatus >= 0L)) {
#line 5547
      return (ntStatus);
    }
  }
#line 5555
  DisketteExtension->IsReadOnly = (unsigned char)0;
#line 5561
  while (1) {
#line 5567
    DisketteExtension->FifoBuffer[0] = (unsigned char)16;
#line 5568
    DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 5569
    DisketteExtension->FifoBuffer[2] = (unsigned char )((int )currentTrack / (int )driveMediaConstants->NumberOfHeads << (int )driveMediaConstants->CylinderShift);
#line 5577
    while (1) {
#line 5577
      break;
    }
#line 5579
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (struct _MDL *)((void *)0), 0UL, 0UL);
#line 5586
    if (ntStatus >= 0L) {
#line 5588
      if ((int )DisketteExtension->FifoBuffer[0] & 32) {
#line 5588
        if ((int )DisketteExtension->FifoBuffer[1] == (int )((unsigned char )((int )currentTrack / (int )driveMediaConstants->NumberOfHeads << (int )driveMediaConstants->CylinderShift))) {
#line 5598
          headSettleTime.__annonCompField1.LowPart = (unsigned long )(- (10000 * (int )driveMediaConstants->HeadSettleTime));
#line 5600
          headSettleTime.__annonCompField1.HighPart = -1L;
#line 5602
          KeDelayExecutionThread((char)0, (unsigned char)0, & headSettleTime);
#line 5607
          if (! ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1)) {
#line 5619
            DisketteExtension->FifoBuffer[0] = (unsigned char)84;
#line 5621
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 5624
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                      0UL, 0UL);
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 5641
        while (1) {
#line 5641
          break;
        }
#line 5643
        DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5645
        ntStatus = -1073741464L;
      }
    }
#line 5649
    if (! (ntStatus >= 0L)) {
#line 5654
      while (1) {
#line 5654
        break;
      }
#line 5656
      return (ntStatus);
    }
#line 5663
    whichSector = (unsigned char)0;
#line 5663
    while ((int )whichSector < (int )driveMediaConstants->SectorsPerTrack) {
#line 5667
      *(DisketteExtension->IoBuffer + (int )whichSector * 4) = (unsigned char )((int )currentTrack / (int )driveMediaConstants->NumberOfHeads);
#line 5669
      *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 1)) = (unsigned char )((int )currentTrack % (int )driveMediaConstants->NumberOfHeads);
#line 5671
      if (formatExParameters) {
#line 5672
        *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 2)) = (unsigned char )formatExParameters->SectorNumber[whichSector];
      } else {
#line 5675
        *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 2)) = (unsigned char )((int )whichSector + 1);
      }
#line 5678
      *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 3)) = driveMediaConstants->SectorLengthCode;
#line 5689
      while (1) {
#line 5689
        break;
      }
#line 5663
      whichSector = (UCHAR )((int )whichSector + 1);
    }
#line 5696
    retryCount = (unsigned char)0;
#line 5698
    while (1) {
#line 5702
      length = (unsigned long )driveMediaConstants->BytesPerSector;
#line 5708
      DisketteExtension->FifoBuffer[0] = (unsigned char)71;
#line 5710
      DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )currentTrack % (int )driveMediaConstants->NumberOfHeads << 2) | (int )DisketteExtension->DeviceUnit);
#line 5713
      DisketteExtension->FifoBuffer[2] = driveMediaConstants->SectorLengthCode;
#line 5715
      DisketteExtension->FifoBuffer[3] = driveMediaConstants->SectorsPerTrack;
#line 5717
      DisketteExtension->FifoBuffer[4] = driveMediaConstants->FormatGapLength;
#line 5719
      DisketteExtension->FifoBuffer[5] = driveMediaConstants->FormatFillCharacter;
#line 5735
      while (1) {
#line 5735
        break;
      }
#line 5736
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, DisketteExtension->IoBufferMdl,
                                0UL, length);
#line 5743
      if (! (ntStatus >= 0L)) {
#line 5748
        while (1) {
#line 5748
          break;
        }
      }
#line 5751
      if (ntStatus >= 0L) {
#line 5757
        if ((int )DisketteExtension->FifoBuffer[0] & 208) {
          goto _L___0;
        } else {
#line 5757
          if ((int )DisketteExtension->FifoBuffer[1] & 16) {
            goto _L___0;
          } else {
#line 5757
            if ((int )DisketteExtension->FifoBuffer[2] != 0) {
              _L___0: /* CIL Label */ 
#line 5775
              while (1) {
#line 5775
                break;
              }
#line 5777
              DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5779
              ntStatus = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
            }
          }
        }
      }
#line 5698
      if (! (ntStatus >= 0L)) {
#line 5698
        tmp = retryCount;
#line 5698
        retryCount = (UCHAR )((int )retryCount + 1);
#line 5698
        if (! (tmp < 3)) {
#line 5698
          break;
        }
      } else {
#line 5698
        break;
      }
    }
#line 5788
    if (! (ntStatus >= 0L)) {
#line 5790
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5791
        DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 5792
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 5794
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                  0UL, 0UL);
#line 5801
        if (! (ntStatus >= 0L)) {
#line 5806
          while (1) {
#line 5806
            break;
          }
#line 5808
          return (ntStatus);
        }
#line 5811
        if ((int )DisketteExtension->FifoBuffer[0] & 32) {
#line 5813
          driveStatus = (unsigned char)127;
        } else {
#line 5817
          driveStatus = (unsigned char)128;
        }
      } else {
#line 5822
        ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (776 << 2)) | 3),
                                 (void *)(& fdcDiskChangeParms));
#line 5826
        driveStatus = fdcDiskChangeParms.DriveStatus;
      }
#line 5829
      if ((int )DisketteExtension->DriveType != 0) {
#line 5829
        if ((int )driveStatus & 128) {
#line 5837
          return (-1073741805L);
        }
      }
#line 5847
      while (1) {
#line 5847
        break;
      }
#line 5849
      if (badTrackBufferLength >= (unsigned long )((unsigned int )((int )numberOfBadTracks + 1) * sizeof(BAD_TRACK_NUMBER ))) {
#line 5852
        badTrackBuffer = (USHORT *)Irp->AssociatedIrp.SystemBuffer;
#line 5855
        *(badTrackBuffer + numberOfBadTracks) = (unsigned short )currentTrack;
      } else {
#line 5860
        bufferOverflow = (unsigned char)1;
      }
#line 5863
      numberOfBadTracks = (UCHAR )((int )numberOfBadTracks + 1);
    }
#line 5866
    currentTrack = (UCHAR )((int )currentTrack + 1);
#line 5561
    if (! ((int )currentTrack <= (int )endTrack)) {
#line 5561
      break;
    }
  }
#line 5870
  if (ntStatus >= 0L) {
#line 5870
    if (bufferOverflow) {
#line 5872
      ntStatus = -2147483643L;
    }
  }
#line 5875
  return (ntStatus);
}
}
#line 5878 "floppy.c"
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension , PFORMAT_PARAMETERS FormatParameters ) 
{ PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  DRIVE_MEDIA_TYPE driveMediaType ;

  {
#line 5913
  driveMediaType = (DriveMediaLimits + DisketteExtension->DriveType)->HighestDriveMediaType;
#line 5916
  while (1) {
#line 5916
    if ((int )(DriveMediaConstants + driveMediaType)->MediaType != (int )FormatParameters->MediaType) {
#line 5916
      if (! ((int )driveMediaType > (int )(DriveMediaLimits + DisketteExtension->DriveType)->LowestDriveMediaType)) {
#line 5916
        break;
      }
    } else {
#line 5916
      break;
    }
#line 5921
    driveMediaType = (DRIVE_MEDIA_TYPE )((int )driveMediaType - 1);
  }
#line 5924
  if ((int )(DriveMediaConstants + driveMediaType)->MediaType != (int )FormatParameters->MediaType) {
#line 5927
    return ((unsigned char)0);
  } else {
#line 5931
    driveMediaConstants = DriveMediaConstants + driveMediaType;
#line 5933
    if (FormatParameters->StartHeadNumber > (unsigned long )((int )driveMediaConstants->NumberOfHeads - 1)) {
#line 5944
      return ((unsigned char)0);
    } else {
#line 5933
      if (FormatParameters->EndHeadNumber > (unsigned long )((int )driveMediaConstants->NumberOfHeads - 1)) {
#line 5944
        return ((unsigned char)0);
      } else {
#line 5933
        if (FormatParameters->StartCylinderNumber > (ULONG )driveMediaConstants->MaximumTrack) {
#line 5944
          return ((unsigned char)0);
        } else {
#line 5933
          if (FormatParameters->EndCylinderNumber > (ULONG )driveMediaConstants->MaximumTrack) {
#line 5944
            return ((unsigned char)0);
          } else {
#line 5933
            if (FormatParameters->EndCylinderNumber < FormatParameters->StartCylinderNumber) {
#line 5944
              return ((unsigned char)0);
            } else {
#line 5948
              if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5949
                if ((int )FormatParameters->MediaType == 6) {
#line 5955
                  return ((unsigned char)0);
                } else {
#line 5949
                  if ((int )FormatParameters->MediaType == 7) {
#line 5955
                    return ((unsigned char)0);
                  } else {
#line 5949
                    if ((int )FormatParameters->MediaType == 8) {
#line 5955
                      return ((unsigned char)0);
                    } else {
#line 5949
                      if ((int )FormatParameters->MediaType == 9) {
#line 5955
                        return ((unsigned char)0);
                      } else {
#line 5949
                        if ((int )FormatParameters->MediaType == 10) {
#line 5955
                          return ((unsigned char)0);
                        }
                      }
                    }
                  }
                }
              }
#line 5959
              return ((unsigned char)1);
            }
          }
        }
      }
    }
  }
}
}
#line 5964 "floppy.c"
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension , PUCHAR FifoInBuffer ,
                        PUCHAR FifoOutBuffer , PMDL IoMdl , ULONG IoOffset , ULONG TransferBytes ) 
{ NTSTATUS ntStatus ;
  ISSUE_FDC_COMMAND_PARMS issueCommandParms ;

  {
#line 6018
  issueCommandParms.FifoInBuffer = FifoInBuffer;
#line 6019
  issueCommandParms.FifoOutBuffer = FifoOutBuffer;
#line 6020
  issueCommandParms.IoHandle = (void *)IoMdl;
#line 6021
  issueCommandParms.IoOffset = IoOffset;
#line 6022
  issueCommandParms.TransferBytes = TransferBytes;
#line 6023
  issueCommandParms.TimeOut = 4UL;
#line 6028
  while (1) {
#line 6028
    break;
  }
#line 6030
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (771 << 2)) | 3),
                           (void *)(& issueCommandParms));
#line 6038
  if (ntStatus == -1073741661L) {
#line 6041
    DisketteExtension->HardwareFailed = (unsigned char)1;
  } else {
#line 6038
    if (ntStatus == -1073741464L) {
#line 6041
      DisketteExtension->HardwareFailed = (unsigned char)1;
    }
  }
#line 6044
  return (ntStatus);
}
}
#line 6047 "floppy.c"
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;

  {
#line 6069
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (773 << 2)) | 3),
                           (void *)0);
#line 6073
  if (ntStatus >= 0L) {
#line 6075
    if ((int )DisketteExtension->PerpendicularMode != 0) {
#line 6077
      DisketteExtension->FifoBuffer[0] = (unsigned char)21;
#line 6078
      DisketteExtension->FifoBuffer[1] = (unsigned char )(128 | ((int )DisketteExtension->PerpendicularMode << 2));
#line 6082
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                0UL, 0UL);
    }
  }
#line 6092
  return (ntStatus);
}
}
#line 6095 "floppy.c"
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject , ULONG Ioctl , PVOID Data ) 
{ NTSTATUS ntStatus ;
  PIRP irp ;
  PIO_STACK_LOCATION irpStack ;
  KEVENT doneEvent ;
  IO_STATUS_BLOCK ioStatus ;

  {
#line 6108
  while (1) {
#line 6108
    break;
  }
#line 6110
  KeInitializeEvent(& doneEvent, 0, (unsigned char)0);
#line 6117
  irp = IoBuildDeviceIoControlRequest(Ioctl, DeviceObject, (void *)0, 0UL, (void *)0,
                                      0UL, (unsigned char)1, & doneEvent, & ioStatus);
#line 6127
  if ((unsigned int )irp == (unsigned int )((void *)0)) {
#line 6129
    while (1) {
#line 6129
      break;
    }
#line 6135
    return (-1073741670L);
  }
#line 6138
  irpStack = irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 6139
  irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;
#line 6144
  ntStatus = IofCallDriver(DeviceObject, irp);
#line 6146
  if (ntStatus == 259L) {
#line 6152
    KeWaitForSingleObject((void *)(& doneEvent), 5, (char)0, (unsigned char)0, (LARGE_INTEGER *)((void *)0));
#line 6158
    ntStatus = ioStatus.__annonCompField4.Status;
  }
#line 6161
  return (ntStatus);
}
}
#line 6165 "floppy.c"
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  SHORT st5 ;
  BOOLEAN media144MB ;
  BOOLEAN mediaUpTo120MB ;
  BOOLEAN supportDrive ;
  SET_HD_BIT_PARMS setHdBitParameter ;

  {
#line 6195
  st5 = (SHORT )0;
#line 6210
  media144MB = (unsigned char)0;
#line 6211
  mediaUpTo120MB = (unsigned char)0;
#line 6212
  supportDrive = (unsigned char)1;
#line 6217
  while (1) {
#line 6217
    break;
  }
#line 6219
  switch ((int )DisketteExtension->DriveMediaType) {
  case 18: 
#line 6226
  media144MB = (unsigned char)1;
  case 16: ;
  case 17: ;
  case 12: ;
  case 13: ;
  case 19: ;
  case 20: 
#line 6234
  mediaUpTo120MB = (unsigned char)1;
  case 0: ;
  case 1: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 7: ;
  case 8: ;
  case 9: ;
  case 10: ;
  case 11: ;
  case 14: ;
  case 15: ;
#line 6253
  break;
  default: 
#line 6260
  mediaUpTo120MB = (unsigned char)1;
#line 6262
  break;
  }
#line 6265
  setHdBitParameter.Media144MB = media144MB;
#line 6266
  setHdBitParameter.More120MB = mediaUpTo120MB;
#line 6267
  setHdBitParameter.DeviceUnit = DisketteExtension->DeviceUnit;
#line 6268
  if ((int )DisketteExtension->DriveType == 3) {
#line 6268
    setHdBitParameter.DriveType144MB = (unsigned char)1;
  } else {
#line 6268
    setHdBitParameter.DriveType144MB = (unsigned char)0;
  }
#line 6271
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (785 << 2)) | 3),
                           (void *)(& setHdBitParameter));
#line 6275
  if (! (ntStatus >= 0L)) {
#line 6276
    return (ntStatus);
  }
#line 6279
  if (setHdBitParameter.ChangedHdBit) {
#line 6281
    ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
  }
#line 6284
  return (ntStatus);
}
}
#line 6286 "floppy.c"
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) 
{ KIRQL oldIrql ;
  NTSTATUS ntStatus ;
  LONG tmp ;

  {
#line 6318
  ExAcquireFastMutex(PagingMutex);
#line 6318
  PagingReferenceCount ++;
#line 6318
  if (PagingReferenceCount == 1UL) {
#line 6318
    MmResetDriverPaging((void *)(& DriverEntry));
  }
#line 6318
  ExReleaseFastMutex(PagingMutex);
#line 6333
  oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
#line 6335
  InterlockedExchange((LONG *)((PVOID *)(& Irp->CancelRoutine)), (long )((void *)(& FloppyCancelQueuedRequest)));
#line 6340
  if (Irp->Cancel) {
#line 6340
    tmp = InterlockedExchange((LONG *)((PVOID *)(& Irp->CancelRoutine)), (long )((void *)0));
#line 6340
    if ((void (*)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ))((void *)tmp)) {
#line 6345
      Irp->IoStatus.__annonCompField4.Status = -1073741536L;
#line 6346
      myStatus = -1073741536L;
#line 6347
      Irp->IoStatus.Information = 0UL;
#line 6348
      KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql);
#line 6349
      IofCompleteRequest(Irp, (char)0);
#line 6351
      ExAcquireFastMutex(PagingMutex);
#line 6351
      PagingReferenceCount --;
#line 6351
      if (PagingReferenceCount == 0UL) {
#line 6351
        MmPageEntireDriver((void *)(& DriverEntry));
      }
#line 6351
      ExReleaseFastMutex(PagingMutex);
#line 6353
      ntStatus = -1073741536L;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 6359
    Irp->IoStatus.__annonCompField4.Status = 259L;
#line 6360
    myStatus = 259L;
#line 6361
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (unsigned char )((int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1);
#line 6362
    if (pended == 0) {
#line 6362
      pended = 1;
    } else {
#line 6362
      assert(0);
    }
#line 6363
    ExfInterlockedInsertTailList(& DisketteExtension->NewRequestQueue, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                                 & DisketteExtension->NewRequestQueueSpinLock);
#line 6368
    KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql);
#line 6370
    ntStatus = 259L;
  }
#line 6373
  return (ntStatus);
}
}
#line 6375 "floppy.c"
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  KIRQL oldIrql ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;

  {
#line 6402
  disketteExtension = (PDISKETTE_EXTENSION )DeviceObject->DeviceExtension;
#line 6406
  while (1) {
#line 6406
    break;
  }
#line 6409
  oldIrql = KfAcquireSpinLock(& disketteExtension->FlCancelSpinLock);
#line 6411
  Irp->IoStatus.__annonCompField4.Status = -1073741536L;
#line 6412
  myStatus = -1073741536L;
#line 6413
  Irp->IoStatus.Information = 0UL;
#line 6417
  if (Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink) {
#line 6418
    _EX_Flink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink;
#line 6418
    _EX_Blink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Blink;
#line 6418
    _EX_Blink->Flink = _EX_Flink;
#line 6418
    _EX_Flink->Blink = _EX_Blink;
  }
#line 6422
  KfReleaseSpinLock(& disketteExtension->FlCancelSpinLock, oldIrql);
#line 6424
  IoReleaseCancelSpinLock(Irp->CancelIrql);
#line 6426
  IofCompleteRequest(Irp, (char)0);
#line 6428
  ExAcquireFastMutex(PagingMutex);
#line 6428
  PagingReferenceCount --;
#line 6428
  if (PagingReferenceCount == 0UL) {
#line 6428
    MmPageEntireDriver((void *)(& DriverEntry));
  }
#line 6428
  ExReleaseFastMutex(PagingMutex);
#line 6430
  // return;
}
}
#line 6432 "floppy.c"
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension ) 
{ KIRQL oldIrql ;
  PLIST_ENTRY headOfList ;
  PIRP currentIrp ;
  PIO_STACK_LOCATION irpSp ;
  LONG tmp ;

  {
#line 6470
  oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
#line 6471
  while (1) {
#line 6471
    headOfList = ExfInterlockedRemoveHeadList(& DisketteExtension->NewRequestQueue,
                                              & DisketteExtension->NewRequestQueueSpinLock);
#line 6471
    if (! ((unsigned int )headOfList != (unsigned int )((void *)0))) {
#line 6471
      break;
    }
#line 6475
    currentIrp = (IRP *)((CHAR *)headOfList - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
#line 6479
    tmp = InterlockedExchange((LONG *)((PVOID *)(& currentIrp->CancelRoutine)), (long )((void *)0));
#line 6479
    if ((void (*)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ))((void *)tmp)) {
#line 6480
      irpSp = currentIrp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
    } else {
#line 6487
      currentIrp->Tail.Overlay.__annonCompField17.ListEntry.Flink = (struct _LIST_ENTRY *)((void *)0);
#line 6488
      currentIrp = (struct _IRP *)((void *)0);
    }
#line 6492
    KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql);
#line 6494
    if (currentIrp) {
#line 6495
      if (DisketteExtension->IsRemoved) {
#line 6499
        currentIrp->IoStatus.Information = 0UL;
#line 6500
        currentIrp->IoStatus.__annonCompField4.Status = -1073741738L;
#line 6501
        IofCompleteRequest(currentIrp, (char)0);
      } else {
#line 6505
        switch ((int )irpSp->MajorFunction) {
        case 3: ;
        case 4: 
#line 6510
        FloppyReadWrite(DisketteExtension->DeviceObject, currentIrp);
#line 6511
        break;
        case 14: 
#line 6515
        FloppyDeviceControl(DisketteExtension->DeviceObject, currentIrp);
#line 6516
        break;
        default: 
#line 6520
        currentIrp->IoStatus.Information = 0UL;
#line 6521
        currentIrp->IoStatus.__annonCompField4.Status = -1073741823L;
#line 6522
        IofCompleteRequest(currentIrp, (char)0);
        }
      }
    }
#line 6527
    if (currentIrp) {
#line 6531
      ExAcquireFastMutex(PagingMutex);
#line 6531
      PagingReferenceCount --;
#line 6531
      if (PagingReferenceCount == 0UL) {
#line 6531
        MmPageEntireDriver((void *)(& DriverEntry));
      }
#line 6531
      ExReleaseFastMutex(PagingMutex);
    }
#line 6535
    oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
  }
#line 6540
  KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql);
#line 6542
  // return;
}
}
#line 17 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"
#pragma once
#line 26 "C:/NTDDK/inc/ntdef.h"
#pragma once
#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"
#pragma once
#line 26 "C:/NTDDK/inc/basetsd.h"
#pragma once
#line 832 "C:/NTDDK/inc/ntdef.h"
#pragma warning(push)
#line 834
#pragma warning(disable:4035)
#line 835 "C:/NTDDK/inc/ntdef.h"
__inline ULONGLONG ( __attribute__((__stdcall__)) Int64ShllMod32___1)(ULONGLONG Value ,
                                                                      ULONG ShiftCount ) 
{ 

  {
#line 850
  return (0ULL);
}
}
#line 845 "C:/NTDDK/inc/ntdef.h"
__inline LONGLONG ( __attribute__((__stdcall__)) Int64ShraMod32___1)(LONGLONG Value ,
                                                                     ULONG ShiftCount ) 
{ 

  {
#line 860
  return (0LL);
}
}
#line 855 "C:/NTDDK/inc/ntdef.h"
__inline ULONGLONG ( __attribute__((__stdcall__)) Int64ShrlMod32___1)(ULONGLONG Value ,
                                                                      ULONG ShiftCount ) 
{ 

  {
#line 870
  return (0ULL);
}
}
#line 873
#pragma warning(pop)
#line 17 "C:/NTDDK/inc/string.h"
#pragma once
#line 25 "C:/NTDDK/inc/pshpack4.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 1953 "C:/NTDDK/inc/ddk/ntddk.h"
#pragma warning(push)
#line 1955
#pragma warning(disable:4035)
#line 2020
#pragma warning(pop)
#line 5253
#pragma warning(disable:4035)
#line 7015
#pragma warning(push)
#line 7017
#pragma warning(disable:4164)
#line 7020
#pragma function(_enable)
#line 7021
#pragma function(_disable)
#line 7025
#pragma warning(pop)
#line 25 "C:/NTDDK/inc/pshpack4.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 25 "C:/NTDDK/inc/pshpack1.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 25 "C:/NTDDK/inc/pshpack4.h"
#pragma warning(disable:4103)
#line 28 "C:/NTDDK/inc/poppack.h"
#pragma warning(disable:4103)
#line 17779 "C:/NTDDK/inc/ddk/ntddk.h"
#pragma warning(disable:4200)
#line 17785
#pragma warning(default:4200)
#line 37 "../slam-kernel.c"
IRP *pirp  ;
#line 39 "../slam-kernel.c"
void stub_driver_init(void) 
{ 

  {
#line 41
  s = NP;
#line 46
  pended = 0;
#line 47
  compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))0;
#line 48
  compRegistered = 0;
#line 49
  lowerDriverReturn = 0;
#line 50
  setEventCalled = 0;
#line 51
  customIrp = 0;
#line 52
 // // return;
}
}
#line 48 "../slam-kernel.c"
int main(void) 
{ DRIVER_OBJECT d ;
  UNICODE_STRING u ;
  NTSTATUS status ;
  int we_should_unload ;
  IRP irp ;
  int __BLAST_NONDET ;
  int irp_choice ;
  DEVICE_OBJECT devobj ;

  {
#line 51
  status = (NTSTATUS )0;
#line 54
  pirp = & irp;
#line 54
  //BLAST_init();
#line 56
  status = DriverEntry(& d, & u);
#line 58
  if (status >= 0L) {
#line 71
    s = NP;
#line 72
    customIrp = 0;
#line 72
    setEventCalled = customIrp;
#line 72
    lowerDriverReturn = setEventCalled;
#line 72
    compRegistered = lowerDriverReturn;
#line 72
    compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))compRegistered;
#line 72
    pended = (int )compFptr;
#line 75
    pirp->IoStatus.__annonCompField4.Status = 0L;
#line 76
    myStatus = 0L;
#line 77
    if (irp_choice == 0) {
#line 77
      pirp->IoStatus.__annonCompField4.Status = -1073741637L;
#line 78
      myStatus = -1073741637L;
    }
#line 82
    stub_driver_init();
#line 84
    if (! (status >= 0L)) {
#line 84
      return (-1);
    }
#line 88
    switch (__BLAST_NONDET) {
    case 0: 
#line 92
    status = FloppyCreateClose(& devobj, pirp);
#line 93
    break;
    case 1: 
#line 98
    status = FloppyCreateClose(& devobj, pirp);
#line 99
    break;
    case 2: 
#line 104
    status = FloppyDeviceControl(& devobj, pirp);
#line 105
    break;
    case 3: 
#line 110
    status = FloppyPnp(& devobj, pirp);
#line 111
    break;
    case 4: 
#line 116
    status = FloppyPower(& devobj, pirp);
#line 117
    break;
    default: ;
#line 180
    return (-1);
    }
#line 185
    if (we_should_unload) {
#line 187
      FloppyUnload(& d);
    }
  }
#line 192
  if (pended == 1) {
#line 192
    if (s == NP) {
#line 193
      s = NP;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 195
    if (pended == 1) {
#line 195
      if (s == MPR3) {
#line 196
        s = MPR3;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 198
      if (! (s == UNLOADED)) {
#line 198
        if (! (status == -1L)) {
#line 201
          if (s != SKIP2) {
#line 201
            if (s != IPC) {
#line 201
              if (s != DC) {
#line 201
                //assert(0); // bug in FF
              } else {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 203
            if (pended == 1) {
#line 204
              if (status != 259L) {
#line 204
                status = 0L;
              }
            } else {
#line 206
              if (s == DC) {
#line 207
                if (status == 259L) {
#line 207
                  assert(0);;
                }
              } else {
#line 209
                if (status != (NTSTATUS )lowerDriverReturn) {
#line 209
                  assert(0);;
                }
              }
            }
          }
        }
      }
    }
  }
#line 216
  status = 0L;
#line 217
  return ((int )status);
}
}
#line 220 "../slam-kernel.c"
char _SLAM_alloc_dummy  ;
#line 222 "../slam-kernel.c"
char *malloc(int i ) 
{ 

  {
#line 222
  return (& _SLAM_alloc_dummy);
}
}
#line 230
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) ExAcquireFastMutex)(PFAST_MUTEX FastMutex ) ;
#line 230 "../slam-kernel.c"
void ( __attribute__((__fastcall__)) ExAcquireFastMutex)(PFAST_MUTEX FastMutex ) 
{ 

  {
#line 237
  // // return;
}
}
#line 240
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) ExReleaseFastMutex)(PFAST_MUTEX FastMutex ) ;
#line 240 "../slam-kernel.c"
void ( __attribute__((__fastcall__)) ExReleaseFastMutex)(PFAST_MUTEX FastMutex ) 
{ 

  {
#line 247
  // // return;
}
}
#line 264
 __attribute__((__dllimport__)) PVOID ( __attribute__((__stdcall__)) ExAllocatePoolWithTag)(POOL_TYPE PoolType ,
                                                                                            SIZE_T NumberOfBytes ,
                                                                                            ULONG Tag ) ;
#line 264 "../slam-kernel.c"
PVOID ( __attribute__((__stdcall__)) ExAllocatePoolWithTag)(POOL_TYPE PoolType , SIZE_T NumberOfBytes ,
                                                            ULONG Tag ) 
{ PVOID x ;
  char *tmp ;

  {
#line 274
  tmp = malloc((int )NumberOfBytes);
#line 274
  x = (void *)tmp;
#line 275
  return (x);
}
}
#line 279
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) ExFreePool)(PVOID P ) ;
#line 279 "../slam-kernel.c"
void ( __attribute__((__stdcall__)) ExFreePool)(PVOID P ) 
{ 

  {
#line 285
  // // return;
}
}
#line 288
 __attribute__((__dllimport__)) PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedInsertHeadList)(PLIST_ENTRY ListHead ,
                                                                                                          PLIST_ENTRY ListEntry ,
                                                                                                          PKSPIN_LOCK Lock ) ;
#line 288 "../slam-kernel.c"
PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedInsertHeadList)(PLIST_ENTRY ListHead ,
                                                                          PLIST_ENTRY ListEntry ,
                                                                          PKSPIN_LOCK Lock ) 
{ 

  {
#line 296
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 299
 __attribute__((__dllimport__)) PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedInsertTailList)(PLIST_ENTRY ListHead ,
                                                                                                          PLIST_ENTRY ListEntry ,
                                                                                                          PKSPIN_LOCK Lock ) ;
#line 299 "../slam-kernel.c"
PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedInsertTailList)(PLIST_ENTRY ListHead ,
                                                                          PLIST_ENTRY ListEntry ,
                                                                          PKSPIN_LOCK Lock ) 
{ 

  {
#line 308
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 311
 __attribute__((__dllimport__)) PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedRemoveHeadList)(PLIST_ENTRY ListHead ,
                                                                                                          PKSPIN_LOCK Lock ) ;
#line 311 "../slam-kernel.c"
PLIST_ENTRY ( __attribute__((__fastcall__)) ExfInterlockedRemoveHeadList)(PLIST_ENTRY ListHead ,
                                                                          PKSPIN_LOCK Lock ) 
{ 

  {
#line 319
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 335
 __attribute__((__dllimport__)) PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
                                                   BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota ,
                                                   PIRP Irp ) ;
#line 335 "../slam-kernel.c"
PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length , BOOLEAN SecondaryBuffer ,
                   BOOLEAN ChargeQuota , PIRP Irp ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 346
  switch (__BLAST_NONDET) {
  case 0: 
#line 347
  tmp = malloc((int )sizeof(MDL ));
#line 347
  return ((struct _MDL *)((void *)tmp));
  default: ;
#line 348
  return ((struct _MDL *)((void *)0));
  }
}
}
#line 352
 __attribute__((__dllimport__)) PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice ,
                                                                           PDEVICE_OBJECT TargetDevice ) ;
#line 352 "../slam-kernel.c"
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice , PDEVICE_OBJECT TargetDevice ) 
{ int __BLAST_NONDET ;

  {
#line 360
  switch (__BLAST_NONDET) {
  case 0: ;
#line 361
  return (TargetDevice);
  default: ;
#line 362
  return ((struct _DEVICE_OBJECT *)((void *)0));
  }
}
}
#line 366
 __attribute__((__dllimport__)) PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
                                                                   PDEVICE_OBJECT DeviceObject ,
                                                                   PVOID Buffer ,
                                                                   ULONG Length ,
                                                                   PLARGE_INTEGER StartingOffset ,
                                                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 366 "../slam-kernel.c"
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction , PDEVICE_OBJECT DeviceObject ,
                                   PVOID Buffer , ULONG Length , PLARGE_INTEGER StartingOffset ,
                                   PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 378
  customIrp = 1;
#line 380
  switch (__BLAST_NONDET) {
  case 0: 
#line 381
  tmp = malloc((int )sizeof(IRP ));
#line 381
  return ((struct _IRP *)((void *)tmp));
  default: ;
#line 382
  return ((struct _IRP *)((void *)0));
  }
}
}
#line 397
 __attribute__((__dllimport__)) PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
                                                                   PDEVICE_OBJECT DeviceObject ,
                                                                   PVOID InputBuffer ,
                                                                   ULONG InputBufferLength ,
                                                                   PVOID OutputBuffer ,
                                                                   ULONG OutputBufferLength ,
                                                                   BOOLEAN InternalDeviceIoControl ,
                                                                   PKEVENT Event ,
                                                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 397 "../slam-kernel.c"
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode , PDEVICE_OBJECT DeviceObject ,
                                   PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                   ULONG OutputBufferLength , BOOLEAN InternalDeviceIoControl ,
                                   PKEVENT Event , PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 412
  customIrp = 1;
#line 414
  switch (__BLAST_NONDET) {
  case 0: 
#line 415
  tmp = malloc((int )sizeof(IRP ));
#line 415
  return ((struct _IRP *)((void *)tmp));
  default: ;
#line 416
  return ((struct _IRP *)((void *)0));
  }
}
}
#line 420
 __attribute__((__dllimport__)) NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
                                                        ULONG DeviceExtensionSize ,
                                                        PUNICODE_STRING DeviceName ,
                                                        ULONG DeviceType , ULONG DeviceCharacteristics ,
                                                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) ;
#line 420 "../slam-kernel.c"
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject , ULONG DeviceExtensionSize ,
                        PUNICODE_STRING DeviceName , ULONG DeviceType , ULONG DeviceCharacteristics ,
                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 433
  switch (__BLAST_NONDET) {
  case 0: 
#line 434
  tmp = malloc((int )sizeof(DEVICE_OBJECT ));
#line 434
  *DeviceObject = (struct _DEVICE_OBJECT *)((void *)tmp);
#line 435
  return (0L);
  default: ;
#line 441
  return (-1073741823L);
  }
}
}
#line 446
 __attribute__((__dllimport__)) NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName ,
                                                              PUNICODE_STRING DeviceName ) ;
#line 446 "../slam-kernel.c"
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) 
{ int __BLAST_NONDET ;

  {
#line 454
  switch (__BLAST_NONDET) {
  case 0: ;
#line 455
  return (0L);
  default: ;
#line 456
  return (-1073741823L);
  }
}
}
#line 460
 __attribute__((__dllimport__)) void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
#line 460 "../slam-kernel.c"
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) 
{ 

  {
#line 462
  // // return;
}
}
#line 469
 __attribute__((__dllimport__)) NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) ;
#line 469 "../slam-kernel.c"
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET ;

  {
#line 476
  switch (__BLAST_NONDET) {
  case 0: ;
#line 477
  return (0L);
  default: ;
#line 478
  return (-1073741823L);
  }
}
}
#line 482
 __attribute__((__dllimport__)) void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
#line 482 "../slam-kernel.c"
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) 
{ 

  {
#line 484
  // // return;
}
}
#line 491
 __attribute__((__dllimport__)) void IoFreeIrp(PIRP Irp ) ;
#line 491 "../slam-kernel.c"
void IoFreeIrp(PIRP Irp ) 
{ 

  {
#line 493
  // // return;
}
}
#line 500
 __attribute__((__dllimport__)) void IoFreeMdl(PMDL Mdl ) ;
#line 500 "../slam-kernel.c"
void IoFreeMdl(PMDL Mdl ) 
{ 

  {
#line 502
  // // return;
}
}
#line 509
 __attribute__((__dllimport__)) PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) ;
#line 509 "../slam-kernel.c"
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) 
{ char *tmp ;

  {
#line 514
  tmp = malloc((int )sizeof(CONFIGURATION_INFORMATION ));
#line 514
  return ((struct _CONFIGURATION_INFORMATION *)((void *)tmp));
}
}
#line 517
 __attribute__((__dllimport__)) NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType ,
                                                                  PULONG BusNumber ,
                                                                  PCONFIGURATION_TYPE ControllerType ,
                                                                  PULONG ControllerNumber ,
                                                                  PCONFIGURATION_TYPE PeripheralType ,
                                                                  PULONG PeripheralNumber ,
                                                                  NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                             PUNICODE_STRING PathName ,
                                                                                             INTERFACE_TYPE BusType ,
                                                                                             ULONG BusNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                             CONFIGURATION_TYPE ControllerType ,
                                                                                             ULONG ControllerNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                             CONFIGURATION_TYPE PeripheralType ,
                                                                                             ULONG PeripheralNumber ,
                                                                                             PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                                                  PVOID Context ) ;
#line 517 "../slam-kernel.c"
NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType , PULONG BusNumber , PCONFIGURATION_TYPE ControllerType ,
                                  PULONG ControllerNumber , PCONFIGURATION_TYPE PeripheralType ,
                                  PULONG PeripheralNumber , NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                       PUNICODE_STRING PathName ,
                                                                                       INTERFACE_TYPE BusType ,
                                                                                       ULONG BusNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                       CONFIGURATION_TYPE ControllerType ,
                                                                                       ULONG ControllerNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                       CONFIGURATION_TYPE PeripheralType ,
                                                                                       ULONG PeripheralNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                  PVOID Context ) 
{ int __BLAST_NONDET ;

  {
#line 531
  switch (__BLAST_NONDET) {
  case 0: ;
#line 532
  return (0L);
  default: ;
#line 533
  return (-1073741823L);
  }
}
}
#line 537
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) IoRegisterDeviceInterface)(PDEVICE_OBJECT PhysicalDeviceObject ,
                                                                                                   GUID const   *InterfaceClassGuid ,
                                                                                                   PUNICODE_STRING ReferenceString ,
                                                                                                   PUNICODE_STRING SymbolicLinkName ) ;
#line 537 "../slam-kernel.c"
NTSTATUS ( __attribute__((__stdcall__)) IoRegisterDeviceInterface)(PDEVICE_OBJECT PhysicalDeviceObject ,
                                                                   GUID const   *InterfaceClassGuid ,
                                                                   PUNICODE_STRING ReferenceString ,
                                                                   PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET ;

  {
#line 548
  switch (__BLAST_NONDET) {
  case 0: ;
#line 549
  return (0L);
  default: ;
#line 550
  return (-1073741808L);
  }
}
}
#line 554
 __attribute__((__dllimport__)) void IoReleaseCancelSpinLock(KIRQL Irql ) ;
#line 554 "../slam-kernel.c"
void IoReleaseCancelSpinLock(KIRQL Irql ) 
{ 

  {
#line 556
  // // return;
}
}
#line 563
 __attribute__((__dllimport__)) NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName ,
                                                                   BOOLEAN Enable ) ;
#line 563 "../slam-kernel.c"
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable ) 
{ int __BLAST_NONDET ;

  {
#line 571
  switch (__BLAST_NONDET) {
  case 0: ;
#line 572
  return (0L);
  default: ;
#line 577
  return (-1073741823L);
  }
}
}
#line 582
 __attribute__((__dllimport__)) void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) ;
#line 582 "../slam-kernel.c"
void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) 
{ 

  {
#line 585
  // // return;
}
}
#line 595 "../slam-kernel.c"
void stubMoreProcessingRequired(void) 
{ 

  {
#line 598
  if (s == NP) {
#line 598
    s = MPR1;
  } else {
#line 599
    assert(0);;
  }
#line 600
  // // return;
}
}
#line 602
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__fastcall__)) IofCallDriver)(PDEVICE_OBJECT DeviceObject ,
                                                                                        PIRP Irp ) ;
#line 602 "../slam-kernel.c"
NTSTATUS ( __attribute__((__fastcall__)) IofCallDriver)(PDEVICE_OBJECT DeviceObject ,
                                                        PIRP Irp ) 
{ int __BLAST_NONDET ;
  NTSTATUS returnVal2 ;
  int compRetStatus1 ;
  PVOID lcontext ;
  NTSTATUS tmp ;

  {
#line 615
  if (compRegistered) {
#line 619
    tmp = FloppyPnpComplete(DeviceObject, Irp, lcontext);
#line 619
    compRetStatus1 = (int )tmp;
#line 621
    if ((long )compRetStatus1 == -1073741802L) {
#line 617
      stubMoreProcessingRequired();
    }
  }
#line 622
  switch (__BLAST_NONDET) {
  case 0: 
#line 623
  returnVal2 = 0L;
#line 623
  break;
  case 1: 
#line 625
  returnVal2 = -1073741823L;
#line 625
  break;
  default: 
#line 627
  returnVal2 = 259L;
#line 627
  break;
  }
#line 629
  if (s == NP) {
#line 630
    s = IPC;
#line 630
    lowerDriverReturn = (int )returnVal2;
  } else {
#line 632
    if (s == MPR1) {
#line 633
      if (returnVal2 == 259L) {
#line 634
        s = MPR3;
#line 634
        lowerDriverReturn = (int )returnVal2;
      } else {
#line 636
        s = NP;
#line 636
        lowerDriverReturn = (int )returnVal2;
      }
    } else {
#line 639
      if (s == SKIP1) {
#line 639
        s = SKIP2;
#line 639
        lowerDriverReturn = (int )returnVal2;
      } else {
#line 640
        assert(0);;
      }
    }
  }
#line 643
  return (returnVal2);
}
}
#line 665
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) IofCompleteRequest)(PIRP Irp ,
                                                                                         CCHAR PriorityBoost ) ;
#line 665 "../slam-kernel.c"
void ( __attribute__((__fastcall__)) IofCompleteRequest)(PIRP Irp , CCHAR PriorityBoost ) 
{ 

  {
#line 673
  if (s == NP) {
#line 673
    s = DC;
  } else {
#line 674
    assert(0);
  }
#line 675
  // return;
}
}
#line 677
 __attribute__((__dllimport__)) KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) ;
#line 677 "../slam-kernel.c"
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) 
{ 

  {
#line 679
  return ((unsigned char)0);
}
}
#line 686
 __attribute__((__dllimport__)) NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
                                                                BOOLEAN Alertable ,
                                                                PLARGE_INTEGER Interval ) ;
#line 686 "../slam-kernel.c"
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Interval ) 
{ int __BLAST_NONDET ;

  {
#line 695
  switch (__BLAST_NONDET) {
  case 0: ;
#line 696
  return (0L);
  default: ;
#line 701
  return (-1073741823L);
  }
}
}
#line 706
 __attribute__((__dllimport__)) void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
                                                       BOOLEAN State ) ;
#line 706 "../slam-kernel.c"
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type , BOOLEAN State ) 
{ 

  {
#line 709
  //// return;
}
}
#line 717
 __attribute__((__dllimport__)) void KeInitializeSemaphore(PRKSEMAPHORE Semaphore ,
                                                           LONG Count , LONG Limit ) ;
#line 717 "../slam-kernel.c"
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) 
{ 

  {
#line 720
  // // return;
}
}
#line 728
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) KeInitializeSpinLock)(PKSPIN_LOCK SpinLock ) ;
#line 728 "../slam-kernel.c"
void ( __attribute__((__stdcall__)) KeInitializeSpinLock)(PKSPIN_LOCK SpinLock ) 
{ 

  {
#line 730
  // // return;
}
}
#line 738
 __attribute__((__dllimport__)) LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment ,
                                                        LONG Adjustment , BOOLEAN Wait ) ;
#line 738 "../slam-kernel.c"
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment , LONG Adjustment ,
                        BOOLEAN Wait ) 
{ LONG r ;

  {
#line 748
  return (r);
}
}
#line 751
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) KfReleaseSpinLock)(PKSPIN_LOCK SpinLock ,
                                                                                        KIRQL NewIrql ) ;
#line 751 "../slam-kernel.c"
void ( __attribute__((__fastcall__)) KfReleaseSpinLock)(PKSPIN_LOCK SpinLock , KIRQL NewIrql ) 
{ 

  {
#line 754
  //// return;
}
}
#line 762
 __attribute__((__dllimport__)) LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
                                                BOOLEAN Wait ) ;
#line 762 "../slam-kernel.c"
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait ) 
{ LONG l ;

  {
#line 772
  setEventCalled = 1;
#line 774
  return (l);
}
}
#line 777
 __attribute__((__dllimport__)) NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason ,
                                                               KPROCESSOR_MODE WaitMode ,
                                                               BOOLEAN Alertable ,
                                                               PLARGE_INTEGER Timeout ) ;
#line 777 "../slam-kernel.c"
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason , KPROCESSOR_MODE WaitMode ,
                               BOOLEAN Alertable , PLARGE_INTEGER Timeout ) 
{ int __BLAST_NONDET ;

  {
#line 788
  if (s == MPR3) {
#line 788
    if (setEventCalled == 1) {
#line 789
      s = NP;
#line 789
      setEventCalled = 0;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 791
    if (customIrp == 1) {
#line 792
      s = NP;
#line 792
      customIrp = 0;
    } else {
#line 794
      if (s == MPR3) {
#line 794
         assert(0);
      }
    }
  }
#line 798
  switch (__BLAST_NONDET) {
  case 0: ;
#line 799
  return (0L);
  default: ;
#line 805
  return (-1073741823L);
  }
}
}
#line 810
 __attribute__((__dllimport__)) PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
                                                                 PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
#line 810 "../slam-kernel.c"
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes , PHYSICAL_ADDRESS HighestAcceptableAddress ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 817
  switch (__BLAST_NONDET) {
  case 0: 
#line 818
  tmp = malloc((int )NumberOfBytes);
#line 818
  return ((void *)tmp);
  case 1: ;
#line 819
  return ((void *)0);
  }
#line 821
  return ((void *)0);
}
}
#line 823
 __attribute__((__dllimport__)) void MmFreeContiguousMemory(PVOID BaseAddress ) ;
#line 823 "../slam-kernel.c"
void MmFreeContiguousMemory(PVOID BaseAddress ) 
{ 

  {
#line 825
  //// return;
}
}
#line 832
 __attribute__((__dllimport__)) PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList ,
                                                                   KPROCESSOR_MODE AccessMode ,
                                                                   MEMORY_CACHING_TYPE CacheType ,
                                                                   PVOID BaseAddress ,
                                                                   ULONG BugCheckOnFailure ,
                                                                   MM_PAGE_PRIORITY Priority ) ;
#line 832 "../slam-kernel.c"
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                   MEMORY_CACHING_TYPE CacheType , PVOID BaseAddress ,
                                   ULONG BugCheckOnFailure , MM_PAGE_PRIORITY Priority ) 
{ 

  {
#line 843
  return ((void *)0);
}
}
#line 846
 __attribute__((__dllimport__)) PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
#line 846 "../slam-kernel.c"
PVOID MmPageEntireDriver(PVOID AddressWithinSection ) 
{ 

  {
#line 852
  return ((void *)0);
}
}
#line 855
 __attribute__((__dllimport__)) void MmResetDriverPaging(PVOID AddressWithinSection ) ;
#line 855 "../slam-kernel.c"
void MmResetDriverPaging(PVOID AddressWithinSection ) 
{ 

  {
#line 857
  //// return;
}
}
#line 865
 __attribute__((__dllimport__)) void MmUnlockPages(PMDL MemoryDescriptorList ) ;
#line 865 "../slam-kernel.c"
void MmUnlockPages(PMDL MemoryDescriptorList ) 
{ 

  {
#line 867
  //// return;
}
}
#line 874
 __attribute__((__dllimport__)) NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
                                                                   ACCESS_MASK DesiredAccess ,
                                                                   POBJECT_TYPE ObjectType ,
                                                                   KPROCESSOR_MODE AccessMode ,
                                                                   PVOID *Object ,
                                                                   POBJECT_HANDLE_INFORMATION HandleInformation ) ;
#line 874 "../slam-kernel.c"
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle , ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType ,
                                   KPROCESSOR_MODE AccessMode , PVOID *Object , POBJECT_HANDLE_INFORMATION HandleInformation ) 
{ int __BLAST_NONDET ;

  {
#line 886
  switch (__BLAST_NONDET) {
  case 0: ;
#line 887
  return (0L);
  default: ;
#line 893
  return (-1073741823L);
  }
}
}
#line 899
 __attribute__((__dllimport__)) void ( __attribute__((__fastcall__)) ObfDereferenceObject)(PVOID Object ) ;
#line 899 "../slam-kernel.c"
void ( __attribute__((__fastcall__)) ObfDereferenceObject)(PVOID Object ) 
{ 

  {
#line 901
  //// return;
}
}
#line 909
 __attribute__((__dllimport__)) NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject ,
                                                      PIRP Irp ) ;
#line 909 "../slam-kernel.c"
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET ;
  int compRetStatus ;
  NTSTATUS returnVal ;
  PVOID lcontext ;
  NTSTATUS tmp ;

  {
#line 922
  if (compRegistered) {
#line 926
    tmp = FloppyPnpComplete(DeviceObject, Irp, lcontext);
#line 926
    compRetStatus = (int )tmp;
#line 927
    if ((long )compRetStatus == -1073741802L) {
#line 924
      stubMoreProcessingRequired();
    }
  }
#line 929
  switch (__BLAST_NONDET) {
  case 0: 
#line 931
  returnVal = 0L;
#line 932
  break;
  case 1: 
#line 934
  returnVal = -1073741823L;
#line 935
  break;
  default: 
#line 937
  returnVal = 259L;
#line 937
  break;
  }
#line 939
  if (s == NP) {
#line 940
    s = IPC;
#line 940
    lowerDriverReturn = (int )returnVal;
  } else {
#line 942
    if (s == MPR1) {
#line 943
      if (returnVal == 259L) {
#line 944
        s = MPR3;
#line 944
        lowerDriverReturn = (int )returnVal;
      } else {
#line 946
        s = NP;
#line 946
        lowerDriverReturn = (int )returnVal;
      }
    } else {
#line 949
      if (s == SKIP1) {
#line 949
        s = SKIP2;
#line 949
        lowerDriverReturn = (int )returnVal;
      } else {
#line 950
         //assert(0);  // bug in FF
      }
    }
  }
#line 953
  return (returnVal);
}
}
#line 956
 __attribute__((__dllimport__)) void PoStartNextPowerIrp(PIRP Irp ) ;
#line 956 "../slam-kernel.c"
void PoStartNextPowerIrp(PIRP Irp ) 
{ 

  {
#line 958
  //// return;
}
}
#line 965
 __attribute__((__dllimport__)) NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle ,
                                                              ULONG DesiredAccess ,
                                                              POBJECT_ATTRIBUTES ObjectAttributes ,
                                                              HANDLE ProcessHandle ,
                                                              PCLIENT_ID ClientId ,
                                                              void (*StartRoutine)(PVOID StartContext ) ,
                                                              PVOID StartContext ) ;
#line 965 "../slam-kernel.c"
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
                              HANDLE ProcessHandle , PCLIENT_ID ClientId , void (*StartRoutine)(PVOID StartContext ) ,
                              PVOID StartContext ) 
{ int __BLAST_NONDET ;

  {
#line 978
  switch (__BLAST_NONDET) {
  case 0: ;
#line 979
  return (0L);
  default: ;
#line 980
  return (-1073741823L);
  }
}
}
#line 984
 __attribute__((__dllimport__)) NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;
#line 984 "../slam-kernel.c"
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) 
{ int __BLAST_NONDET ;

  {
#line 991
  switch (__BLAST_NONDET) {
  case 0: ;
#line 992
  return (0L);
  default: ;
#line 993
  return (-1073741823L);
  }
}
}
#line 998
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) RtlAnsiStringToUnicodeString)(PUNICODE_STRING DestinationString ,
                                                                                                      PANSI_STRING SourceString ,
                                                                                                      BOOLEAN AllocateDestinationString ) ;
#line 998 "../slam-kernel.c"
NTSTATUS ( __attribute__((__stdcall__)) RtlAnsiStringToUnicodeString)(PUNICODE_STRING DestinationString ,
                                                                      PANSI_STRING SourceString ,
                                                                      BOOLEAN AllocateDestinationString ) 
{ int __BLAST_NONDET ;

  {
#line 1008
  switch (__BLAST_NONDET) {
  case 0: ;
#line 1009
  return (0L);
  default: ;
#line 1010
  return (-1073741823L);
  }
}
}
#line 1014
 __attribute__((__dllimport__)) SIZE_T ( __attribute__((__stdcall__)) RtlCompareMemory)(void const   *Source1 ,
                                                                                        void const   *Source2 ,
                                                                                        SIZE_T Length ) ;
#line 1014 "../slam-kernel.c"
SIZE_T ( __attribute__((__stdcall__)) RtlCompareMemory)(void const   *Source1 , void const   *Source2 ,
                                                        SIZE_T Length ) 
{ SIZE_T r ;

  {
#line 1024
  return (r);
}
}
#line 1027
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) RtlCopyUnicodeString)(PUNICODE_STRING DestinationString ,
                                                                                          PUNICODE_STRING SourceString ) ;
#line 1027 "../slam-kernel.c"
void ( __attribute__((__stdcall__)) RtlCopyUnicodeString)(PUNICODE_STRING DestinationString ,
                                                          PUNICODE_STRING SourceString ) 
{ 

  {
#line 1030
  // return;
}
}
#line 1038
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) RtlDeleteRegistryValue)(ULONG RelativeTo ,
                                                                                                PCWSTR Path ,
                                                                                                PCWSTR ValueName ) ;
#line 1038 "../slam-kernel.c"
NTSTATUS ( __attribute__((__stdcall__)) RtlDeleteRegistryValue)(ULONG RelativeTo ,
                                                                PCWSTR Path , PCWSTR ValueName ) 
{ int __BLAST_NONDET ;

  {
#line 1048
  switch (__BLAST_NONDET) {
  case 0: ;
#line 1049
  return (0L);
  default: ;
#line 1050
  return (-1073741823L);
  }
}
}
#line 1054
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) RtlFreeUnicodeString)(PUNICODE_STRING UnicodeString ) ;
#line 1054 "../slam-kernel.c"
void ( __attribute__((__stdcall__)) RtlFreeUnicodeString)(PUNICODE_STRING UnicodeString ) 
{ 

  {
#line 1057
  // return;
}
}
#line 1064
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) RtlInitString)(PSTRING DestinationString ,
                                                                                   PCSZ SourceString ) ;
#line 1064 "../slam-kernel.c"
void ( __attribute__((__stdcall__)) RtlInitString)(PSTRING DestinationString , PCSZ SourceString ) 
{ 

  {
#line 1067
  // return;
}
}
#line 1075
 __attribute__((__dllimport__)) void ( __attribute__((__stdcall__)) RtlInitUnicodeString)(PUNICODE_STRING DestinationString ,
                                                                                          PCWSTR SourceString ) ;
#line 1075 "../slam-kernel.c"
void ( __attribute__((__stdcall__)) RtlInitUnicodeString)(PUNICODE_STRING DestinationString ,
                                                          PCWSTR SourceString ) 
{ 

  {
#line 1078
  // return;
}
}
#line 1087
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) RtlQueryRegistryValues)(ULONG RelativeTo ,
                                                                                                PCWSTR Path ,
                                                                                                PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                                                                                PVOID Context ,
                                                                                                PVOID Environment ) ;
#line 1087 "../slam-kernel.c"
NTSTATUS ( __attribute__((__stdcall__)) RtlQueryRegistryValues)(ULONG RelativeTo ,
                                                                PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                                                PVOID Context , PVOID Environment ) 
{ int __BLAST_NONDET ;

  {
#line 1099
  switch (__BLAST_NONDET) {
  case 0: ;
#line 1100
  return (0L);
  default: ;
#line 1105
  return (-1073741823L);
  }
}
}
#line 1109
 __attribute__((__dllimport__)) NTSTATUS ( __attribute__((__stdcall__)) ZwClose)(HANDLE Handle ) ;
#line 1109 "../slam-kernel.c"
NTSTATUS ( __attribute__((__stdcall__)) ZwClose)(HANDLE Handle ) 
{ int __BLAST_NONDET ;

  {
#line 1117
  switch (__BLAST_NONDET) {
  case 0: ;
#line 1118
  return (0L);
  default: ;
#line 1124
  return (-1073741823L);
  }
}
}
