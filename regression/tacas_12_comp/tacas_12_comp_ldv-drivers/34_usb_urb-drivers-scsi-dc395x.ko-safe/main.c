/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 19 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 43 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 46 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 48 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 49 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 11 "include/asm-generic/types.h"
typedef unsigned short umode_t;
#line 11 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_mode_t;
#line 13 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_off_t;
#line 14 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_pid_t;
#line 16 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_uid_t;
#line 17 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_gid_t;
#line 18 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_size_t;
#line 19 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_ssize_t;
#line 21 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_time_t;
#line 23 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_clock_t;
#line 24 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_timer_t;
#line 25 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_clockid_t;
#line 32 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef long long __kernel_loff_t;
#line 41 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_uid_t __kernel_uid32_t;
#line 42 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_gid_t __kernel_gid32_t;
#line 21 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 24 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 26 "include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 28 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 29 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 34 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 37 "include/linux/types.h"
typedef _Bool bool;
#line 39 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 40 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 53 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 62 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 67 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 77 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 110 "include/linux/types.h"
typedef __s32 int32_t;
#line 116 "include/linux/types.h"
typedef __u32 uint32_t;
#line 141 "include/linux/types.h"
typedef unsigned long sector_t;
#line 142 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 154 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 177 "include/linux/types.h"
typedef __u16 __le16;
#line 201 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 202 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 205 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 210 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 212 "include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int counter ;
};
#line 212 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
#line 217 "include/linux/types.h"
struct __anonstruct_atomic64_t_8 {
   long counter ;
};
#line 217 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
#line 222 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 226
struct hlist_node;
#line 226
struct hlist_node;
#line 226
struct hlist_node;
#line 226 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 230 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 59 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/alternative.h"
struct module;
#line 59
struct module;
#line 59
struct module;
#line 59
struct module;
#line 145 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 10 "include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 113 "include/linux/kernel.h"
struct completion;
#line 113
struct completion;
#line 113
struct completion;
#line 113
struct completion;
#line 114
struct pt_regs;
#line 114
struct pt_regs;
#line 114
struct pt_regs;
#line 114
struct pt_regs;
#line 322
struct pid;
#line 322
struct pid;
#line 322
struct pid;
#line 322
struct pid;
#line 12 "include/linux/thread_info.h"
struct timespec;
#line 12
struct timespec;
#line 12
struct timespec;
#line 12
struct timespec;
#line 18 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/page.h"
struct page;
#line 18
struct page;
#line 18
struct page;
#line 18
struct page;
#line 20 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/thread_info.h"
struct task_struct;
#line 20
struct task_struct;
#line 20
struct task_struct;
#line 20
struct task_struct;
#line 7 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct task_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 99 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 136
struct task_struct;
#line 141 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 11 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/math_emu.h"
union __anonunion____missing_field_name_14 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 11 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_14 __annonCompField5 ;
};
#line 8 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/current.h"
struct task_struct;
#line 10 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 11 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pmdval_t;
#line 12 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pudval_t;
#line 13 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 16 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_16 {
   pteval_t pte ;
};
#line 16 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_16 pte_t;
#line 190 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 190 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 192 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_17 {
   pgdval_t pgd ;
};
#line 192 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_17 pgd_t;
#line 210 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pud_t_18 {
   pudval_t pud ;
};
#line 210 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pud_t_18 pud_t;
#line 231 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pmd_t_19 {
   pmdval_t pmd ;
};
#line 231 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pmd_t_19 pmd_t;
#line 280 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 293
struct file;
#line 293
struct file;
#line 293
struct file;
#line 293
struct file;
#line 311
struct seq_file;
#line 311
struct seq_file;
#line 311
struct seq_file;
#line 311
struct seq_file;
#line 22 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_22 {
   unsigned int a ;
   unsigned int b ;
};
#line 22 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_23 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
#line 22 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/desc_defs.h"
union __anonunion____missing_field_name_21 {
   struct __anonstruct____missing_field_name_22 __annonCompField7 ;
   struct __anonstruct____missing_field_name_23 __annonCompField8 ;
};
#line 22 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   union __anonunion____missing_field_name_21 __annonCompField9 ;
} __attribute__((__packed__)) ;
#line 51 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned int ist : 3 ;
   unsigned int zero0 : 5 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
#line 81 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/desc_defs.h"
typedef struct gate_struct64 gate_desc;
#line 94 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
} __attribute__((__packed__)) ;
#line 45 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct page;
#line 46
struct thread_struct;
#line 46
struct thread_struct;
#line 46
struct thread_struct;
#line 46
struct thread_struct;
#line 47
struct desc_ptr;
#line 48
struct tss_struct;
#line 48
struct tss_struct;
#line 48
struct tss_struct;
#line 48
struct tss_struct;
#line 49
struct mm_struct;
#line 50
struct desc_struct;
#line 51
struct task_struct;
#line 52
struct cpumask;
#line 52
struct cpumask;
#line 52
struct cpumask;
#line 52
struct cpumask;
#line 58 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 70 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct pv_init_ops {
   unsigned int (*patch)(u8 type , u16 clobber , void *insnbuf , unsigned long addr ,
                         unsigned int len ) ;
};
#line 84 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct pv_lazy_ops {
   void (*enter)(void) ;
   void (*leave)(void) ;
};
#line 90 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct pv_time_ops {
   unsigned long long (*sched_clock)(void) ;
   unsigned long (*get_tsc_khz)(void) ;
};
#line 95 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct pv_cpu_ops {
   unsigned long (*get_debugreg)(int regno ) ;
   void (*set_debugreg)(int regno , unsigned long value ) ;
   void (*clts)(void) ;
   unsigned long (*read_cr0)(void) ;
   void (*write_cr0)(unsigned long  ) ;
   unsigned long (*read_cr4_safe)(void) ;
   unsigned long (*read_cr4)(void) ;
   void (*write_cr4)(unsigned long  ) ;
   unsigned long (*read_cr8)(void) ;
   void (*write_cr8)(unsigned long  ) ;
   void (*load_tr_desc)(void) ;
   void (*load_gdt)(struct desc_ptr  const  * ) ;
   void (*load_idt)(struct desc_ptr  const  * ) ;
   void (*store_gdt)(struct desc_ptr * ) ;
   void (*store_idt)(struct desc_ptr * ) ;
   void (*set_ldt)(void const   *desc , unsigned int entries ) ;
   unsigned long (*store_tr)(void) ;
   void (*load_tls)(struct thread_struct *t , unsigned int cpu ) ;
   void (*load_gs_index)(unsigned int idx ) ;
   void (*write_ldt_entry)(struct desc_struct *ldt , int entrynum , void const   *desc ) ;
   void (*write_gdt_entry)(struct desc_struct * , int entrynum , void const   *desc ,
                           int size ) ;
   void (*write_idt_entry)(gate_desc * , int entrynum , gate_desc const   *gate ) ;
   void (*alloc_ldt)(struct desc_struct *ldt , unsigned int entries ) ;
   void (*free_ldt)(struct desc_struct *ldt , unsigned int entries ) ;
   void (*load_sp0)(struct tss_struct *tss , struct thread_struct *t ) ;
   void (*set_iopl_mask)(unsigned int mask ) ;
   void (*wbinvd)(void) ;
   void (*io_delay)(void) ;
   void (*cpuid)(unsigned int *eax , unsigned int *ebx , unsigned int *ecx , unsigned int *edx ) ;
   u64 (*read_msr)(unsigned int msr , int *err ) ;
   int (*rdmsr_regs)(u32 *regs ) ;
   int (*write_msr)(unsigned int msr , unsigned int low , unsigned int high ) ;
   int (*wrmsr_regs)(u32 *regs ) ;
   u64 (*read_tsc)(void) ;
   u64 (*read_pmc)(int counter ) ;
   unsigned long long (*read_tscp)(unsigned int *aux ) ;
   void (*irq_enable_sysexit)(void) ;
   void (*usergs_sysret64)(void) ;
   void (*usergs_sysret32)(void) ;
   void (*iret)(void) ;
   void (*swapgs)(void) ;
   void (*start_context_switch)(struct task_struct *prev ) ;
   void (*end_context_switch)(struct task_struct *next ) ;
};
#line 191 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 214 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct pv_apic_ops {
   void (*startup_ipi_hook)(int phys_apicid , unsigned long start_eip , unsigned long start_esp ) ;
};
#line 222 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct pv_mmu_ops {
   unsigned long (*read_cr2)(void) ;
   void (*write_cr2)(unsigned long  ) ;
   unsigned long (*read_cr3)(void) ;
   void (*write_cr3)(unsigned long  ) ;
   void (*activate_mm)(struct mm_struct *prev , struct mm_struct *next ) ;
   void (*dup_mmap)(struct mm_struct *oldmm , struct mm_struct *mm ) ;
   void (*exit_mmap)(struct mm_struct *mm ) ;
   void (*flush_tlb_user)(void) ;
   void (*flush_tlb_kernel)(void) ;
   void (*flush_tlb_single)(unsigned long addr ) ;
   void (*flush_tlb_others)(struct cpumask  const  *cpus , struct mm_struct *mm ,
                            unsigned long va ) ;
   int (*pgd_alloc)(struct mm_struct *mm ) ;
   void (*pgd_free)(struct mm_struct *mm , pgd_t *pgd ) ;
   void (*alloc_pte)(struct mm_struct *mm , unsigned long pfn ) ;
   void (*alloc_pmd)(struct mm_struct *mm , unsigned long pfn ) ;
   void (*alloc_pud)(struct mm_struct *mm , unsigned long pfn ) ;
   void (*release_pte)(unsigned long pfn ) ;
   void (*release_pmd)(unsigned long pfn ) ;
   void (*release_pud)(unsigned long pfn ) ;
   void (*set_pte)(pte_t *ptep , pte_t pteval ) ;
   void (*set_pte_at)(struct mm_struct *mm , unsigned long addr , pte_t *ptep , pte_t pteval ) ;
   void (*set_pmd)(pmd_t *pmdp , pmd_t pmdval ) ;
   void (*set_pmd_at)(struct mm_struct *mm , unsigned long addr , pmd_t *pmdp , pmd_t pmdval ) ;
   void (*pte_update)(struct mm_struct *mm , unsigned long addr , pte_t *ptep ) ;
   void (*pte_update_defer)(struct mm_struct *mm , unsigned long addr , pte_t *ptep ) ;
   void (*pmd_update)(struct mm_struct *mm , unsigned long addr , pmd_t *pmdp ) ;
   void (*pmd_update_defer)(struct mm_struct *mm , unsigned long addr , pmd_t *pmdp ) ;
   pte_t (*ptep_modify_prot_start)(struct mm_struct *mm , unsigned long addr , pte_t *ptep ) ;
   void (*ptep_modify_prot_commit)(struct mm_struct *mm , unsigned long addr , pte_t *ptep ,
                                   pte_t pte ) ;
   struct paravirt_callee_save pte_val ;
   struct paravirt_callee_save make_pte ;
   struct paravirt_callee_save pgd_val ;
   struct paravirt_callee_save make_pgd ;
   void (*set_pud)(pud_t *pudp , pud_t pudval ) ;
   struct paravirt_callee_save pmd_val ;
   struct paravirt_callee_save make_pmd ;
   struct paravirt_callee_save pud_val ;
   struct paravirt_callee_save make_pud ;
   void (*set_pgd)(pgd_t *pudp , pgd_t pgdval ) ;
   struct pv_lazy_ops lazy_mode ;
   void (*set_fixmap)(unsigned int idx , phys_addr_t phys , pgprot_t flags ) ;
};
#line 322
struct arch_spinlock;
#line 322
struct arch_spinlock;
#line 322
struct arch_spinlock;
#line 322
struct arch_spinlock;
#line 323 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct pv_lock_ops {
   int (*spin_is_locked)(struct arch_spinlock *lock ) ;
   int (*spin_is_contended)(struct arch_spinlock *lock ) ;
   void (*spin_lock)(struct arch_spinlock *lock ) ;
   void (*spin_lock_flags)(struct arch_spinlock *lock , unsigned long flags ) ;
   int (*spin_trylock)(struct arch_spinlock *lock ) ;
   void (*spin_unlock)(struct arch_spinlock *lock ) ;
};
#line 335 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
struct paravirt_patch_template {
   struct pv_init_ops pv_init_ops ;
   struct pv_time_ops pv_time_ops ;
   struct pv_cpu_ops pv_cpu_ops ;
   struct pv_irq_ops pv_irq_ops ;
   struct pv_apic_ops pv_apic_ops ;
   struct pv_mmu_ops pv_mmu_ops ;
   struct pv_lock_ops pv_lock_ops ;
};
#line 13 "include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((4096UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 13 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 622 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 20 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/system.h"
struct task_struct;
#line 23
struct tss_struct;
#line 11 "include/linux/personality.h"
struct pt_regs;
#line 224 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   u32 reserved1 ;
   u64 sp0 ;
   u64 sp1 ;
   u64 sp2 ;
   u64 reserved2 ;
   u64 ist[7] ;
   u32 reserved3 ;
   u32 reserved4 ;
   u16 reserved5 ;
   u16 io_bitmap_base ;
} __attribute__((__packed__, __aligned__((1) <<  (6) ))) ;
#line 248 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[8192UL / sizeof(long ) + 1UL] ;
   unsigned long stack[64] ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 280 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
#line 296 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_31 {
   u64 rip ;
   u64 rdp ;
};
#line 296 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_32 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 296 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_30 {
   struct __anonstruct____missing_field_name_31 __annonCompField12 ;
   struct __anonstruct____missing_field_name_32 __annonCompField13 ;
};
#line 296 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_33 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
#line 296 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_30 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_33 __annonCompField15 ;
} __attribute__((__aligned__(16))) ;
#line 331 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 351 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64] ;
};
#line 356 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
#line 362 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
} __attribute__((__packed__, __aligned__(64))) ;
#line 369 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 376 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct fpu {
   union thread_xstate *state ;
};
#line 421
struct kmem_cache;
#line 421
struct kmem_cache;
#line 421
struct kmem_cache;
#line 423
struct perf_event;
#line 423
struct perf_event;
#line 423
struct perf_event;
#line 423
struct perf_event;
#line 425 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 8 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   unsigned int slock ;
};
#line 8 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 14 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/spinlock_types.h"
struct __anonstruct_arch_rwlock_t_36 {
   unsigned int lock ;
};
#line 14 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/spinlock_types.h"
typedef struct __anonstruct_arch_rwlock_t_36 arch_rwlock_t;
#line 12 "include/linux/lockdep.h"
struct task_struct;
#line 13
struct lockdep_map;
#line 13
struct lockdep_map;
#line 13
struct lockdep_map;
#line 13
struct lockdep_map;
#line 8 "include/linux/debug_locks.h"
struct task_struct;
#line 48
struct task_struct;
#line 4 "include/linux/stacktrace.h"
struct task_struct;
#line 5
struct pt_regs;
#line 8
struct task_struct;
#line 10 "include/linux/stacktrace.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 50 "include/linux/lockdep.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 54 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8UL] ;
};
#line 65 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4] ;
   unsigned long contending_point[4] ;
};
#line 150 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 196 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 2 ;
   unsigned int hardirqs_off : 1 ;
   unsigned int references : 11 ;
};
#line 20 "include/linux/spinlock_types.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 20 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 64 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_38 {
   u8 __padding[(unsigned int )(& ((struct raw_spinlock *)0)->dep_map)] ;
   struct lockdep_map dep_map ;
};
#line 64 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_37 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_38 __annonCompField17 ;
};
#line 64 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_37 __annonCompField18 ;
};
#line 64 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 11 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_39 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 11 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_39 rwlock_t;
#line 119 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 119 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 14 "include/linux/time.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 62 "include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 50 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 54 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 56
struct task_struct;
#line 96 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_41 {
   unsigned long bits[(((unsigned long )(1 << 10) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 96 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_41 nodemask_t;
#line 60 "include/linux/pageblock-flags.h"
struct page;
#line 48 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 69 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 20 "include/linux/rwsem.h"
struct rw_semaphore;
#line 20
struct rw_semaphore;
#line 20
struct rw_semaphore;
#line 20
struct rw_semaphore;
#line 26 "include/linux/rwsem.h"
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 8 "include/linux/memory_hotplug.h"
struct page;
#line 18 "include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 26
struct pci_dev;
#line 26
struct pci_dev;
#line 26
struct pci_dev;
#line 177
struct device;
#line 177
struct device;
#line 177
struct device;
#line 177
struct device;
#line 171 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 103 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/mpspec.h"
struct device;
#line 46 "include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 10 "include/linux/timer.h"
struct tvec_base;
#line 10
struct tvec_base;
#line 10
struct tvec_base;
#line 10
struct tvec_base;
#line 12 "include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
   struct lockdep_map lockdep_map ;
};
#line 289
struct hrtimer;
#line 289
struct hrtimer;
#line 289
struct hrtimer;
#line 289
struct hrtimer;
#line 290
enum hrtimer_restart;
#line 290
enum hrtimer_restart;
#line 290
enum hrtimer_restart;
#line 15 "include/linux/workqueue.h"
struct workqueue_struct;
#line 15
struct workqueue_struct;
#line 15
struct workqueue_struct;
#line 15
struct workqueue_struct;
#line 17
struct work_struct;
#line 17
struct work_struct;
#line 17
struct work_struct;
#line 17
struct work_struct;
#line 79 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
   struct lockdep_map lockdep_map ;
};
#line 92 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 102 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 25 "include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 42 "include/linux/pm.h"
struct device;
#line 50 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 50 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 204 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
   int (*runtime_suspend)(struct device *dev ) ;
   int (*runtime_resume)(struct device *dev ) ;
   int (*runtime_idle)(struct device *dev ) ;
};
#line 392
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 414
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 422
struct wakeup_source;
#line 422
struct wakeup_source;
#line 422
struct wakeup_source;
#line 422
struct wakeup_source;
#line 424 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int ignore_children : 1 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int run_wake : 1 ;
   unsigned int runtime_auto : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   void *subsys_data ;
};
#line 475 "include/linux/pm.h"
struct dev_power_domain {
   struct dev_pm_ops ops ;
};
#line 176 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 176
struct pci_bus;
#line 176
struct pci_bus;
#line 176
struct pci_bus;
#line 11 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_111 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 11 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_111 mm_context_t;
#line 68 "include/asm-generic/iomap.h"
struct pci_dev;
#line 8 "include/linux/vmalloc.h"
struct vm_area_struct;
#line 8
struct vm_area_struct;
#line 8
struct vm_area_struct;
#line 8
struct vm_area_struct;
#line 337 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/io.h"
struct bio_vec;
#line 337
struct bio_vec;
#line 337
struct bio_vec;
#line 337
struct bio_vec;
#line 964 "include/linux/mmzone.h"
struct page;
#line 18 "include/linux/smp.h"
struct call_single_data {
   struct list_head list ;
   void (*func)(void *info ) ;
   void *info ;
   u16 flags ;
   u16 priv ;
};
#line 10 "include/linux/gfp.h"
struct vm_area_struct;
#line 29 "include/linux/sysctl.h"
struct completion;
#line 72 "include/linux/rcupdate.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
#line 937 "include/linux/sysctl.h"
struct nsproxy;
#line 937
struct nsproxy;
#line 937
struct nsproxy;
#line 937
struct nsproxy;
#line 48 "include/linux/kmod.h"
struct cred;
#line 48
struct cred;
#line 48
struct cred;
#line 48
struct cred;
#line 49
struct file;
#line 264 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/elf.h"
struct task_struct;
#line 10 "include/linux/elf.h"
struct file;
#line 27 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 28 "include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 32 "include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 33 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 203 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 203 "include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 20 "include/linux/kobject_ns.h"
struct sock;
#line 20
struct sock;
#line 20
struct sock;
#line 20
struct sock;
#line 21
struct kobject;
#line 21
struct kobject;
#line 21
struct kobject;
#line 21
struct kobject;
#line 27
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 40 "include/linux/kobject_ns.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock *sk ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 22 "include/linux/sysfs.h"
struct kobject;
#line 23
struct module;
#line 24
enum kobj_ns_type;
#line 26 "include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   mode_t mode ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 56 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 85
struct file;
#line 86
struct vm_area_struct;
#line 88 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
#line 112 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 117
struct sysfs_dirent;
#line 117
struct sysfs_dirent;
#line 117
struct sysfs_dirent;
#line 117
struct sysfs_dirent;
#line 20 "include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
#line 60 "include/linux/kobject.h"
struct kset;
#line 60
struct kset;
#line 60
struct kset;
#line 60
struct kobj_type;
#line 60
struct kobj_type;
#line 60
struct kobj_type;
#line 60 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 110 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject *kobj ) ;
   void const   *(*namespace)(struct kobject *kobj ) ;
};
#line 118 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
#line 125 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(* const  name)(struct kset *kset , struct kobject *kobj ) ;
   int (* const  uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
#line 142
struct sock;
#line 161 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 34 "include/linux/moduleparam.h"
struct kernel_param;
#line 34
struct kernel_param;
#line 34
struct kernel_param;
#line 34
struct kernel_param;
#line 36 "include/linux/moduleparam.h"
struct kernel_param_ops {
   int (*set)(char const   *val , struct kernel_param  const  *kp ) ;
   int (*get)(char *buffer , struct kernel_param  const  *kp ) ;
   void (*free)(void *arg ) ;
};
#line 48
struct kparam_string;
#line 48
struct kparam_string;
#line 48
struct kparam_string;
#line 48
struct kparam_array;
#line 48
struct kparam_array;
#line 48
struct kparam_array;
#line 48 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_195 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 48 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   u16 flags ;
   union __anonunion____missing_field_name_195 __annonCompField31 ;
};
#line 61 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 67 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 391
struct module;
#line 26 "include/linux/jump_label.h"
struct module;
#line 61 "include/linux/jump_label.h"
struct jump_label_key {
   atomic_t enabled ;
};
#line 22 "include/linux/tracepoint.h"
struct module;
#line 23
struct tracepoint;
#line 23
struct tracepoint;
#line 23
struct tracepoint;
#line 23
struct tracepoint;
#line 25 "include/linux/tracepoint.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 30 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct jump_label_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 8 "include/asm-generic/module.h"
struct mod_arch_specific {

};
#line 21 "include/trace/events/module.h"
struct module;
#line 37 "include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 49
struct module;
#line 51 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 70
struct module_param_attrs;
#line 70
struct module_param_attrs;
#line 70
struct module_param_attrs;
#line 70 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 83
struct exception_table_entry;
#line 83
struct exception_table_entry;
#line 83
struct exception_table_entry;
#line 83
struct exception_table_entry;
#line 265
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 272
struct module_sect_attrs;
#line 272
struct module_sect_attrs;
#line 272
struct module_sect_attrs;
#line 272
struct module_notes_attrs;
#line 272
struct module_notes_attrs;
#line 272
struct module_notes_attrs;
#line 272
struct ftrace_event_call;
#line 272
struct ftrace_event_call;
#line 272
struct ftrace_event_call;
#line 272 "include/linux/module.h"
struct module_ref {
   unsigned int incs ;
   unsigned int decs ;
};
#line 272 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t *ctors ;
   unsigned int num_ctors ;
};
#line 18 "include/linux/capability.h"
struct task_struct;
#line 94 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
#line 94 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 376
struct dentry;
#line 376
struct dentry;
#line 376
struct dentry;
#line 376
struct dentry;
#line 377
struct user_namespace;
#line 377
struct user_namespace;
#line 377
struct user_namespace;
#line 377
struct user_namespace;
#line 100 "include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 110 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 14 "include/linux/prio_tree.h"
struct prio_tree_node;
#line 14
struct prio_tree_node;
#line 14
struct prio_tree_node;
#line 14 "include/linux/prio_tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 20 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 28 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 23 "include/linux/mm_types.h"
struct address_space;
#line 23
struct address_space;
#line 23
struct address_space;
#line 23
struct address_space;
#line 34 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_199 {
   u16 inuse ;
   u16 objects ;
};
#line 34 "include/linux/mm_types.h"
union __anonunion____missing_field_name_198 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_199 __annonCompField32 ;
};
#line 34 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_201 {
   unsigned long private ;
   struct address_space *mapping ;
};
#line 34 "include/linux/mm_types.h"
union __anonunion____missing_field_name_200 {
   struct __anonstruct____missing_field_name_201 __annonCompField34 ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 34 "include/linux/mm_types.h"
union __anonunion____missing_field_name_202 {
   unsigned long index ;
   void *freelist ;
};
#line 34 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_198 __annonCompField33 ;
   union __anonunion____missing_field_name_200 __annonCompField35 ;
   union __anonunion____missing_field_name_202 __annonCompField36 ;
   struct list_head lru ;
};
#line 132 "include/linux/mm_types.h"
struct __anonstruct_vm_set_204 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 132 "include/linux/mm_types.h"
union __anonunion_shared_203 {
   struct __anonstruct_vm_set_204 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 132
struct anon_vma;
#line 132
struct anon_vma;
#line 132
struct anon_vma;
#line 132
struct vm_operations_struct;
#line 132
struct vm_operations_struct;
#line 132
struct vm_operations_struct;
#line 132
struct mempolicy;
#line 132
struct mempolicy;
#line 132
struct mempolicy;
#line 132 "include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_203 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 189 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 194 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 216 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3] ;
};
#line 220
struct linux_binfmt;
#line 220
struct linux_binfmt;
#line 220
struct linux_binfmt;
#line 220
struct mmu_notifier_mm;
#line 220
struct mmu_notifier_mm;
#line 220
struct mmu_notifier_mm;
#line 220 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   atomic_t oom_disable_count ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
};
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 84 "include/linux/sem.h"
struct task_struct;
#line 122
struct sem_undo_list;
#line 122
struct sem_undo_list;
#line 122
struct sem_undo_list;
#line 135 "include/linux/sem.h"
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
#line 141 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 10 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/signal.h"
struct siginfo;
#line 10
struct siginfo;
#line 10
struct siginfo;
#line 10
struct siginfo;
#line 30 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_206 {
   unsigned long sig[1] ;
};
#line 30 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_206 sigset_t;
#line 17 "include/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "include/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "include/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "include/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 167 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 174 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 7 "include/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 7 "include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 40 "include/asm-generic/siginfo.h"
struct __anonstruct__kill_208 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 40 "include/asm-generic/siginfo.h"
struct __anonstruct__timer_209 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 40 "include/asm-generic/siginfo.h"
struct __anonstruct__rt_210 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 40 "include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_211 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 40 "include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_212 {
   void *_addr ;
   short _addr_lsb ;
};
#line 40 "include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_213 {
   long _band ;
   int _fd ;
};
#line 40 "include/asm-generic/siginfo.h"
union __anonunion__sifields_207 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_208 _kill ;
   struct __anonstruct__timer_209 _timer ;
   struct __anonstruct__rt_210 _rt ;
   struct __anonstruct__sigchld_211 _sigchld ;
   struct __anonstruct__sigfault_212 _sigfault ;
   struct __anonstruct__sigpoll_213 _sigpoll ;
};
#line 40 "include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_207 _sifields ;
};
#line 40 "include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 280
struct siginfo;
#line 10 "include/linux/signal.h"
struct task_struct;
#line 18
struct user_struct;
#line 18
struct user_struct;
#line 18
struct user_struct;
#line 28 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 239
struct timespec;
#line 240
struct pt_regs;
#line 6 "include/linux/pid.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 50
struct pid_namespace;
#line 50
struct pid_namespace;
#line 50
struct pid_namespace;
#line 50 "include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 57 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
#line 69 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 100
struct pid_namespace;
#line 18 "include/linux/percpu_counter.h"
struct percpu_counter {
   spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 50 "include/linux/proportions.h"
struct prop_local_percpu {
   struct percpu_counter events ;
   int shift ;
   unsigned long period ;
   spinlock_t lock ;
};
#line 97 "include/linux/proportions.h"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
#line 10 "include/linux/seccomp.h"
struct __anonstruct_seccomp_t_216 {
   int mode ;
};
#line 10 "include/linux/seccomp.h"
typedef struct __anonstruct_seccomp_t_216 seccomp_t;
#line 82 "include/linux/plist.h"
struct plist_head {
   struct list_head node_list ;
   raw_spinlock_t *rawlock ;
   spinlock_t *spinlock ;
};
#line 90 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 40
struct rt_mutex_waiter;
#line 40
struct rt_mutex_waiter;
#line 40
struct rt_mutex_waiter;
#line 42 "include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 81
struct task_struct;
#line 8 "include/linux/timerqueue.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 13 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 27 "include/linux/hrtimer.h"
struct hrtimer_clock_base;
#line 27
struct hrtimer_clock_base;
#line 27
struct hrtimer_clock_base;
#line 27
struct hrtimer_clock_base;
#line 28
struct hrtimer_cpu_base;
#line 28
struct hrtimer_cpu_base;
#line 28
struct hrtimer_cpu_base;
#line 28
struct hrtimer_cpu_base;
#line 44
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 108 "include/linux/hrtimer.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
#line 145 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 178 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned long active_bases ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3] ;
};
#line 11 "include/linux/task_io_accounting.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 18 "include/linux/latencytop.h"
struct latency_record {
   unsigned long backtrace[12] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 26
struct task_struct;
#line 29 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 32 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 34
struct key;
#line 34
struct key;
#line 34
struct key;
#line 74
struct seq_file;
#line 75
struct user_struct;
#line 76
struct signal_struct;
#line 76
struct signal_struct;
#line 76
struct signal_struct;
#line 76
struct signal_struct;
#line 77
struct cred;
#line 79
struct key_type;
#line 79
struct key_type;
#line 79
struct key_type;
#line 79
struct key_type;
#line 81
struct keyring_list;
#line 81
struct keyring_list;
#line 81
struct keyring_list;
#line 81
struct keyring_list;
#line 124
struct key_user;
#line 124
struct key_user;
#line 124
struct key_user;
#line 124 "include/linux/key.h"
union __anonunion____missing_field_name_217 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 124 "include/linux/key.h"
union __anonunion_type_data_218 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
   int reject_error ;
};
#line 124 "include/linux/key.h"
union __anonunion_payload_219 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 124 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_217 __annonCompField37 ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_218 type_data ;
   union __anonunion_payload_219 payload ;
};
#line 18 "include/linux/selinux.h"
struct audit_context;
#line 18
struct audit_context;
#line 18
struct audit_context;
#line 18
struct audit_context;
#line 21 "include/linux/cred.h"
struct user_struct;
#line 22
struct cred;
#line 23
struct inode;
#line 23
struct inode;
#line 23
struct inode;
#line 23
struct inode;
#line 31 "include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
#line 83 "include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
#line 116 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
#line 97 "include/linux/sched.h"
struct futex_pi_state;
#line 97
struct futex_pi_state;
#line 97
struct futex_pi_state;
#line 97
struct futex_pi_state;
#line 98
struct robust_list_head;
#line 98
struct robust_list_head;
#line 98
struct robust_list_head;
#line 98
struct robust_list_head;
#line 99
struct bio_list;
#line 99
struct bio_list;
#line 99
struct bio_list;
#line 99
struct bio_list;
#line 100
struct fs_struct;
#line 100
struct fs_struct;
#line 100
struct fs_struct;
#line 100
struct fs_struct;
#line 101
struct perf_event_context;
#line 101
struct perf_event_context;
#line 101
struct perf_event_context;
#line 101
struct perf_event_context;
#line 102
struct blk_plug;
#line 102
struct blk_plug;
#line 102
struct blk_plug;
#line 102
struct blk_plug;
#line 150
struct seq_file;
#line 151
struct cfs_rq;
#line 151
struct cfs_rq;
#line 151
struct cfs_rq;
#line 151
struct cfs_rq;
#line 259
struct task_struct;
#line 364
struct nsproxy;
#line 365
struct user_namespace;
#line 58 "include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 16 "include/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 15 "include/linux/aio.h"
struct kioctx;
#line 15
struct kioctx;
#line 15
struct kioctx;
#line 15
struct kioctx;
#line 87 "include/linux/aio.h"
union __anonunion_ki_obj_221 {
   void *user ;
   struct task_struct *tsk ;
};
#line 87
struct eventfd_ctx;
#line 87
struct eventfd_ctx;
#line 87
struct eventfd_ctx;
#line 87 "include/linux/aio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_221 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 165 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
#line 178 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
#line 213
struct mm_struct;
#line 441 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 448 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 456 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 474 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 510 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
#line 517
struct autogroup;
#line 517
struct autogroup;
#line 517
struct autogroup;
#line 517
struct autogroup;
#line 526
struct tty_struct;
#line 526
struct tty_struct;
#line 526
struct tty_struct;
#line 526
struct taskstats;
#line 526
struct taskstats;
#line 526
struct taskstats;
#line 526
struct tty_audit_buf;
#line 526
struct tty_audit_buf;
#line 526
struct tty_audit_buf;
#line 526 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore threadgroup_fork_lock ;
   int oom_adj ;
   int oom_score_adj ;
   int oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 687 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
   atomic_long_t locked_vm ;
};
#line 731
struct backing_dev_info;
#line 731
struct backing_dev_info;
#line 731
struct backing_dev_info;
#line 731
struct backing_dev_info;
#line 732
struct reclaim_state;
#line 732
struct reclaim_state;
#line 732
struct reclaim_state;
#line 732
struct reclaim_state;
#line 735 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 747 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1050
struct io_context;
#line 1050
struct io_context;
#line 1050
struct io_context;
#line 1050
struct io_context;
#line 1059
struct audit_context;
#line 1060
struct mempolicy;
#line 1061
struct pipe_inode_info;
#line 1061
struct pipe_inode_info;
#line 1061
struct pipe_inode_info;
#line 1061
struct pipe_inode_info;
#line 1064
struct rq;
#line 1064
struct rq;
#line 1064
struct rq;
#line 1064
struct rq;
#line 1084 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int flags ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int flags ) ;
   void (*yield_task)(struct rq *rq ) ;
   bool (*yield_to_task)(struct rq *rq , struct task_struct *p , bool preempt ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int flags ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sd_flag , int flags ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_waking)(struct task_struct *task ) ;
   void (*task_woken)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_fork)(struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ) ;
   unsigned int (*get_rr_interval)(struct rq *rq , struct task_struct *task ) ;
   void (*task_move_group)(struct task_struct *p , int on_rq ) ;
};
#line 1129 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1134 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1169 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
#line 1195
struct rt_rq;
#line 1195
struct rt_rq;
#line 1195
struct rt_rq;
#line 1195 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1220
struct files_struct;
#line 1220
struct files_struct;
#line 1220
struct files_struct;
#line 1220
struct irqaction;
#line 1220
struct irqaction;
#line 1220
struct irqaction;
#line 1220
struct css_set;
#line 1220
struct css_set;
#line 1220
struct css_set;
#line 1220
struct compat_robust_list_head;
#line 1220
struct compat_robust_list_head;
#line 1220
struct compat_robust_list_head;
#line 1220
struct ftrace_ret_stack;
#line 1220
struct ftrace_ret_stack;
#line 1220
struct ftrace_ret_stack;
#line 1220
struct mem_cgroup;
#line 1220
struct mem_cgroup;
#line 1220
struct mem_cgroup;
#line 1220 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1220 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct task_struct *wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned int brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int group_stop ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct cred *replacement_session_keyring ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   struct irqaction *irqaction ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48UL] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   int mems_allowed_change_disable ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   struct prop_local_single dirties ;
   int latency_record_count ;
   struct latency_record latency_record[32] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   atomic_t ptrace_bp_refcnt ;
};
#line 1634
struct pid_namespace;
#line 38 "include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   int node ;
   unsigned int stat[19] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 64 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 71 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
#line 25 "include/linux/genhd.h"
struct device_type;
#line 25
struct device_type;
#line 25
struct device_type;
#line 27
struct class;
#line 27
struct class;
#line 27
struct class;
#line 19 "include/linux/klist.h"
struct klist_node;
#line 19
struct klist_node;
#line 19
struct klist_node;
#line 19
struct klist_node;
#line 39 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 4 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/device.h"
struct dma_map_ops;
#line 4
struct dma_map_ops;
#line 4
struct dma_map_ops;
#line 4 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 28 "include/linux/device.h"
struct device;
#line 29
struct device_private;
#line 29
struct device_private;
#line 29
struct device_private;
#line 29
struct device_private;
#line 30
struct device_driver;
#line 30
struct device_driver;
#line 30
struct device_driver;
#line 30
struct device_driver;
#line 31
struct driver_private;
#line 31
struct driver_private;
#line 31
struct driver_private;
#line 31
struct driver_private;
#line 32
struct class;
#line 33
struct subsys_private;
#line 33
struct subsys_private;
#line 33
struct subsys_private;
#line 33
struct subsys_private;
#line 34
struct bus_type;
#line 34
struct bus_type;
#line 34
struct bus_type;
#line 34
struct bus_type;
#line 35
struct device_node;
#line 35
struct device_node;
#line 35
struct device_node;
#line 35
struct device_node;
#line 37 "include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
#line 82
struct device_attribute;
#line 82
struct device_attribute;
#line 82
struct device_attribute;
#line 82
struct driver_attribute;
#line 82
struct driver_attribute;
#line 82
struct driver_attribute;
#line 82 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 185
struct of_device_id;
#line 185
struct of_device_id;
#line 185
struct of_device_id;
#line 185 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 222 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
#line 280
struct class_attribute;
#line 280
struct class_attribute;
#line 280
struct class_attribute;
#line 280 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , mode_t *mode ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 347 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , struct class_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct class *class , struct class_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 413 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , mode_t *mode ) ;
   void (*release)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 424 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 484 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 551
struct dma_coherent_mem;
#line 551
struct dma_coherent_mem;
#line 551
struct dma_coherent_mem;
#line 551 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_power_domain *pwr_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device *dev ) ;
};
#line 43 "include/linux/pm_wakeup.h"
struct wakeup_source {
   char *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long hit_count ;
   unsigned int active : 1 ;
};
#line 13 "include/linux/blk_types.h"
struct bio;
#line 13
struct bio;
#line 13
struct bio;
#line 13
struct bio;
#line 14
struct bio_integrity_payload;
#line 14
struct bio_integrity_payload;
#line 14
struct bio_integrity_payload;
#line 14
struct bio_integrity_payload;
#line 15
struct page;
#line 16
struct block_device;
#line 16
struct block_device;
#line 16
struct block_device;
#line 16
struct block_device;
#line 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 18 "include/linux/blk_types.h"
typedef void bio_destructor_t(struct bio * );
#line 23 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 33 "include/linux/blk_types.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned int bi_phys_segments ;
   unsigned int bi_size ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   unsigned int bi_max_vecs ;
   unsigned int bi_comp_cpu ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct bio_integrity_payload *bi_integrity ;
   bio_destructor_t *bi_destructor ;
   struct bio_vec bi_inline_vecs[0] ;
};
#line 33 "include/linux/list_bl.h"
struct hlist_bl_node;
#line 33
struct hlist_bl_node;
#line 33
struct hlist_bl_node;
#line 33 "include/linux/list_bl.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 37 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 13 "include/linux/dcache.h"
struct nameidata;
#line 13
struct nameidata;
#line 13
struct nameidata;
#line 13
struct nameidata;
#line 14
struct path;
#line 14
struct path;
#line 14
struct path;
#line 14
struct path;
#line 15
struct vfsmount;
#line 15
struct vfsmount;
#line 15
struct vfsmount;
#line 15
struct vfsmount;
#line 35 "include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
#line 116
struct dentry_operations;
#line 116
struct dentry_operations;
#line 116
struct dentry_operations;
#line 116
struct super_block;
#line 116
struct super_block;
#line 116
struct super_block;
#line 116 "include/linux/dcache.h"
union __anonunion_d_u_224 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 116 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_224 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
};
#line 159 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 4 "include/linux/path.h"
struct dentry;
#line 5
struct vfsmount;
#line 7 "include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 57 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 57
struct radix_tree_node;
#line 57
struct radix_tree_node;
#line 57 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 16 "include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
#line 399 "include/linux/fs.h"
struct export_operations;
#line 399
struct export_operations;
#line 399
struct export_operations;
#line 399
struct export_operations;
#line 400
struct hd_geometry;
#line 400
struct hd_geometry;
#line 400
struct hd_geometry;
#line 400
struct hd_geometry;
#line 401
struct iovec;
#line 402
struct nameidata;
#line 403
struct kiocb;
#line 404
struct kobject;
#line 405
struct pipe_inode_info;
#line 406
struct poll_table_struct;
#line 406
struct poll_table_struct;
#line 406
struct poll_table_struct;
#line 406
struct poll_table_struct;
#line 407
struct kstatfs;
#line 407
struct kstatfs;
#line 407
struct kstatfs;
#line 407
struct kstatfs;
#line 408
struct vm_area_struct;
#line 409
struct vfsmount;
#line 410
struct cred;
#line 460 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 129 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 50 "include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 146 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 146 "include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 17 "include/linux/dqblk_qtree.h"
struct dquot;
#line 17
struct dquot;
#line 17
struct dquot;
#line 17
struct dquot;
#line 185 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 186 "include/linux/quota.h"
typedef long long qsize_t;
#line 200 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 215
struct quota_format_type;
#line 215
struct quota_format_type;
#line 215
struct quota_format_type;
#line 215
struct quota_format_type;
#line 217 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 230
struct super_block;
#line 284 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 301 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
#line 312 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 325
struct path;
#line 328 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 341 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 395 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops  const  *ops[2] ;
};
#line 523 "include/linux/fs.h"
struct page;
#line 524
struct address_space;
#line 525
struct writeback_control;
#line 525
struct writeback_control;
#line 525
struct writeback_control;
#line 525
struct writeback_control;
#line 568 "include/linux/fs.h"
union __anonunion_arg_231 {
   char *buf ;
   void *data ;
};
#line 568 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_230 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_231 arg ;
   int error ;
};
#line 568 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_230 read_descriptor_t;
#line 581 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
#line 633
struct backing_dev_info;
#line 634 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 658
struct hd_struct;
#line 658
struct hd_struct;
#line 658
struct hd_struct;
#line 658
struct gendisk;
#line 658
struct gendisk;
#line 658
struct gendisk;
#line 658 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 735
struct posix_acl;
#line 735
struct posix_acl;
#line 735
struct posix_acl;
#line 735
struct posix_acl;
#line 738
struct inode_operations;
#line 738
struct inode_operations;
#line 738
struct inode_operations;
#line 738 "include/linux/fs.h"
union __anonunion____missing_field_name_232 {
   struct list_head i_dentry ;
   struct rcu_head i_rcu ;
};
#line 738
struct file_operations;
#line 738
struct file_operations;
#line 738
struct file_operations;
#line 738
struct file_lock;
#line 738
struct file_lock;
#line 738
struct file_lock;
#line 738
struct cdev;
#line 738
struct cdev;
#line 738
struct cdev;
#line 738 "include/linux/fs.h"
union __anonunion____missing_field_name_233 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 738 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   uid_t i_uid ;
   gid_t i_gid ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   spinlock_t i_lock ;
   unsigned int i_flags ;
   unsigned long i_state ;
   void *i_security ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_232 __annonCompField39 ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   dev_t i_rdev ;
   unsigned int i_blkbits ;
   u64 i_version ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   struct rw_semaphore i_alloc_sem ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_233 __annonCompField40 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   atomic_t i_writecount ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   void *i_private ;
};
#line 903 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 914 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 937 "include/linux/fs.h"
union __anonunion_f_u_234 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 937 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_234 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 1064 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1066 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1071 "include/linux/fs.h"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
#line 8 "include/linux/nfs_fs_i.h"
struct nlm_lockowner;
#line 8
struct nlm_lockowner;
#line 8
struct nlm_lockowner;
#line 8
struct nlm_lockowner;
#line 13 "include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 19
struct nfs4_lock_state;
#line 19
struct nfs4_lock_state;
#line 19
struct nfs4_lock_state;
#line 19
struct nfs4_lock_state;
#line 20 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1091 "include/linux/fs.h"
struct fasync_struct;
#line 1091
struct fasync_struct;
#line 1091
struct fasync_struct;
#line 1091 "include/linux/fs.h"
struct __anonstruct_afs_236 {
   struct list_head link ;
   int state ;
};
#line 1091 "include/linux/fs.h"
union __anonunion_fl_u_235 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_236 afs ;
};
#line 1091 "include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_235 fl_u ;
};
#line 1324 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct rcu_head fa_rcu ;
};
#line 1364
struct file_system_type;
#line 1364
struct file_system_type;
#line 1364
struct file_system_type;
#line 1364
struct super_operations;
#line 1364
struct super_operations;
#line 1364
struct super_operations;
#line 1364
struct xattr_handler;
#line 1364
struct xattr_handler;
#line 1364
struct xattr_handler;
#line 1364
struct mtd_info;
#line 1364
struct mtd_info;
#line 1364
struct mtd_info;
#line 1364 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_dirt ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   u8 s_uuid[16] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
};
#line 1499 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1533
struct block_device_operations;
#line 1533
struct block_device_operations;
#line 1533
struct block_device_operations;
#line 1533
struct block_device_operations;
#line 1546 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file *file , int mode , loff_t offset , loff_t len ) ;
};
#line 1578 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  , unsigned int  ) ;
   int (*check_acl)(struct inode * , int  , unsigned int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   void (*truncate)(struct inode * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 1608
struct seq_file;
#line 1622 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int flags ) ;
   int (*write_inode)(struct inode * , struct writeback_control *wbc ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_devname)(struct seq_file * , struct vfsmount * ) ;
   int (*show_path)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
#line 1802 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
#line 82 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2] ;
   unsigned long ios[2] ;
   unsigned long merges[2] ;
   unsigned long ticks[2] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 94 "include/linux/genhd.h"
struct partition_meta_info {
   u8 uuid[16] ;
   u8 volname[64] ;
};
#line 99 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct rcu_head rcu_head ;
};
#line 146 "include/linux/genhd.h"
struct disk_part_tbl {
   struct rcu_head rcu_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 153
struct disk_events;
#line 153
struct disk_events;
#line 153
struct disk_events;
#line 153
struct disk_events;
#line 155
struct request_queue;
#line 155
struct request_queue;
#line 155
struct request_queue;
#line 155
struct timer_rand_state;
#line 155
struct timer_rand_state;
#line 155
struct timer_rand_state;
#line 155
struct blk_integrity;
#line 155
struct blk_integrity;
#line 155
struct blk_integrity;
#line 155 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32] ;
   char *(*devnode)(struct gendisk *gd , mode_t *mode ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 19 "include/linux/mm.h"
struct mempolicy;
#line 20
struct anon_vma;
#line 21
struct file_ra_state;
#line 22
struct user_struct;
#line 23
struct writeback_control;
#line 41 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable_64.h"
struct mm_struct;
#line 656 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/pgtable.h"
struct vm_area_struct;
#line 185 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 202 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t const   *from , nodemask_t const   *to ,
                  unsigned long flags ) ;
};
#line 244
struct inode;
#line 197 "include/linux/page-flags.h"
struct page;
#line 94 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 10 "include/linux/irqreturn.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 31 "include/linux/irq.h"
struct seq_file;
#line 12 "include/linux/irqdesc.h"
struct proc_dir_entry;
#line 12
struct proc_dir_entry;
#line 12
struct proc_dir_entry;
#line 12
struct proc_dir_entry;
#line 13
struct timer_rand_state;
#line 16 "include/linux/profile.h"
struct proc_dir_entry;
#line 17
struct pt_regs;
#line 65
struct task_struct;
#line 66
struct mm_struct;
#line 88
struct pt_regs;
#line 363 "include/linux/irq.h"
struct irqaction;
#line 132 "include/linux/hardirq.h"
struct task_struct;
#line 10 "include/linux/writeback.h"
struct backing_dev_info;
#line 17
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 27 "include/linux/writeback.h"
struct writeback_control {
   enum writeback_sync_modes sync_mode ;
   unsigned long *older_than_this ;
   unsigned long wb_start ;
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   unsigned int nonblocking : 1 ;
   unsigned int encountered_congestion : 1 ;
   unsigned int for_kupdate : 1 ;
   unsigned int for_background : 1 ;
   unsigned int for_reclaim : 1 ;
   unsigned int range_cyclic : 1 ;
   unsigned int more_io : 1 ;
};
#line 58
struct bdi_writeback;
#line 58
struct bdi_writeback;
#line 58
struct bdi_writeback;
#line 58
struct bdi_writeback;
#line 21 "include/linux/backing-dev.h"
struct page;
#line 22
struct device;
#line 23
struct dentry;
#line 38 "include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 48 "include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned int nr ;
   unsigned long last_old_flush ;
   unsigned long last_active ;
   struct task_struct *task ;
   struct timer_list wakeup_timer ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
};
#line 62 "include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[2] ;
   struct prop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 9 "include/linux/mempool.h"
struct kmem_cache;
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t gfp_mask , void *pool_data );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void *element , void *pool_data );
#line 14 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 14 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 34 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   unsigned short ioprio_changed ;
   unsigned short cgroup_changed ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root radix_root ;
   struct hlist_head cic_list ;
   void *ioc_data ;
};
#line 73
struct task_struct;
#line 169 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   sector_t bip_sector ;
   void *bip_buf ;
   bio_end_io_t *bip_end_io ;
   unsigned int bip_size ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_idx ;
   struct work_struct bip_work ;
   struct bio_vec bip_vec[0] ;
};
#line 221
struct request_queue;
#line 381 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 67 "include/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 6 "include/asm-generic/scatterlist.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 27 "include/linux/blkdev.h"
struct request_queue;
#line 28
struct elevator_queue;
#line 28
struct elevator_queue;
#line 28
struct elevator_queue;
#line 28
struct elevator_queue;
#line 30
struct blk_trace;
#line 30
struct blk_trace;
#line 30
struct blk_trace;
#line 30
struct blk_trace;
#line 31
struct request;
#line 31
struct request;
#line 31
struct request;
#line 31
struct request;
#line 37
struct request;
#line 38 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 40 "include/linux/blkdev.h"
struct request_list {
   int count[2] ;
   int starved[2] ;
   int elvpriv ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2] ;
};
#line 55
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_SPECIAL = 7,
    REQ_TYPE_ATA_TASKFILE = 8,
    REQ_TYPE_ATA_PC = 9
} ;
#line 79 "include/linux/blkdev.h"
union __anonunion____missing_field_name_248 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 79 "include/linux/blkdev.h"
struct __anonstruct_flush_250 {
   unsigned int seq ;
   struct list_head list ;
};
#line 79 "include/linux/blkdev.h"
union __anonunion____missing_field_name_249 {
   void *elevator_private[3] ;
   struct __anonstruct_flush_250 flush ;
};
#line 79 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct call_single_data csd ;
   struct request_queue *q ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   struct hlist_node hash ;
   union __anonunion____missing_field_name_248 __annonCompField41 ;
   union __anonunion____missing_field_name_249 __annonCompField42 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   int ref_count ;
   void *special ;
   char *buffer ;
   int tag ;
   int errors ;
   unsigned char __cmd[16] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 8 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 11 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 13 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 15 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 17 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 20 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 22 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 23 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 24 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 25 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 27 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , gfp_t  );
#line 28 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 29 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 30 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 32 "include/linux/elevator.h"
typedef void *elevator_init_fn(struct request_queue * );
#line 33 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 35 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   void (*trim)(struct io_context * ) ;
};
#line 65 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 74 "include/linux/elevator.h"
struct elevator_type {
   struct list_head list ;
   struct elevator_ops ops ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16] ;
   struct module *elevator_owner ;
};
#line 86 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_ops *ops ;
   void *elevator_data ;
   struct kobject kobj ;
   struct elevator_type *elevator_type ;
   struct mutex sysfs_lock ;
   struct hlist_head *hash ;
   unsigned int registered : 1 ;
};
#line 195 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue *q );
#line 196 "include/linux/blkdev.h"
typedef int make_request_fn(struct request_queue *q , struct bio *bio );
#line 197 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 198 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 200
struct bio_vec;
#line 201 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 207 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 209 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 210 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 211 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue *q );
#line 213
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 219 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 226 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
};
#line 238 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
};
#line 263 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   struct request_list rq ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   gfp_t bounce_gfp ;
   unsigned long queue_flags ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   void *dma_drain_buffer ;
   unsigned int dma_drain_size ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2] ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned int flush_not_queueable : 1 ;
   unsigned int flush_queue_delayed : 1 ;
   unsigned int flush_pending_idx : 1 ;
   unsigned int flush_running_idx : 1 ;
   unsigned long flush_pending_since ;
   struct list_head flush_queue[2] ;
   struct list_head flush_data_in_flight ;
   struct request flush_rq ;
   struct mutex sysfs_lock ;
   struct bsg_class_device bsg_dev ;
};
#line 860 "include/linux/blkdev.h"
struct blk_plug {
   unsigned long magic ;
   struct list_head list ;
   struct list_head cb_list ;
   unsigned int should_sort ;
};
#line 1134
struct work_struct;
#line 1203 "include/linux/blkdev.h"
struct blk_integrity_exchg {
   void *prot_buf ;
   void *data_buf ;
   sector_t sector ;
   unsigned int data_size ;
   unsigned short sector_size ;
   char const   *disk_name ;
};
#line 1212 "include/linux/blkdev.h"
typedef void integrity_gen_fn(struct blk_integrity_exchg * );
#line 1213 "include/linux/blkdev.h"
typedef int integrity_vrfy_fn(struct blk_integrity_exchg * );
#line 1214 "include/linux/blkdev.h"
typedef void integrity_set_tag_fn(void * , void * , unsigned int  );
#line 1215 "include/linux/blkdev.h"
typedef void integrity_get_tag_fn(void * , void * , unsigned int  );
#line 1217 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_gen_fn *generate_fn ;
   integrity_vrfy_fn *verify_fn ;
   integrity_set_tag_fn *set_tag_fn ;
   integrity_get_tag_fn *get_tag_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short sector_size ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1294 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   int (*release)(struct gendisk * , fmode_t  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ) ;
   unsigned int (*check_events)(struct gendisk *disk , unsigned int clearing ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 9 "include/trace/events/irq.h"
struct irqaction;
#line 106 "include/linux/interrupt.h"
struct irqaction {
   irqreturn_t (*handler)(int  , void * ) ;
   unsigned long flags ;
   void *dev_id ;
   struct irqaction *next ;
   int irq ;
   irqreturn_t (*thread_fn)(int  , void * ) ;
   struct task_struct *thread ;
   unsigned long thread_flags ;
   unsigned long thread_mask ;
   char const   *name ;
   struct proc_dir_entry *dir ;
} __attribute__((__aligned__((1) <<  (12) ))) ;
#line 172
struct device;
#line 682
struct seq_file;
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 17 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32] ;
   char type[32] ;
   char compatible[128] ;
   void *data ;
};
#line 25 "include/linux/io.h"
struct device;
#line 61 "include/linux/pci.h"
struct hotplug_slot;
#line 61
struct hotplug_slot;
#line 61
struct hotplug_slot;
#line 61 "include/linux/pci.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 117 "include/linux/pci.h"
typedef int pci_power_t;
#line 143 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 145
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 169 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 184 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 228
struct pcie_link_state;
#line 228
struct pcie_link_state;
#line 228
struct pcie_link_state;
#line 228
struct pcie_link_state;
#line 229
struct pci_vpd;
#line 229
struct pci_vpd;
#line 229
struct pci_vpd;
#line 229
struct pci_vpd;
#line 230
struct pci_sriov;
#line 230
struct pci_sriov;
#line 230
struct pci_sriov;
#line 230
struct pci_sriov;
#line 231
struct pci_ats;
#line 231
struct pci_ats;
#line 231
struct pci_ats;
#line 231
struct pci_ats;
#line 236
struct pci_driver;
#line 236
struct pci_driver;
#line 236
struct pci_driver;
#line 236 "include/linux/pci.h"
union __anonunion____missing_field_name_258 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 236 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_interrupt : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int d3_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[18] ;
   resource_size_t fw_addr[18] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[18] ;
   struct bin_attribute *res_attr_wc[18] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_258 __annonCompField43 ;
   struct pci_ats *ats ;
};
#line 409
struct pci_ops;
#line 409
struct pci_ops;
#line 409
struct pci_ops;
#line 409 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4] ;
   struct list_head resources ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 475 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
#line 494 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 506 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 526 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
#line 546
struct module;
#line 547 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 12 "include/linux/bug.h"
struct pt_regs;
#line 25 "include/linux/dma-attrs.h"
struct dma_attrs {
   unsigned long flags[((2UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 10 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 11 "include/linux/dma-mapping.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 18 "include/linux/dma-mapping.h"
struct dma_map_ops {
   void *(*alloc_coherent)(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                           gfp_t gfp ) ;
   void (*free_coherent)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
   dma_addr_t (*map_page)(struct device *dev , struct page *page , unsigned long offset ,
                          size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
   void (*unmap_page)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ,
                      struct dma_attrs *attrs ) ;
   int (*map_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                 struct dma_attrs *attrs ) ;
   void (*unmap_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                    struct dma_attrs *attrs ) ;
   void (*sync_single_for_cpu)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                               enum dma_data_direction dir ) ;
   void (*sync_single_for_device)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                                  enum dma_data_direction dir ) ;
   void (*sync_sg_for_cpu)(struct device *dev , struct scatterlist *sg , int nents ,
                           enum dma_data_direction dir ) ;
   void (*sync_sg_for_device)(struct device *dev , struct scatterlist *sg , int nents ,
                              enum dma_data_direction dir ) ;
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   int (*dma_supported)(struct device *dev , u64 mask ) ;
   int (*set_dma_mask)(struct device *dev , u64 mask ) ;
   int is_phys ;
};
#line 25 "include/linux/dma-debug.h"
struct device;
#line 26
struct scatterlist;
#line 27
struct bus_type;
#line 6 "include/linux/swiotlb.h"
struct device;
#line 7
struct dma_attrs;
#line 8
struct scatterlist;
#line 14 "include/scsi/scsi.h"
struct scsi_cmnd;
#line 14
struct scsi_cmnd;
#line 14
struct scsi_cmnd;
#line 14
struct scsi_cmnd;
#line 11 "include/scsi/scsi_cmnd.h"
struct Scsi_Host;
#line 11
struct Scsi_Host;
#line 11
struct Scsi_Host;
#line 11
struct Scsi_Host;
#line 12
struct scsi_device;
#line 12
struct scsi_device;
#line 12
struct scsi_device;
#line 12
struct scsi_device;
#line 31 "include/scsi/scsi_cmnd.h"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 38 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 53 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   unsigned char tag ;
};
#line 12 "include/scsi/scsi_device.h"
struct request_queue;
#line 13
struct scsi_cmnd;
#line 15
struct scsi_sense_hdr;
#line 15
struct scsi_sense_hdr;
#line 15
struct scsi_sense_hdr;
#line 15
struct scsi_sense_hdr;
#line 31
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_BLOCK = 7,
    SDEV_CREATED_BLOCK = 8
} ;
#line 68
struct scsi_target;
#line 68
struct scsi_target;
#line 68
struct scsi_target;
#line 68
struct scsi_dh_data;
#line 68
struct scsi_dh_data;
#line 68
struct scsi_dh_data;
#line 68 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   unsigned int device_busy ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int lun ;
   unsigned int channel ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned int writeable : 1 ;
   unsigned int removable : 1 ;
   unsigned int changed : 1 ;
   unsigned int busy : 1 ;
   unsigned int lockable : 1 ;
   unsigned int locked : 1 ;
   unsigned int borken : 1 ;
   unsigned int disconnect : 1 ;
   unsigned int soft_reset : 1 ;
   unsigned int sdtr : 1 ;
   unsigned int wdtr : 1 ;
   unsigned int ppr : 1 ;
   unsigned int tagged_supported : 1 ;
   unsigned int simple_tags : 1 ;
   unsigned int ordered_tags : 1 ;
   unsigned int was_reset : 1 ;
   unsigned int expecting_cc_ua : 1 ;
   unsigned int use_10_for_rw : 1 ;
   unsigned int use_10_for_ms : 1 ;
   unsigned int skip_ms_page_8 : 1 ;
   unsigned int skip_ms_page_3f : 1 ;
   unsigned int use_192_bytes_for_3f : 1 ;
   unsigned int no_start_on_add : 1 ;
   unsigned int allow_restart : 1 ;
   unsigned int manage_start_stop : 1 ;
   unsigned int start_stop_pwr_cond : 1 ;
   unsigned int no_uld_attach : 1 ;
   unsigned int select_no_atn : 1 ;
   unsigned int fix_capacity : 1 ;
   unsigned int guess_capacity : 1 ;
   unsigned int retry_hwerror : 1 ;
   unsigned int last_sector_bug : 1 ;
   unsigned int no_read_disc_info : 1 ;
   unsigned int no_read_capacity_16 : 1 ;
   unsigned int is_visible : 1 ;
   unsigned long supported_events[((2UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int device_blocked ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0] ;
} __attribute__((__aligned__(sizeof(unsigned long )))) ;
#line 179 "include/scsi/scsi_device.h"
struct scsi_dh_devlist {
   char *vendor ;
   char *model ;
};
#line 185 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   int idx ;
   struct module *module ;
   char const   *name ;
   struct scsi_dh_devlist  const  *devlist ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   int (*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
};
#line 202 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
   char buf[0] ;
};
#line 225
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 236 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   unsigned int reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned int create : 1 ;
   unsigned int single_lun : 1 ;
   unsigned int pdt_1f_for_no_lun ;
   unsigned int target_busy ;
   unsigned int can_queue ;
   unsigned int target_blocked ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   struct execute_work ew ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0] ;
} __attribute__((__aligned__(sizeof(unsigned long )))) ;
#line 11 "include/scsi/scsi_host.h"
struct request_queue;
#line 12
struct block_device;
#line 13
struct completion;
#line 14
struct module;
#line 15
struct scsi_cmnd;
#line 16
struct scsi_device;
#line 17
struct scsi_target;
#line 18
struct Scsi_Host;
#line 19
struct scsi_host_cmd_pool;
#line 19
struct scsi_host_cmd_pool;
#line 19
struct scsi_host_cmd_pool;
#line 19
struct scsi_host_cmd_pool;
#line 20
struct scsi_transport_template;
#line 20
struct scsi_transport_template;
#line 20
struct scsi_transport_template;
#line 20
struct scsi_transport_template;
#line 52 "include/scsi/scsi_host.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device *dev , int cmd , void *arg ) ;
   int (*compat_ioctl)(struct scsi_device *dev , int cmd , void *arg ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*transfer_response)(struct scsi_cmnd * , void (*done)(struct scsi_cmnd * ) ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  , int  ) ;
   int (*change_queue_type)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*proc_info)(struct Scsi_Host * , char * , char ** , off_t  , int  , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   unsigned int supported_mode : 2 ;
   unsigned int unchecked_isa_dma : 1 ;
   unsigned int use_clustering : 1 ;
   unsigned int emulated : 1 ;
   unsigned int skip_settle_delay : 1 ;
   unsigned int ordered_tag : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
};
#line 530
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 540 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   struct blk_queue_tag *bqt ;
   unsigned int host_busy ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int resetting ;
   unsigned long last_reset ;
   unsigned int max_id ;
   unsigned int max_lun ;
   unsigned int max_channel ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   unsigned long cmd_serial_number ;
   unsigned int active_mode : 2 ;
   unsigned int unchecked_isa_dma : 1 ;
   unsigned int use_clustering : 1 ;
   unsigned int use_blk_tcq : 1 ;
   unsigned int host_self_blocked : 1 ;
   unsigned int reverse_ordering : 1 ;
   unsigned int ordered_tag : 1 ;
   unsigned int tmf_in_progress : 1 ;
   unsigned int async_scan : 1 ;
   char work_q_name[20] ;
   struct workqueue_struct *work_q ;
   unsigned int host_blocked ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0]  __attribute__((__aligned__(sizeof(unsigned long )))) ;
};
#line 222 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/drivers/scsi/dc395x.h"
struct ScsiInqData {
   u8 DevType ;
   u8 RMB_TypeMod ;
   u8 Vers ;
   u8 RDF ;
   u8 AddLen ;
   u8 Res1 ;
   u8 Res2 ;
   u8 Flags ;
   u8 VendorID[8] ;
   u8 ProductID[16] ;
   u8 ProductRev[4] ;
};
#line 190 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
struct SGentry {
   u32 address ;
   u32 length ;
};
#line 196 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
struct NVRamTarget {
   u8 cfg0 ;
   u8 period ;
   u8 cfg2 ;
   u8 cfg3 ;
};
#line 203 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
struct NvRamType {
   u8 sub_vendor_id[2] ;
   u8 sub_sys_id[2] ;
   u8 sub_class ;
   u8 vendor_id[2] ;
   u8 device_id[2] ;
   u8 reserved ;
   struct NVRamTarget target[16] ;
   u8 scsi_id ;
   u8 channel_cfg ;
   u8 delay_time ;
   u8 max_tag ;
   u8 reserved0 ;
   u8 boot_target ;
   u8 boot_lun ;
   u8 reserved1 ;
   u16 reserved2[22] ;
   u16 cksum ;
};
#line 229
struct DeviceCtlBlk;
#line 229
struct DeviceCtlBlk;
#line 229
struct DeviceCtlBlk;
#line 229 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
struct ScsiReqBlk {
   struct list_head list ;
   struct DeviceCtlBlk *dcb ;
   struct scsi_cmnd *cmd ;
   struct SGentry *segment_x ;
   dma_addr_t sg_bus_addr ;
   u8 sg_count ;
   u8 sg_index ;
   size_t total_xfer_length ;
   size_t request_length ;
   size_t xferred ;
   u16 state ;
   u8 msgin_buf[6] ;
   u8 msgout_buf[6] ;
   u8 adapter_status ;
   u8 target_status ;
   u8 msg_count ;
   u8 end_message ;
   u8 tag_number ;
   u8 status ;
   u8 retry_count ;
   u8 flag ;
   u8 scsi_phase ;
};
#line 270
struct AdapterCtlBlk;
#line 270
struct AdapterCtlBlk;
#line 270
struct AdapterCtlBlk;
#line 270 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
struct DeviceCtlBlk {
   struct list_head list ;
   struct AdapterCtlBlk *acb ;
   struct list_head srb_going_list ;
   struct list_head srb_waiting_list ;
   struct ScsiReqBlk *active_srb ;
   u32 tag_mask ;
   u16 max_command ;
   u8 target_id ;
   u8 target_lun ;
   u8 identify_msg ;
   u8 dev_mode ;
   u8 inquiry7 ;
   u8 sync_mode ;
   u8 min_nego_period ;
   u8 sync_period ;
   u8 sync_offset ;
   u8 flag ;
   u8 dev_type ;
   u8 init_tcq_flag ;
};
#line 297 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
struct AdapterCtlBlk {
   struct Scsi_Host *scsi_host ;
   unsigned long io_port_base ;
   unsigned long io_port_len ;
   struct list_head dcb_list ;
   struct DeviceCtlBlk *dcb_run_robin ;
   struct DeviceCtlBlk *active_dcb ;
   struct list_head srb_free_list ;
   struct ScsiReqBlk *tmp_srb ;
   struct timer_list waiting_timer ;
   struct timer_list selto_timer ;
   u16 srb_count ;
   u8 sel_timeout ;
   unsigned int irq_level ;
   u8 tag_max_num ;
   u8 acb_flag ;
   u8 gmode2 ;
   u8 config ;
   u8 lun_chk ;
   u8 scan_devices ;
   u8 hostid_bit ;
   u8 dcb_map[16] ;
   struct DeviceCtlBlk *children[16][32] ;
   struct pci_dev *dev ;
   u8 msg_len ;
   struct ScsiReqBlk srb_array[63] ;
   struct ScsiReqBlk srb ;
   struct NvRamType eeprom ;
};
#line 486 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
struct ParameterData {
   int value ;
   int min ;
   int max ;
   int def ;
   int safe ;
};
#line 244 "include/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
} __attribute__((__packed__)) ;
#line 300 "include/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
} __attribute__((__packed__)) ;
#line 337 "include/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
} __attribute__((__packed__)) ;
#line 355 "include/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
} __attribute__((__packed__)) ;
#line 576 "include/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
} __attribute__((__packed__)) ;
#line 637 "include/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
} __attribute__((__packed__)) ;
#line 846
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 854
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 25 "include/linux/usb.h"
struct usb_device;
#line 25
struct usb_device;
#line 25
struct usb_device;
#line 25
struct usb_device;
#line 27
struct wusb_dev;
#line 27
struct wusb_dev;
#line 27
struct wusb_dev;
#line 27
struct wusb_dev;
#line 47
struct ep_device;
#line 47
struct ep_device;
#line 47
struct ep_device;
#line 47
struct ep_device;
#line 64 "include/linux/usb.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
};
#line 77 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
   unsigned char *extra ;
   int extralen ;
};
#line 90
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 159 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned int sysfs_files_created : 1 ;
   unsigned int ep_devs_created : 1 ;
   unsigned int unregistering : 1 ;
   unsigned int needs_remote_wakeup : 1 ;
   unsigned int needs_altsetting0 : 1 ;
   unsigned int needs_binding : 1 ;
   unsigned int reset_running : 1 ;
   unsigned int resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 222 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0] ;
};
#line 274 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16] ;
   struct usb_interface *interface[32] ;
   struct usb_interface_cache *intf_cache[32] ;
   unsigned char *extra ;
   int extralen ;
};
#line 305 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[128UL / (8UL * sizeof(unsigned long ))] ;
};
#line 312
struct mon_bus;
#line 312
struct mon_bus;
#line 312
struct mon_bus;
#line 312 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned int is_b_host : 1 ;
   unsigned int b_hnp_enable : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   struct dentry *usbfs_dentry ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 367
struct usb_tt;
#line 367
struct usb_tt;
#line 367
struct usb_tt;
#line 367
struct usb_tt;
#line 426 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16] ;
   struct usb_host_endpoint *ep_out[16] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned int can_submit : 1 ;
   unsigned int persist_enabled : 1 ;
   unsigned int have_langid : 1 ;
   unsigned int authorized : 1 ;
   unsigned int authenticated : 1 ;
   unsigned int wusb : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   struct device *usb_classdev ;
   struct dentry *usbfs_dentry ;
   int maxchild ;
   struct usb_device *children[31] ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned int do_remote_wakeup : 1 ;
   unsigned int reset_resume : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
};
#line 983 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 990
struct urb;
#line 990
struct urb;
#line 990
struct urb;
#line 990
struct urb;
#line 992 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   unsigned int poisoned : 1 ;
};
#line 1183 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0] ;
};
#line 1388
struct scatterlist;
#line 1 "<compiler builtins>"
void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;
#line 1
long __builtin_expect(long  , long  ) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) ;
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ struct list_head *__cil_tmp3 ;

  {
  {
#line 62
  __cil_tmp3 = head->next;
#line 62
  __list_add(new, head, __cil_tmp3);
  }
#line 63
  return;
}
}
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ struct list_head *__cil_tmp3 ;

  {
  {
#line 76
  __cil_tmp3 = head->prev;
#line 76
  __list_add(new, __cil_tmp3, head);
  }
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head *entry ) ;
#line 112
extern void list_del(struct list_head *entry ) ;
#line 153 "include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
#line 155
  __list_del_entry(list);
#line 156
  list_add(list, head);
  }
#line 157
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ unsigned long __cil_tmp2 ;
  struct list_head *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 188
  __cil_tmp2 = (unsigned long )head;
#line 188
  __cil_tmp3 = head->next;
#line 188
  __cil_tmp4 = (unsigned long )__cil_tmp3;
#line 188
  return (__cil_tmp4 == __cil_tmp2);
  }
}
}
#line 100 "include/linux/printk.h"
extern int printk(char const   *fmt  , ...) ;
#line 69 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   *file , int line ) ;
#line 291 "include/linux/kernel.h"
extern int sprintf(char *buf , char const   *fmt  , ...) ;
#line 61 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/page_64_types.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 349 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 34 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void *to , void const   *from , size_t len ) ;
#line 55
extern void *memset(void *s , int c , size_t n ) ;
#line 851 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void)  __attribute__((__no_instrument_function__)) ;
#line 851
__inline static unsigned long arch_local_save_flags(void)  __attribute__((__no_instrument_function__)) ;
#line 851 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  struct paravirt_patch_template *__cil_tmp15 ;
  void **__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long long __cil_tmp19 ;
  u64 __cil_tmp20 ;
  u64 __cil_tmp21 ;
  unsigned long long __cil_tmp22 ;
  struct paravirt_patch_template *__cil_tmp23 ;
  void **__cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;

  {
#line 853
  __edi = __edi;
#line 853
  __esi = __esi;
#line 853
  __edx = __edx;
#line 853
  __ecx = __ecx;
#line 853
  __eax = __eax;
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 853
    __cil_tmp8 = (void *)0;
#line 853
    __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 853
    __cil_tmp10 = (unsigned long )pv_irq_ops.save_fl.func;
#line 853
    __cil_tmp11 = __cil_tmp10 == __cil_tmp9;
#line 853
    __cil_tmp12 = ! __cil_tmp11;
#line 853
    __cil_tmp13 = ! __cil_tmp12;
#line 853
    __cil_tmp14 = (long )__cil_tmp13;
#line 853
    tmp = __builtin_expect(__cil_tmp14, 0L);
    }
#line 853
    if (tmp) {
      {
#line 853
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 853
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"),
                             "i" (853), "i" (12UL));
        {
#line 853
        while (1) {
          while_continue___1: /* CIL Label */ ;

        }
        while_break___3: /* CIL Label */ ;
        }

#line 853
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {

    }
#line 853
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 853
  if (8UL > 8UL) {
#line 853
    __cil_tmp15 = (struct paravirt_patch_template *)0;
#line 853
    __cil_tmp16 = & __cil_tmp15->pv_irq_ops.save_fl.func;
#line 853
    __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 853
    __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 853
/*    __asm__  volatile   (""
                         "771:\n\t"
                         "call *%c[paravirt_opptr];"
                         "\n"
                         "772:\n"
                         ".pushsection .parainstructions,\"a\"\n"
                         " "
                         ".balign 8"
                         " "
                         "\n"
                         " "
                         ".quad"
                         " "
                         " 771b\n"
                         "  .byte "
                         "%c[paravirt_typenum]"
                         "\n"
                         "  .byte 772b-771b\n"
                         "  .short "
                         "%c[paravirt_clobber]"
                         "\n"
                         ".popsection\n"
                         "": "=a" (__eax): [paravirt_typenum] "i" (__cil_tmp18 / 8UL),
                         [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                         "cc");*/
#line 853
    __cil_tmp19 = (unsigned long long )__eax;
#line 853
    __cil_tmp20 = (u64 )__edx;
#line 853
    __cil_tmp21 = __cil_tmp20 << 32;
#line 853
    __cil_tmp22 = __cil_tmp21 | __cil_tmp19;
#line 853
    __ret = (unsigned long )__cil_tmp22;
  } else {
#line 853
    __cil_tmp23 = (struct paravirt_patch_template *)0;
#line 853
    __cil_tmp24 = & __cil_tmp23->pv_irq_ops.save_fl.func;
#line 853
    __cil_tmp25 = (unsigned int )__cil_tmp24;
#line 853
    __cil_tmp26 = (unsigned long )__cil_tmp25;
#line 853
/*    __asm__  volatile   (""
                         "771:\n\t"
                         "call *%c[paravirt_opptr];"
                         "\n"
                         "772:\n"
                         ".pushsection .parainstructions,\"a\"\n"
                         " "
                         ".balign 8"
                         " "
                         "\n"
                         " "
                         ".quad"
                         " "
                         " 771b\n"
                         "  .byte "
                         "%c[paravirt_typenum]"
                         "\n"
                         "  .byte 772b-771b\n"
                         "  .short "
                         "%c[paravirt_clobber]"
                         "\n"
                         ".popsection\n"
                         "": "=a" (__eax): [paravirt_typenum] "i" (__cil_tmp26 / 8UL),
                         [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                         "cc");*/
#line 853
    __ret = __eax;
  }
#line 853
  return (__ret);
}
}
#line 856
__inline static void arch_local_irq_restore(unsigned long f )  __attribute__((__no_instrument_function__)) ;
#line 856
__inline static void arch_local_irq_restore(unsigned long f )  __attribute__((__no_instrument_function__)) ;
#line 856 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_restore(unsigned long f ) 
{ unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  long __cil_tmp14 ;
  struct paravirt_patch_template *__cil_tmp15 ;
  void **__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;

  {
#line 858
  __edi = __edi;
#line 858
  __esi = __esi;
#line 858
  __edx = __edx;
#line 858
  __ecx = __ecx;
#line 858
  __eax = __eax;
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 858
    __cil_tmp8 = (void *)0;
#line 858
    __cil_tmp9 = (unsigned long )__cil_tmp8;
#line 858
    __cil_tmp10 = (unsigned long )pv_irq_ops.restore_fl.func;
#line 858
    __cil_tmp11 = __cil_tmp10 == __cil_tmp9;
#line 858
    __cil_tmp12 = ! __cil_tmp11;
#line 858
    __cil_tmp13 = ! __cil_tmp12;
#line 858
    __cil_tmp14 = (long )__cil_tmp13;
#line 858
    tmp = __builtin_expect(__cil_tmp14, 0L);
    }
#line 858
    if (tmp) {
      {
#line 858
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 858
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"),
                             "i" (858), "i" (12UL));
        {
#line 858
        while (1) {
          while_continue___1: /* CIL Label */ ;

        }
        while_break___3: /* CIL Label */ ;
        }

#line 858
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {

    }
#line 858
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 858
  __cil_tmp15 = (struct paravirt_patch_template *)0;
#line 858
  __cil_tmp16 = & __cil_tmp15->pv_irq_ops.restore_fl.func;
#line 858
  __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 858
  __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 858
/*  __asm__  volatile   (""
                       "771:\n\t"
                       "call *%c[paravirt_opptr];"
                       "\n"
                       "772:\n"
                       ".pushsection .parainstructions,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       " 771b\n"
                       "  .byte "
                       "%c[paravirt_typenum]"
                       "\n"
                       "  .byte 772b-771b\n"
                       "  .short "
                       "%c[paravirt_clobber]"
                       "\n"
                       ".popsection\n"
                       "": "=a" (__eax): [paravirt_typenum] "i" (__cil_tmp18 / 8UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");*/
#line 859
  return;
}
}
#line 861
__inline static void arch_local_irq_disable(void)  __attribute__((__no_instrument_function__)) ;
#line 861
__inline static void arch_local_irq_disable(void)  __attribute__((__no_instrument_function__)) ;
#line 861 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_disable(void) 
{ unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  struct paravirt_patch_template *__cil_tmp14 ;
  void **__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;

  {
#line 863
  __edi = __edi;
#line 863
  __esi = __esi;
#line 863
  __edx = __edx;
#line 863
  __ecx = __ecx;
#line 863
  __eax = __eax;
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 863
    __cil_tmp7 = (void *)0;
#line 863
    __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 863
    __cil_tmp9 = (unsigned long )pv_irq_ops.irq_disable.func;
#line 863
    __cil_tmp10 = __cil_tmp9 == __cil_tmp8;
#line 863
    __cil_tmp11 = ! __cil_tmp10;
#line 863
    __cil_tmp12 = ! __cil_tmp11;
#line 863
    __cil_tmp13 = (long )__cil_tmp12;
#line 863
    tmp = __builtin_expect(__cil_tmp13, 0L);
    }
#line 863
    if (tmp) {
      {
#line 863
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 863
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"),
                             "i" (863), "i" (12UL));
        {
#line 863
        while (1) {
          while_continue___1: /* CIL Label */ ;

        }
        while_break___3: /* CIL Label */ ;
        }

#line 863
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {

    }
#line 863
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 863
  __cil_tmp14 = (struct paravirt_patch_template *)0;
#line 863
  __cil_tmp15 = & __cil_tmp14->pv_irq_ops.irq_disable.func;
#line 863
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 863
  __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 863
/*  __asm__  volatile   (""
                       "771:\n\t"
                       "call *%c[paravirt_opptr];"
                       "\n"
                       "772:\n"
                       ".pushsection .parainstructions,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       " 771b\n"
                       "  .byte "
                       "%c[paravirt_typenum]"
                       "\n"
                       "  .byte 772b-771b\n"
                       "  .short "
                       "%c[paravirt_clobber]"
                       "\n"
                       ".popsection\n"
                       "": "=a" (__eax): [paravirt_typenum] "i" (__cil_tmp17 / 8UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");*/
#line 864
  return;
}
}
#line 871
__inline static unsigned long arch_local_irq_save(void)  __attribute__((__no_instrument_function__)) ;
#line 871
__inline static unsigned long arch_local_irq_save(void)  __attribute__((__no_instrument_function__)) ;
#line 871 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_irq_save(void) 
{ unsigned long f ;

  {
  {
#line 875
  f = arch_local_save_flags();
#line 876
  arch_local_irq_disable();
  }
#line 877
  return (f);
}
}
#line 154 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ unsigned long __cil_tmp2 ;

  {
  {
#line 156
  __cil_tmp2 = flags & 512UL;
#line 156
  return (! __cil_tmp2);
  }
}
}
#line 20 "include/linux/irqflags.h"
extern void trace_hardirqs_on(void) ;
#line 21
extern void trace_hardirqs_off(void) ;
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 32
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 42
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 

  {
#line 274
  return (& lock->__annonCompField18.rlock);
}
}
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 310
  __cil_tmp2 = & lock->__annonCompField18.rlock;
#line 310
  _raw_spin_lock_irq(__cil_tmp2);
  }
#line 311
  return;
}
}
#line 333 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ struct raw_spinlock *__cil_tmp2 ;

  {
  {
#line 335
  __cil_tmp2 = & lock->__annonCompField18.rlock;
#line 335
  _raw_spin_unlock_irq(__cil_tmp2);
  }
#line 336
  return;
}
}
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ struct raw_spinlock *__cil_tmp3 ;

  {
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    __cil_tmp3 = & lock->__annonCompField18.rlock;
#line 340
    _raw_spin_unlock_irqrestore(__cil_tmp3, flags);
    }
#line 340
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 341
  return;
}
}
#line 113 "include/linux/ioport.h"
extern struct resource ioport_resource ;
#line 156
extern struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ,
                                         int flags ) ;
#line 167
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 82 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
#line 91 "include/linux/timer.h"
extern void init_timer_key(struct timer_list *timer , char const   *name , struct lock_class_key *key ) ;
#line 204 "include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ void *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  struct list_head *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 206
  __cil_tmp2 = (void *)0;
#line 206
  __cil_tmp3 = (unsigned long )__cil_tmp2;
#line 206
  __cil_tmp4 = timer->entry.next;
#line 206
  __cil_tmp5 = (unsigned long )__cil_tmp4;
#line 206
  return (__cil_tmp5 != __cil_tmp3);
  }
}
}
#line 210
extern int del_timer(struct timer_list *timer ) ;
#line 275
extern void add_timer(struct timer_list *timer ) ;
#line 310 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/io.h"
__inline static void outb(unsigned char value , int port ) 
{ 

  {
#line 310
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0, %w1": : "a" (value), "Nd" (port));
#line 310
  return;
}
}
#line 310 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/io.h"
__inline static unsigned char inb(int port ) 
{ unsigned char value ;

  {
#line 310
  __asm__  volatile   ("in"
                       "b"
                       " %w1, %"
                       "b"
                       "0": "=a" (value): "Nd" (port));
#line 310
  return (value);
}
}
#line 311 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/io.h"
__inline static void outw(unsigned short value , int port ) 
{ 

  {
#line 311
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0, %w1": : "a" (value), "Nd" (port));
#line 311
  return;
}
}
#line 311 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/io.h"
__inline static unsigned short inw(int port ) 
{ unsigned short value ;

  {
#line 311
  __asm__  volatile   ("in"
                       "w"
                       " %w1, %"
                       "w"
                       "0": "=a" (value): "Nd" (port));
#line 311
  return (value);
}
}
#line 312 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 

  {
#line 312
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
#line 312
  return;
}
}
#line 312 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ unsigned int value ;

  {
#line 312
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
#line 312
  return (value);
}
}
#line 830 "include/linux/rcupdate.h"
extern void kfree(void const   * ) ;
#line 303 "include/linux/moduleparam.h"
extern struct kernel_param_ops param_ops_int ;
#line 329
extern struct kernel_param_ops param_ops_bool ;
#line 79 "include/linux/module.h"
int init_module(void) ;
#line 80
void cleanup_module(void) ;
#line 99
extern struct module __this_module ;
#line 16 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/delay.h"
extern void __const_udelay(unsigned long xloops ) ;
#line 221 "include/linux/slub_def.h"
extern void *__kmalloc(size_t size , gfp_t flags ) ;
#line 255 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___10 ;

  {
  {
#line 270
  tmp___10 = __kmalloc(size, flags);
  }
#line 270
  return (tmp___10);
}
}
#line 705 "include/linux/device.h"
extern void *dev_get_drvdata(struct device  const  *dev )  __attribute__((__ldv_model__)) ;
#line 706
extern int dev_set_drvdata(struct device *dev , void *data ) ;
#line 123 "include/linux/interrupt.h"
extern int __attribute__((__warn_unused_result__))  request_threaded_irq(unsigned int irq ,
                                                                         irqreturn_t (*handler)(int  ,
                                                                                                void * ) ,
                                                                         irqreturn_t (*thread_fn)(int  ,
                                                                                                  void * ) ,
                                                                         unsigned long flags ,
                                                                         char const   *name ,
                                                                         void *dev ) ;
#line 128 "include/linux/interrupt.h"
__inline static int __attribute__((__warn_unused_result__))  request_irq(unsigned int irq ,
                                                                         irqreturn_t (*handler)(int  ,
                                                                                                void * ) ,
                                                                         unsigned long flags ,
                                                                         char const   *name ,
                                                                         void *dev ) 
{ int tmp___7 ;
  int tmp ;
  int tmp___8 ;
  void *__cil_tmp9 ;
  irqreturn_t (*__cil_tmp10)(int  , void * ) ;

  {
  {
#line 132
  __cil_tmp9 = (void *)0;
#line 132
  __cil_tmp10 = (irqreturn_t (*)(int  , void * ))__cil_tmp9;
#line 132
  tmp___8 = (int )request_threaded_irq(irq, handler, __cil_tmp10, flags, name, dev);
#line 132
  tmp = tmp___8;
#line 132
  tmp___7 = tmp;
  }
#line 132
  return (tmp___7);
}
}
#line 170
extern void free_irq(unsigned int  , void * ) ;
#line 725 "include/linux/pci.h"
extern int pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u16 *val ) ;
#line 741 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev *dev , int where , u16 *val ) 
{ int tmp___7 ;
  struct pci_bus *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;

  {
  {
#line 743
  __cil_tmp5 = dev->bus;
#line 743
  __cil_tmp6 = dev->devfn;
#line 743
  tmp___7 = pci_bus_read_config_word(__cil_tmp5, __cil_tmp6, where, val);
  }
#line 743
  return (tmp___7);
}
}
#line 764
extern int __attribute__((__warn_unused_result__))  pci_enable_device(struct pci_dev *dev ) ;
#line 781
extern void pci_disable_device(struct pci_dev *dev ) ;
#line 782
extern void pci_set_master(struct pci_dev *dev ) ;
#line 916
extern int __attribute__((__warn_unused_result__))  __pci_register_driver(struct pci_driver * ,
                                                                          struct module * ,
                                                                          char const   *mod_name ) ;
#line 925
extern void pci_unregister_driver(struct pci_driver *dev ) ;
#line 202 "include/linux/scatterlist.h"
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 80 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ int tmp___7 ;

  {
#line 82
  if (dma_direction == 0) {
#line 82
    tmp___7 = 1;
  } else
#line 82
  if (dma_direction == 1) {
#line 82
    tmp___7 = 1;
  } else
#line 82
  if (dma_direction == 2) {
#line 82
    tmp___7 = 1;
  } else {
#line 82
    tmp___7 = 0;
  }
#line 82
  return (tmp___7);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 

  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device *dev , struct page *page , size_t offset ,
                               size_t size , int direction , dma_addr_t dma_addr ,
                               bool map_single ) ;
#line 42
extern void debug_dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                 int direction , bool map_single ) ;
#line 61
extern void debug_dma_sync_single_for_device(struct device *dev , dma_addr_t dma_handle ,
                                             size_t size , int direction ) ;
#line 76
extern void debug_dma_sync_sg_for_cpu(struct device *dev , struct scatterlist *sg ,
                                      int nelems , int direction ) ;
#line 29 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 31 "/anthill/stuff/tacas-comp/inst/current/envs/linux-3.0.1/linux-3.0.1/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ long tmp___7 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  long __cil_tmp6 ;
  struct dma_map_ops *__cil_tmp7 ;

  {
  {
#line 36
  __cil_tmp3 = ! dev;
#line 36
  __cil_tmp4 = ! __cil_tmp3;
#line 36
  __cil_tmp5 = ! __cil_tmp4;
#line 36
  __cil_tmp6 = (long )__cil_tmp5;
#line 36
  tmp___7 = __builtin_expect(__cil_tmp6, 0L);
  }
#line 36
  if (tmp___7) {
#line 37
    return (dma_ops);
  } else {
    {
#line 36
    __cil_tmp7 = dev->archdata.dma_ops;
#line 36
    if (! __cil_tmp7) {
#line 37
      return (dma_ops);
    } else {
#line 39
      return (dev->archdata.dma_ops);
    }
    }
  }
}
}
#line 9 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  dma_addr_t addr ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  dma_addr_t (*__cil_tmp18)(struct device *dev , struct page *page , unsigned long offset ,
                            size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
  unsigned long __cil_tmp19 ;
  struct page *__cil_tmp20 ;
  struct page *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct page *__cil_tmp30 ;
  struct page *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  bool __cil_tmp39 ;

  {
  {
#line 14
  tmp___7 = get_dma_ops(dev);
#line 14
  ops = tmp___7;
#line 17
  __cil_tmp14 = (unsigned int )size;
#line 17
  kmemcheck_mark_initialized(ptr, __cil_tmp14);
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 18
    __cil_tmp15 = (int )dir;
#line 18
    tmp___8 = valid_dma_direction(__cil_tmp15);
    }
#line 18
    if (tmp___8) {
#line 18
      tmp___9 = 0;
    } else {
#line 18
      tmp___9 = 1;
    }
    {
#line 18
    __cil_tmp16 = (long )tmp___9;
#line 18
    tmp___10 = __builtin_expect(__cil_tmp16, 0L);
    }
#line 18
    if (tmp___10) {
      {
#line 18
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 18
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("include/asm-generic/dma-mapping-common.h"),
                             "i" (18), "i" (12UL));
        {
#line 18
        while (1) {
          while_continue___1: /* CIL Label */ ;

        }
        while_break___3: /* CIL Label */ ;
        }

#line 18
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {

    }
#line 18
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 19
  __cil_tmp17 = (unsigned long )ptr;
#line 19
  tmp___11 = __phys_addr(__cil_tmp17);
#line 19
  __cil_tmp18 = ops->map_page;
#line 19
  __cil_tmp19 = tmp___11 >> 12;
#line 19
  __cil_tmp20 = (struct page *)1152897315351035904UL;
#line 19
  __cil_tmp21 = __cil_tmp20 + __cil_tmp19;
#line 19
  __cil_tmp22 = 1UL << 12;
#line 19
  __cil_tmp23 = __cil_tmp22 - 1UL;
#line 19
  __cil_tmp24 = ~ __cil_tmp23;
#line 19
  __cil_tmp25 = ~ __cil_tmp24;
#line 19
  __cil_tmp26 = (unsigned long )ptr;
#line 19
  __cil_tmp27 = __cil_tmp26 & __cil_tmp25;
#line 19
  addr = (*__cil_tmp18)(dev, __cil_tmp21, __cil_tmp27, size, dir, attrs);
#line 22
  __cil_tmp28 = (unsigned long )ptr;
#line 22
  tmp___12 = __phys_addr(__cil_tmp28);
#line 22
  __cil_tmp29 = tmp___12 >> 12;
#line 22
  __cil_tmp30 = (struct page *)1152897315351035904UL;
#line 22
  __cil_tmp31 = __cil_tmp30 + __cil_tmp29;
#line 22
  __cil_tmp32 = 1UL << 12;
#line 22
  __cil_tmp33 = __cil_tmp32 - 1UL;
#line 22
  __cil_tmp34 = ~ __cil_tmp33;
#line 22
  __cil_tmp35 = ~ __cil_tmp34;
#line 22
  __cil_tmp36 = (unsigned long )ptr;
#line 22
  __cil_tmp37 = __cil_tmp36 & __cil_tmp35;
#line 22
  __cil_tmp38 = (int )dir;
#line 22
  __cil_tmp39 = (bool )1;
#line 22
  debug_dma_map_page(dev, __cil_tmp31, __cil_tmp37, size, __cil_tmp38, addr, __cil_tmp39);
  }
#line 25
  return (addr);
}
}
#line 28 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int __cil_tmp11 ;
  long __cil_tmp12 ;
  void (*__cil_tmp13)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ,
                      struct dma_attrs *attrs ) ;
  int __cil_tmp14 ;
  bool __cil_tmp15 ;

  {
  {
#line 33
  tmp___7 = get_dma_ops(dev);
#line 33
  ops = tmp___7;
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 35
    __cil_tmp11 = (int )dir;
#line 35
    tmp___8 = valid_dma_direction(__cil_tmp11);
    }
#line 35
    if (tmp___8) {
#line 35
      tmp___9 = 0;
    } else {
#line 35
      tmp___9 = 1;
    }
    {
#line 35
    __cil_tmp12 = (long )tmp___9;
#line 35
    tmp___10 = __builtin_expect(__cil_tmp12, 0L);
    }
#line 35
    if (tmp___10) {
      {
#line 35
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 35
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("include/asm-generic/dma-mapping-common.h"),
                             "i" (35), "i" (12UL));
        {
#line 35
        while (1) {
          while_continue___1: /* CIL Label */ ;

        }
        while_break___3: /* CIL Label */ ;
        }

#line 35
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {

    }
#line 35
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 36
  if (ops->unmap_page) {
    {
#line 37
    __cil_tmp13 = ops->unmap_page;
#line 37
    (*__cil_tmp13)(dev, addr, size, dir, attrs);
    }
  } else {

  }
  {
#line 38
  __cil_tmp14 = (int )dir;
#line 38
  __cil_tmp15 = (bool )1;
#line 38
  debug_dma_unmap_page(dev, addr, size, __cil_tmp14, __cil_tmp15);
  }
#line 39
  return;
}
}
#line 108 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  void (*__cil_tmp12)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ) ;
  int __cil_tmp13 ;

  {
  {
#line 112
  tmp___7 = get_dma_ops(dev);
#line 112
  ops = tmp___7;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 114
    __cil_tmp10 = (int )dir;
#line 114
    tmp___8 = valid_dma_direction(__cil_tmp10);
    }
#line 114
    if (tmp___8) {
#line 114
      tmp___9 = 0;
    } else {
#line 114
      tmp___9 = 1;
    }
    {
#line 114
    __cil_tmp11 = (long )tmp___9;
#line 114
    tmp___10 = __builtin_expect(__cil_tmp11, 0L);
    }
#line 114
    if (tmp___10) {
      {
#line 114
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 114
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("include/asm-generic/dma-mapping-common.h"),
                             "i" (114), "i" (12UL));
        {
#line 114
        while (1) {
          while_continue___1: /* CIL Label */ ;

        }
        while_break___3: /* CIL Label */ ;
        }

#line 114
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {

    }
#line 114
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 115
  if (ops->sync_single_for_device) {
    {
#line 116
    __cil_tmp12 = ops->sync_single_for_device;
#line 116
    (*__cil_tmp12)(dev, addr, size, dir);
    }
  } else {

  }
  {
#line 117
  __cil_tmp13 = (int )dir;
#line 117
  debug_dma_sync_single_for_device(dev, addr, size, __cil_tmp13);
  }
#line 118
  return;
}
}
#line 138 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_sg_for_cpu(struct device *dev , struct scatterlist *sg ,
                                         int nelems , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  void (*__cil_tmp12)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ) ;
  int __cil_tmp13 ;

  {
  {
#line 142
  tmp___7 = get_dma_ops(dev);
#line 142
  ops = tmp___7;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    __cil_tmp10 = (int )dir;
#line 144
    tmp___8 = valid_dma_direction(__cil_tmp10);
    }
#line 144
    if (tmp___8) {
#line 144
      tmp___9 = 0;
    } else {
#line 144
      tmp___9 = 1;
    }
    {
#line 144
    __cil_tmp11 = (long )tmp___9;
#line 144
    tmp___10 = __builtin_expect(__cil_tmp11, 0L);
    }
#line 144
    if (tmp___10) {
      {
#line 144
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 144
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("include/asm-generic/dma-mapping-common.h"),
                             "i" (144), "i" (12UL));
        {
#line 144
        while (1) {
          while_continue___1: /* CIL Label */ ;

        }
        while_break___3: /* CIL Label */ ;
        }

#line 144
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {

    }
#line 144
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 145
  if (ops->sync_sg_for_cpu) {
    {
#line 146
    __cil_tmp12 = ops->sync_sg_for_cpu;
#line 146
    (*__cil_tmp12)(dev, sg, nelems, dir);
    }
  } else {

  }
  {
#line 147
  __cil_tmp13 = (int )dir;
#line 147
  debug_dma_sync_sg_for_cpu(dev, sg, nelems, __cil_tmp13);
  }
#line 148
  return;
}
}
#line 29 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ struct device *tmp___7 ;
  dma_addr_t tmp___8 ;
  void *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  enum dma_data_direction __cil_tmp11 ;
  void *__cil_tmp12 ;
  struct dma_attrs *__cil_tmp13 ;

  {
  {
#line 32
  __cil_tmp7 = (void *)0;
#line 32
  __cil_tmp8 = (unsigned long )__cil_tmp7;
#line 32
  __cil_tmp9 = (unsigned long )hwdev;
#line 32
  if (__cil_tmp9 == __cil_tmp8) {
#line 32
    __cil_tmp10 = (void *)0;
#line 32
    tmp___7 = (struct device *)__cil_tmp10;
  } else {
#line 32
    tmp___7 = & hwdev->dev;
  }
  }
  {
#line 32
  __cil_tmp11 = (enum dma_data_direction )direction;
#line 32
  __cil_tmp12 = (void *)0;
#line 32
  __cil_tmp13 = (struct dma_attrs *)__cil_tmp12;
#line 32
  tmp___8 = dma_map_single_attrs(tmp___7, ptr, size, __cil_tmp11, __cil_tmp13);
  }
#line 32
  return (tmp___8);
}
}
#line 35 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ struct device *tmp___7 ;
  void *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;
  enum dma_data_direction __cil_tmp10 ;
  void *__cil_tmp11 ;
  struct dma_attrs *__cil_tmp12 ;

  {
  {
#line 39
  __cil_tmp6 = (void *)0;
#line 39
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 39
  __cil_tmp8 = (unsigned long )hwdev;
#line 39
  if (__cil_tmp8 == __cil_tmp7) {
#line 39
    __cil_tmp9 = (void *)0;
#line 39
    tmp___7 = (struct device *)__cil_tmp9;
  } else {
#line 39
    tmp___7 = & hwdev->dev;
  }
  }
  {
#line 39
  __cil_tmp10 = (enum dma_data_direction )direction;
#line 39
  __cil_tmp11 = (void *)0;
#line 39
  __cil_tmp12 = (struct dma_attrs *)__cil_tmp11;
#line 39
  dma_unmap_single_attrs(tmp___7, dma_addr, size, __cil_tmp10, __cil_tmp12);
  }
#line 40
  return;
}
}
#line 77 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction ) 
{ struct device *tmp___7 ;
  void *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;
  enum dma_data_direction __cil_tmp10 ;

  {
  {
#line 81
  __cil_tmp6 = (void *)0;
#line 81
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 81
  __cil_tmp8 = (unsigned long )hwdev;
#line 81
  if (__cil_tmp8 == __cil_tmp7) {
#line 81
    __cil_tmp9 = (void *)0;
#line 81
    tmp___7 = (struct device *)__cil_tmp9;
  } else {
#line 81
    tmp___7 = & hwdev->dev;
  }
  }
  {
#line 81
  __cil_tmp10 = (enum dma_data_direction )direction;
#line 81
  dma_sync_single_for_device(tmp___7, dma_handle, size, __cil_tmp10);
  }
#line 82
  return;
}
}
#line 84 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev , struct scatterlist *sg ,
                                             int nelems , int direction ) 
{ struct device *tmp___7 ;
  void *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;
  enum dma_data_direction __cil_tmp10 ;

  {
  {
#line 88
  __cil_tmp6 = (void *)0;
#line 88
  __cil_tmp7 = (unsigned long )__cil_tmp6;
#line 88
  __cil_tmp8 = (unsigned long )hwdev;
#line 88
  if (__cil_tmp8 == __cil_tmp7) {
#line 88
    __cil_tmp9 = (void *)0;
#line 88
    tmp___7 = (struct device *)__cil_tmp9;
  } else {
#line 88
    tmp___7 = & hwdev->dev;
  }
  }
  {
#line 88
  __cil_tmp10 = (enum dma_data_direction )direction;
#line 88
  dma_sync_sg_for_cpu(tmp___7, sg, nelems, __cil_tmp10);
  }
#line 89
  return;
}
}
#line 1316 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp___7 ;
  struct device *__cil_tmp3 ;
  struct device  const  *__cil_tmp4 ;

  {
  {
#line 1318
  __cil_tmp3 = & pdev->dev;
#line 1318
  __cil_tmp4 = (struct device  const  *)__cil_tmp3;
#line 1318
  tmp___7 = dev_get_drvdata(__cil_tmp4);
  }
#line 1318
  return (tmp___7);
}
}
#line 1321 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ struct device *__cil_tmp3 ;

  {
  {
#line 1323
  __cil_tmp3 = & pdev->dev;
#line 1323
  dev_set_drvdata(__cil_tmp3, data);
  }
#line 1324
  return;
}
}
#line 15 "include/scsi/scsicam.h"
extern int scsicam_bios_param(struct block_device *bdev , sector_t capacity , int *ip ) ;
#line 141 "include/scsi/scsi_cmnd.h"
extern void *scsi_kmap_atomic_sg(struct scatterlist *sg , int sg_count , size_t *offset ,
                                 size_t *len ) ;
#line 143
extern void scsi_kunmap_atomic_sg(void *virt ) ;
#line 148
extern int scsi_dma_map(struct scsi_cmnd *cmd ) ;
#line 149
extern void scsi_dma_unmap(struct scsi_cmnd *cmd ) ;
#line 154 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_sg_count(struct scsi_cmnd *cmd ) 
{ 

  {
#line 156
  return (cmd->sdb.table.nents);
}
}
#line 159 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 

  {
#line 161
  return (cmd->sdb.table.sgl);
}
}
#line 164 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 

  {
#line 166
  return (cmd->sdb.length);
}
}
#line 169 "include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 

  {
#line 171
  cmd->sdb.resid = resid;
#line 172
  return;
}
}
#line 762 "include/scsi/scsi_host.h"
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
#line 763
extern int __attribute__((__warn_unused_result__))  scsi_add_host_with_dma(struct Scsi_Host * ,
                                                                           struct device * ,
                                                                           struct device * ) ;
#line 766
extern void scsi_scan_host(struct Scsi_Host * ) ;
#line 768
extern void scsi_remove_host(struct Scsi_Host * ) ;
#line 770
extern void scsi_host_put(struct Scsi_Host *t ) ;
#line 773
extern void scsi_cmd_get_serial(struct Scsi_Host * , struct scsi_cmnd * ) ;
#line 777 "include/scsi/scsi_host.h"
__inline static int __attribute__((__warn_unused_result__))  scsi_add_host(struct Scsi_Host *host ,
                                                                           struct device *dev ) 
{ int tmp___7 ;
  int tmp ;
  int tmp___8 ;

  {
  {
#line 780
  tmp___8 = (int )scsi_add_host_with_dma(host, dev, dev);
#line 780
  tmp = tmp___8;
#line 780
  tmp___7 = tmp;
  }
#line 780
  return (tmp___7);
}
}
#line 343 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void data_out_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 345
static void data_in_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 347
static void command_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 349
static void status_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 351
static void msgout_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 353
static void msgin_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 355
static void data_out_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 357
static void data_in_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 359
static void command_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 361
static void status_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 363
static void msgout_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 365
static void msgin_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 367
static void nop0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 369
static void nop1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) ;
#line 371
static void set_basic_config(struct AdapterCtlBlk *acb ) ;
#line 372
static void cleanup_after_transfer(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) ;
#line 374
static void reset_scsi_bus(struct AdapterCtlBlk *acb ) ;
#line 375
static void data_io_transfer(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ,
                             u16 io_dir ) ;
#line 377
static void disconnect(struct AdapterCtlBlk *acb ) ;
#line 378
static void reselect(struct AdapterCtlBlk *acb ) ;
#line 379
static u8 start_scsi(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) ;
#line 381
__inline static void enable_msgout_abort(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) ;
#line 383
static void build_srb(struct scsi_cmnd *cmd , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) ;
#line 385
static void doing_srb_done(struct AdapterCtlBlk *acb , u8 did_flag , struct scsi_cmnd *cmd ,
                           u8 force ) ;
#line 387
static void scsi_reset_detect(struct AdapterCtlBlk *acb ) ;
#line 388
static void pci_unmap_srb(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) ;
#line 389
static void pci_unmap_srb_sense(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) ;
#line 391
static void srb_done(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) ;
#line 393
static void request_sense(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) ;
#line 395
static void set_xfer_rate(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb ) ;
#line 397
static void waiting_timeout(unsigned long ptr ) ;
#line 403 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static u16 current_sync_offset  =    (u16 )0;
#line 405 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void *dc395x_scsi_phase0[8]  = 
#line 405
  {      (void *)(& data_out_phase0),      (void *)(& data_in_phase0),      (void *)(& command_phase0),      (void *)(& status_phase0), 
        (void *)(& nop0),      (void *)(& nop0),      (void *)(& msgout_phase0),      (void *)(& msgin_phase0)};
#line 416 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void *dc395x_scsi_phase1[8]  = 
#line 416
  {      (void *)(& data_out_phase1),      (void *)(& data_in_phase1),      (void *)(& command_phase1),      (void *)(& status_phase1), 
        (void *)(& nop1),      (void *)(& nop1),      (void *)(& msgout_phase1),      (void *)(& msgin_phase1)};
#line 449 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static u8 clock_period[8]  = 
#line 449
  {      (u8 )12,      (u8 )18,      (u8 )25,      (u8 )31, 
        (u8 )37,      (u8 )43,      (u8 )50,      (u8 )62};
#line 450 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static u16 clock_speed[8]  = 
#line 450
  {      (u16 )200,      (u16 )133,      (u16 )100,      (u16 )80, 
        (u16 )67,      (u16 )58,      (u16 )50,      (u16 )40};
#line 493 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct ParameterData cfg_data[6]  __attribute__((__section__(".devinit.data")))  = {      {-1,
      0, 15, 7, 7}, 
        {-1, 0, 7, 1, 4}, 
        {-1, 0, 63, 63, 9}, 
        {-1, 0, 47, 39, 15}, 
        {-1, 0, 5, 3, 2}, 
        {-1, 0, 180, 1, 10}};
#line 550 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int use_safe_settings  =    0;
#line 551 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __param_str_safe[5]  = {      (char const   )'s',      (char const   )'a',      (char const   )'f',      (char const   )'e', 
        (char const   )'\000'};
#line 551 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct kernel_param  const  __param_safe  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_safe, (struct kernel_param_ops  const  *)(& param_ops_bool), (u16 )0,
    (u16 )0, {(void *)(& use_safe_settings)}};
#line 551 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_safetype551[19]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 551
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'s',      (char const   )'a',      (char const   )'f', 
        (char const   )'e',      (char const   )':',      (char const   )'b',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'\000'};
#line 552 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_safe552[58]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 552
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'s',      (char const   )'a',      (char const   )'f', 
        (char const   )'e',      (char const   )':',      (char const   )'U',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'a', 
        (char const   )'f',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'s', 
        (char const   )'l',      (char const   )'o',      (char const   )'w',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'s', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )'.',      (char const   )' ',      (char const   )'D', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )':',      (char const   )' ', 
        (char const   )'f',      (char const   )'a',      (char const   )'l',      (char const   )'s', 
        (char const   )'e',      (char const   )'\000'};
#line 555 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __param_str_adapter_id[11]  = 
#line 555
  {      (char const   )'a',      (char const   )'d',      (char const   )'a',      (char const   )'p', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'_', 
        (char const   )'i',      (char const   )'d',      (char const   )'\000'};
#line 555 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct kernel_param  const  __param_adapter_id  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_adapter_id, (struct kernel_param_ops  const  *)(& param_ops_int),
    (u16 )0, (u16 )0, {(void *)(& cfg_data[0].value)}};
#line 555 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_adapter_idtype555[24]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 555
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'p',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
#line 556 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_adapter_id556[50]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 556
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'p',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'A',      (char const   )'d',      (char const   )'a',      (char const   )'p', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'S',      (char const   )'C',      (char const   )'S',      (char const   )'I', 
        (char const   )' ',      (char const   )'I',      (char const   )'D',      (char const   )'.', 
        (char const   )' ',      (char const   )'D',      (char const   )'e',      (char const   )'f', 
        (char const   )'a',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )' ',      (char const   )'7',      (char const   )' ',      (char const   )'(', 
        (char const   )'0',      (char const   )'-',      (char const   )'1',      (char const   )'5', 
        (char const   )')',      (char const   )'\000'};
#line 558 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __param_str_max_speed[10]  = 
#line 558
  {      (char const   )'m',      (char const   )'a',      (char const   )'x',      (char const   )'_', 
        (char const   )'s',      (char const   )'p',      (char const   )'e',      (char const   )'e', 
        (char const   )'d',      (char const   )'\000'};
#line 558 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct kernel_param  const  __param_max_speed  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_max_speed, (struct kernel_param_ops  const  *)(& param_ops_int), (u16 )0,
    (u16 )0, {(void *)(& cfg_data[1].value)}};
#line 558 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_max_speedtype558[23]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 558
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'m',      (char const   )'a',      (char const   )'x', 
        (char const   )'_',      (char const   )'s',      (char const   )'p',      (char const   )'e', 
        (char const   )'e',      (char const   )'d',      (char const   )':',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000'};
#line 559 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_max_speed559[110]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 559
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'m',      (char const   )'a',      (char const   )'x', 
        (char const   )'_',      (char const   )'s',      (char const   )'p',      (char const   )'e', 
        (char const   )'e',      (char const   )'d',      (char const   )':',      (char const   )'M', 
        (char const   )'a',      (char const   )'x',      (char const   )'i',      (char const   )'m', 
        (char const   )'u',      (char const   )'m',      (char const   )' ',      (char const   )'b', 
        (char const   )'u',      (char const   )'s',      (char const   )' ',      (char const   )'s', 
        (char const   )'p',      (char const   )'e',      (char const   )'e',      (char const   )'d', 
        (char const   )'.',      (char const   )' ',      (char const   )'D',      (char const   )'e', 
        (char const   )'f',      (char const   )'a',      (char const   )'u',      (char const   )'l', 
        (char const   )'t',      (char const   )' ',      (char const   )'1',      (char const   )' ', 
        (char const   )'(',      (char const   )'0',      (char const   )'-',      (char const   )'7', 
        (char const   )')',      (char const   )' ',      (char const   )'S',      (char const   )'p', 
        (char const   )'e',      (char const   )'e',      (char const   )'d',      (char const   )'s', 
        (char const   )':',      (char const   )' ',      (char const   )'0',      (char const   )'=', 
        (char const   )'2',      (char const   )'0',      (char const   )',',      (char const   )' ', 
        (char const   )'1',      (char const   )'=',      (char const   )'1',      (char const   )'3', 
        (char const   )'.',      (char const   )'3',      (char const   )',',      (char const   )' ', 
        (char const   )'2',      (char const   )'=',      (char const   )'1',      (char const   )'0', 
        (char const   )',',      (char const   )' ',      (char const   )'3',      (char const   )'=', 
        (char const   )'8',      (char const   )',',      (char const   )' ',      (char const   )'4', 
        (char const   )'=',      (char const   )'6',      (char const   )'.',      (char const   )'7', 
        (char const   )',',      (char const   )' ',      (char const   )'5',      (char const   )'=', 
        (char const   )'5',      (char const   )'.',      (char const   )'8',      (char const   )',', 
        (char const   )' ',      (char const   )'6',      (char const   )'=',      (char const   )'5', 
        (char const   )',',      (char const   )' ',      (char const   )'7',      (char const   )'=', 
        (char const   )'4',      (char const   )' ',      (char const   )'M',      (char const   )'h', 
        (char const   )'z',      (char const   )'\000'};
#line 561 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __param_str_dev_mode[9]  = 
#line 561
  {      (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'_', 
        (char const   )'m',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )'\000'};
#line 561 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct kernel_param  const  __param_dev_mode  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_dev_mode, (struct kernel_param_ops  const  *)(& param_ops_int), (u16 )0,
    (u16 )0, {(void *)(& cfg_data[2].value)}};
#line 561 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_dev_modetype561[22]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 561
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'_',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )':',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
#line 562 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_dev_mode562[27]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 562
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'_',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )':',      (char const   )'D',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )' ',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )'.',      (char const   )'\000'};
#line 564 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __param_str_adapter_mode[13]  = 
#line 564
  {      (char const   )'a',      (char const   )'d',      (char const   )'a',      (char const   )'p', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'_', 
        (char const   )'m',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )'\000'};
#line 564 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct kernel_param  const  __param_adapter_mode  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_adapter_mode, (struct kernel_param_ops  const  *)(& param_ops_int),
    (u16 )0, (u16 )0, {(void *)(& cfg_data[3].value)}};
#line 564 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_adapter_modetype564[26]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 564
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'p',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )':',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
#line 565 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_adapter_mode565[32]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 565
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'p',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )':',      (char const   )'A',      (char const   )'d', 
        (char const   )'a',      (char const   )'p',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )'.',      (char const   )'\000'};
#line 567 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __param_str_tags[5]  = {      (char const   )'t',      (char const   )'a',      (char const   )'g',      (char const   )'s', 
        (char const   )'\000'};
#line 567 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct kernel_param  const  __param_tags  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_tags, (struct kernel_param_ops  const  *)(& param_ops_int), (u16 )0,
    (u16 )0, {(void *)(& cfg_data[4].value)}};
#line 567 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_tagstype567[18]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 567
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'t',      (char const   )'a',      (char const   )'g', 
        (char const   )'s',      (char const   )':',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
#line 568 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_tags568[49]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 568
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'t',      (char const   )'a',      (char const   )'g', 
        (char const   )'s',      (char const   )':',      (char const   )'N',      (char const   )'u', 
        (char const   )'m',      (char const   )'b',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'t',      (char const   )'a',      (char const   )'g',      (char const   )'s', 
        (char const   )' ',      (char const   )'(',      (char const   )'1',      (char const   )'<', 
        (char const   )'<',      (char const   )'x',      (char const   )')',      (char const   )'.', 
        (char const   )' ',      (char const   )'D',      (char const   )'e',      (char const   )'f', 
        (char const   )'a',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )' ',      (char const   )'3',      (char const   )' ',      (char const   )'(', 
        (char const   )'0',      (char const   )'-',      (char const   )'5',      (char const   )')', 
        (char const   )'\000'};
#line 570 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __param_str_reset_delay[12]  = 
#line 570
  {      (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'_',      (char const   )'d',      (char const   )'e', 
        (char const   )'l',      (char const   )'a',      (char const   )'y',      (char const   )'\000'};
#line 570 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct kernel_param  const  __param_reset_delay  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_reset_delay, (struct kernel_param_ops  const  *)(& param_ops_int),
    (u16 )0, (u16 )0, {(void *)(& cfg_data[5].value)}};
#line 570 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_reset_delaytype570[25]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 570
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'_',      (char const   )'d', 
        (char const   )'e',      (char const   )'l',      (char const   )'a',      (char const   )'y', 
        (char const   )':',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
#line 571 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_reset_delay571[59]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 571
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'_',      (char const   )'d', 
        (char const   )'e',      (char const   )'l',      (char const   )'a',      (char const   )'y', 
        (char const   )':',      (char const   )'R',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'l',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'d',      (char const   )'s',      (char const   )'.', 
        (char const   )' ',      (char const   )'D',      (char const   )'e',      (char const   )'f', 
        (char const   )'a',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )' ',      (char const   )'1',      (char const   )' ',      (char const   )'(', 
        (char const   )'0',      (char const   )'-',      (char const   )'1',      (char const   )'8', 
        (char const   )'0',      (char const   )')',      (char const   )'\000'};
#line 578
static void set_safe_settings(void)  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 578
static void set_safe_settings(void)  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 578 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void set_safe_settings(void) 
{ int i ;

  {
#line 580
  if (use_safe_settings) {
    {
#line 584
    printk("<6>dc395x: Using safe settings.\n");
#line 585
    i = 0;
    }
    {
#line 585
    while (1) {
      while_continue: /* CIL Label */ ;

#line 585
      if (i < 6) {

      } else {
#line 585
        goto while_break;
      }
#line 587
      cfg_data[i].value = cfg_data[i].safe;
#line 585
      i = i + 1;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  } else {

  }
#line 590
  return;
}
}
#line 597
static void fix_settings(void)  __attribute__((__section__(".devinit.text"), __no_instrument_function__)) ;
#line 597
static void fix_settings(void)  __attribute__((__section__(".devinit.text"), __no_instrument_function__)) ;
#line 597 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void fix_settings(void) 
{ int i ;

  {
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;

#line 601
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 610
  i = 0;
  {
#line 610
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 610
    if (i < 6) {

    } else {
#line 610
      goto while_break___0;
    }
#line 612
    if (cfg_data[i].value < cfg_data[i].min) {
#line 614
      cfg_data[i].value = cfg_data[i].def;
    } else
#line 612
    if (cfg_data[i].value > cfg_data[i].max) {
#line 614
      cfg_data[i].value = cfg_data[i].def;
    } else {

    }
#line 610
    i = i + 1;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 616
  return;
}
}
#line 624 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char eeprom_index_to_delay_map[8]  __attribute__((__section__(".devinit.data")))  = 
#line 624
  {      (char)1,      (char)3,      (char)5,      (char)10, 
        (char)16,      (char)30,      (char)60,      (char)120};
#line 634
static void eeprom_index_to_delay(struct NvRamType *eeprom )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 634
static void eeprom_index_to_delay(struct NvRamType *eeprom )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 634 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void eeprom_index_to_delay(struct NvRamType *eeprom ) 
{ 

  {
#line 636
  eeprom->delay_time = (u8 )eeprom_index_to_delay_map[eeprom->delay_time];
#line 637
  return;
}
}
#line 647
static int delay_to_eeprom_index(int delay )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 647
static int delay_to_eeprom_index(int delay )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 647 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int delay_to_eeprom_index(int delay ) 
{ u8 idx ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 649
  idx = (u8 )0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 650
    __cil_tmp3 = (int )idx;
#line 650
    if (__cil_tmp3 < 7) {
      {
#line 650
      __cil_tmp4 = (int )eeprom_index_to_delay_map[idx];
#line 650
      if (__cil_tmp4 < delay) {

      } else {
#line 650
        goto while_break;
      }
      }
    } else {
#line 650
      goto while_break;
    }
    }
#line 651
    __cil_tmp5 = (int )idx;
#line 651
    __cil_tmp6 = __cil_tmp5 + 1;
#line 651
    idx = (u8 )__cil_tmp6;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 652
  return ((int )idx);
}
}
#line 663
static void eeprom_override(struct NvRamType *eeprom )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 663
static void eeprom_override(struct NvRamType *eeprom )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 663 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void eeprom_override(struct NvRamType *eeprom ) 
{ u8 id ;
  int tmp___7 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 668
  if (cfg_data[0].value != -1) {
#line 669
    eeprom->scsi_id = (u8 )cfg_data[0].value;
  } else {

  }
#line 671
  if (cfg_data[3].value != -1) {
#line 672
    eeprom->channel_cfg = (u8 )cfg_data[3].value;
  } else {

  }
#line 674
  if (cfg_data[5].value != -1) {
    {
#line 675
    tmp___7 = delay_to_eeprom_index(cfg_data[5].value);
#line 675
    eeprom->delay_time = (u8 )tmp___7;
    }
  } else {

  }
#line 678
  if (cfg_data[4].value != -1) {
#line 679
    eeprom->max_tag = (u8 )cfg_data[4].value;
  } else {

  }
#line 682
  id = (u8 )0;
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 682
    __cil_tmp4 = (int )id;
#line 682
    if (__cil_tmp4 < 16) {

    } else {
#line 682
      goto while_break;
    }
    }
#line 683
    if (cfg_data[2].value != -1) {
#line 684
      eeprom->target[id].cfg0 = (u8 )cfg_data[2].value;
    } else {

    }
#line 687
    if (cfg_data[1].value != -1) {
#line 688
      eeprom->target[id].period = (u8 )cfg_data[1].value;
    } else {

    }
#line 682
    __cil_tmp5 = (int )id;
#line 682
    __cil_tmp6 = __cil_tmp5 + 1;
#line 682
    id = (u8 )__cil_tmp6;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 692
  return;
}
}
#line 698 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static unsigned int list_size(struct list_head *head ) 
{ unsigned int count ;
  struct list_head *pos ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
#line 700
  count = 0U;
#line 702
  pos = head->next;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 702
    __cil_tmp4 = (unsigned long )head;
#line 702
    __cil_tmp5 = (unsigned long )pos;
#line 702
    if (__cil_tmp5 != __cil_tmp4) {

    } else {
#line 702
      goto while_break;
    }
    }
#line 703
    count = count + 1U;
#line 702
    pos = pos->next;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 704
  return (count);
}
}
#line 708 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct DeviceCtlBlk *dcb_get_next(struct list_head *head , struct DeviceCtlBlk *pos ) 
{ int use_next ;
  struct DeviceCtlBlk *next ;
  struct DeviceCtlBlk *i ;
  int tmp___7 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  void *__cil_tmp11 ;
  struct list_head  const  *__cil_tmp12 ;
  void *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  struct DeviceCtlBlk *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  struct DeviceCtlBlk *__cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  struct DeviceCtlBlk *__cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  struct list_head *__cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  struct DeviceCtlBlk *__cil_tmp41 ;
  struct list_head *__cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
  {
#line 711
  use_next = 0;
#line 712
  __cil_tmp11 = (void *)0;
#line 712
  next = (struct DeviceCtlBlk *)__cil_tmp11;
#line 715
  __cil_tmp12 = (struct list_head  const  *)head;
#line 715
  tmp___7 = list_empty(__cil_tmp12);
  }
#line 715
  if (tmp___7) {
    {
#line 716
    __cil_tmp13 = (void *)0;
#line 716
    return ((struct DeviceCtlBlk *)__cil_tmp13);
    }
  } else {

  }
#line 719
  __cil_tmp14 = head->next;
#line 719
  __mptr = (struct list_head  const  *)__cil_tmp14;
#line 719
  __cil_tmp15 = (struct DeviceCtlBlk *)0;
#line 719
  __cil_tmp16 = & __cil_tmp15->list;
#line 719
  __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 719
  __cil_tmp18 = (char *)__mptr;
#line 719
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
#line 719
  i = (struct DeviceCtlBlk *)__cil_tmp19;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 719
    __cil_tmp20 = (unsigned long )head;
#line 719
    __cil_tmp21 = & i->list;
#line 719
    __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 719
    if (__cil_tmp22 != __cil_tmp20) {

    } else {
#line 719
      goto while_break;
    }
    }
#line 720
    if (use_next) {
#line 721
      next = i;
#line 722
      goto while_break;
    } else {
      {
#line 723
      __cil_tmp23 = (unsigned long )pos;
#line 723
      __cil_tmp24 = (unsigned long )i;
#line 723
      if (__cil_tmp24 == __cil_tmp23) {
#line 724
        use_next = 1;
      } else {

      }
      }
    }
#line 719
    __cil_tmp25 = i->list.next;
#line 719
    __mptr___0 = (struct list_head  const  *)__cil_tmp25;
#line 719
    __cil_tmp26 = (struct DeviceCtlBlk *)0;
#line 719
    __cil_tmp27 = & __cil_tmp26->list;
#line 719
    __cil_tmp28 = (unsigned int )__cil_tmp27;
#line 719
    __cil_tmp29 = (char *)__mptr___0;
#line 719
    __cil_tmp30 = __cil_tmp29 - __cil_tmp28;
#line 719
    i = (struct DeviceCtlBlk *)__cil_tmp30;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 727
  if (! next) {
#line 728
    __cil_tmp31 = head->next;
#line 728
    __mptr___1 = (struct list_head  const  *)__cil_tmp31;
#line 728
    __cil_tmp32 = (struct DeviceCtlBlk *)0;
#line 728
    __cil_tmp33 = & __cil_tmp32->list;
#line 728
    __cil_tmp34 = (unsigned int )__cil_tmp33;
#line 728
    __cil_tmp35 = (char *)__mptr___1;
#line 728
    __cil_tmp36 = __cil_tmp35 - __cil_tmp34;
#line 728
    i = (struct DeviceCtlBlk *)__cil_tmp36;
    {
#line 728
    while (1) {
      while_continue___0: /* CIL Label */ ;

      {
#line 728
      __cil_tmp37 = (unsigned long )head;
#line 728
      __cil_tmp38 = & i->list;
#line 728
      __cil_tmp39 = (unsigned long )__cil_tmp38;
#line 728
      if (__cil_tmp39 != __cil_tmp37) {

      } else {
#line 728
        goto while_break___0;
      }
      }
#line 729
      next = i;
#line 730
      goto while_break___0;
#line 728
      __cil_tmp40 = i->list.next;
#line 728
      __mptr___2 = (struct list_head  const  *)__cil_tmp40;
#line 728
      __cil_tmp41 = (struct DeviceCtlBlk *)0;
#line 728
      __cil_tmp42 = & __cil_tmp41->list;
#line 728
      __cil_tmp43 = (unsigned int )__cil_tmp42;
#line 728
      __cil_tmp44 = (char *)__mptr___2;
#line 728
      __cil_tmp45 = __cil_tmp44 - __cil_tmp43;
#line 728
      i = (struct DeviceCtlBlk *)__cil_tmp45;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  } else {

  }
#line 733
  return (next);
}
}
#line 737 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void free_tag(struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ u8 __cil_tmp3 ;
  int __cil_tmp4 ;
  u8 __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  u32 __cil_tmp10 ;

  {
  {
#line 739
  __cil_tmp3 = srb->tag_number;
#line 739
  __cil_tmp4 = (int )__cil_tmp3;
#line 739
  if (__cil_tmp4 < 255) {
#line 740
    __cil_tmp5 = srb->tag_number;
#line 740
    __cil_tmp6 = (int )__cil_tmp5;
#line 740
    __cil_tmp7 = 1 << __cil_tmp6;
#line 740
    __cil_tmp8 = ~ __cil_tmp7;
#line 740
    __cil_tmp9 = (unsigned int )__cil_tmp8;
#line 740
    __cil_tmp10 = dcb->tag_mask;
#line 740
    dcb->tag_mask = __cil_tmp10 & __cil_tmp9;
#line 741
    srb->tag_number = (u8 )255;
  } else {

  }
  }
#line 743
  return;
}
}
#line 747 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
__inline static struct ScsiReqBlk *find_cmd(struct scsi_cmnd *cmd , struct list_head *head ) 
{ struct ScsiReqBlk *i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *__cil_tmp6 ;
  struct ScsiReqBlk *__cil_tmp7 ;
  struct list_head *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct list_head *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct scsi_cmnd *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  struct ScsiReqBlk *__cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
#line 751
  __cil_tmp6 = head->next;
#line 751
  __mptr = (struct list_head  const  *)__cil_tmp6;
#line 751
  __cil_tmp7 = (struct ScsiReqBlk *)0;
#line 751
  __cil_tmp8 = & __cil_tmp7->list;
#line 751
  __cil_tmp9 = (unsigned int )__cil_tmp8;
#line 751
  __cil_tmp10 = (char *)__mptr;
#line 751
  __cil_tmp11 = __cil_tmp10 - __cil_tmp9;
#line 751
  i = (struct ScsiReqBlk *)__cil_tmp11;
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 751
    __cil_tmp12 = (unsigned long )head;
#line 751
    __cil_tmp13 = & i->list;
#line 751
    __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 751
    if (__cil_tmp14 != __cil_tmp12) {

    } else {
#line 751
      goto while_break;
    }
    }
    {
#line 752
    __cil_tmp15 = (unsigned long )cmd;
#line 752
    __cil_tmp16 = i->cmd;
#line 752
    __cil_tmp17 = (unsigned long )__cil_tmp16;
#line 752
    if (__cil_tmp17 == __cil_tmp15) {
#line 753
      return (i);
    } else {

    }
    }
#line 751
    __cil_tmp18 = i->list.next;
#line 751
    __mptr___0 = (struct list_head  const  *)__cil_tmp18;
#line 751
    __cil_tmp19 = (struct ScsiReqBlk *)0;
#line 751
    __cil_tmp20 = & __cil_tmp19->list;
#line 751
    __cil_tmp21 = (unsigned int )__cil_tmp20;
#line 751
    __cil_tmp22 = (char *)__mptr___0;
#line 751
    __cil_tmp23 = __cil_tmp22 - __cil_tmp21;
#line 751
    i = (struct ScsiReqBlk *)__cil_tmp23;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 754
  __cil_tmp24 = (void *)0;
#line 754
  return ((struct ScsiReqBlk *)__cil_tmp24);
  }
}
}
#line 758 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct ScsiReqBlk *srb_get_free(struct AdapterCtlBlk *acb ) 
{ struct list_head *head ;
  struct ScsiReqBlk *srb ;
  struct list_head  const  *__mptr ;
  int tmp___7 ;
  void *__cil_tmp6 ;
  struct list_head  const  *__cil_tmp7 ;
  struct list_head *__cil_tmp8 ;
  struct ScsiReqBlk *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;

  {
  {
#line 760
  head = & acb->srb_free_list;
#line 761
  __cil_tmp6 = (void *)0;
#line 761
  srb = (struct ScsiReqBlk *)__cil_tmp6;
#line 763
  __cil_tmp7 = (struct list_head  const  *)head;
#line 763
  tmp___7 = list_empty(__cil_tmp7);
  }
#line 763
  if (tmp___7) {

  } else {
    {
#line 764
    __cil_tmp8 = head->next;
#line 764
    __mptr = (struct list_head  const  *)__cil_tmp8;
#line 764
    __cil_tmp9 = (struct ScsiReqBlk *)0;
#line 764
    __cil_tmp10 = & __cil_tmp9->list;
#line 764
    __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 764
    __cil_tmp12 = (char *)__mptr;
#line 764
    __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 764
    srb = (struct ScsiReqBlk *)__cil_tmp13;
#line 765
    __cil_tmp14 = head->next;
#line 765
    list_del(__cil_tmp14);
    }
    {
#line 766
    while (1) {
      while_continue: /* CIL Label */ ;

#line 766
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 768
  return (srb);
}
}
#line 772 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_free_insert(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ struct list_head *__cil_tmp3 ;
  struct list_head *__cil_tmp4 ;

  {
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;

#line 774
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 775
  __cil_tmp3 = & srb->list;
#line 775
  __cil_tmp4 = & acb->srb_free_list;
#line 775
  list_add_tail(__cil_tmp3, __cil_tmp4);
  }
#line 776
  return;
}
}
#line 779 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_waiting_insert(struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ struct list_head *__cil_tmp3 ;
  struct list_head *__cil_tmp4 ;

  {
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;

#line 782
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 784
  __cil_tmp3 = & srb->list;
#line 784
  __cil_tmp4 = & dcb->srb_waiting_list;
#line 784
  list_add(__cil_tmp3, __cil_tmp4);
  }
#line 785
  return;
}
}
#line 788 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_waiting_append(struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ struct list_head *__cil_tmp3 ;
  struct list_head *__cil_tmp4 ;

  {
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;

#line 791
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 793
  __cil_tmp3 = & srb->list;
#line 793
  __cil_tmp4 = & dcb->srb_waiting_list;
#line 793
  list_add_tail(__cil_tmp3, __cil_tmp4);
  }
#line 794
  return;
}
}
#line 797 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_going_append(struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ struct list_head *__cil_tmp3 ;
  struct list_head *__cil_tmp4 ;

  {
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;

#line 799
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 801
  __cil_tmp3 = & srb->list;
#line 801
  __cil_tmp4 = & dcb->srb_going_list;
#line 801
  list_add_tail(__cil_tmp3, __cil_tmp4);
  }
#line 802
  return;
}
}
#line 805 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_going_remove(struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ struct ScsiReqBlk *i ;
  struct ScsiReqBlk *tmp___7 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head *__cil_tmp8 ;
  struct ScsiReqBlk *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  struct ScsiReqBlk *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct list_head *__cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  struct ScsiReqBlk *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 809
  while (1) {
    while_continue: /* CIL Label */ ;

#line 809
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 812
  __cil_tmp8 = dcb->srb_going_list.next;
#line 812
  __mptr = (struct list_head  const  *)__cil_tmp8;
#line 812
  __cil_tmp9 = (struct ScsiReqBlk *)0;
#line 812
  __cil_tmp10 = & __cil_tmp9->list;
#line 812
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 812
  __cil_tmp12 = (char *)__mptr;
#line 812
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 812
  i = (struct ScsiReqBlk *)__cil_tmp13;
#line 812
  __cil_tmp14 = i->list.next;
#line 812
  __mptr___0 = (struct list_head  const  *)__cil_tmp14;
#line 812
  __cil_tmp15 = (struct ScsiReqBlk *)0;
#line 812
  __cil_tmp16 = & __cil_tmp15->list;
#line 812
  __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 812
  __cil_tmp18 = (char *)__mptr___0;
#line 812
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
#line 812
  tmp___7 = (struct ScsiReqBlk *)__cil_tmp19;
  {
#line 812
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 812
    __cil_tmp20 = & dcb->srb_going_list;
#line 812
    __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 812
    __cil_tmp22 = & i->list;
#line 812
    __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 812
    if (__cil_tmp23 != __cil_tmp21) {

    } else {
#line 812
      goto while_break___0;
    }
    }
    {
#line 813
    __cil_tmp24 = (unsigned long )srb;
#line 813
    __cil_tmp25 = (unsigned long )i;
#line 813
    if (__cil_tmp25 == __cil_tmp24) {
      {
#line 814
      __cil_tmp26 = & srb->list;
#line 814
      list_del(__cil_tmp26);
      }
#line 815
      goto while_break___0;
    } else {

    }
    }
#line 812
    i = tmp___7;
#line 812
    __cil_tmp27 = tmp___7->list.next;
#line 812
    __mptr___1 = (struct list_head  const  *)__cil_tmp27;
#line 812
    __cil_tmp28 = (struct ScsiReqBlk *)0;
#line 812
    __cil_tmp29 = & __cil_tmp28->list;
#line 812
    __cil_tmp30 = (unsigned int )__cil_tmp29;
#line 812
    __cil_tmp31 = (char *)__mptr___1;
#line 812
    __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
#line 812
    tmp___7 = (struct ScsiReqBlk *)__cil_tmp32;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 817
  return;
}
}
#line 820 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_waiting_remove(struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ struct ScsiReqBlk *i ;
  struct ScsiReqBlk *tmp___7 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head *__cil_tmp8 ;
  struct ScsiReqBlk *__cil_tmp9 ;
  struct list_head *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  struct list_head *__cil_tmp14 ;
  struct ScsiReqBlk *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  struct list_head *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  struct list_head *__cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  struct ScsiReqBlk *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 825
  while (1) {
    while_continue: /* CIL Label */ ;

#line 825
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 828
  __cil_tmp8 = dcb->srb_waiting_list.next;
#line 828
  __mptr = (struct list_head  const  *)__cil_tmp8;
#line 828
  __cil_tmp9 = (struct ScsiReqBlk *)0;
#line 828
  __cil_tmp10 = & __cil_tmp9->list;
#line 828
  __cil_tmp11 = (unsigned int )__cil_tmp10;
#line 828
  __cil_tmp12 = (char *)__mptr;
#line 828
  __cil_tmp13 = __cil_tmp12 - __cil_tmp11;
#line 828
  i = (struct ScsiReqBlk *)__cil_tmp13;
#line 828
  __cil_tmp14 = i->list.next;
#line 828
  __mptr___0 = (struct list_head  const  *)__cil_tmp14;
#line 828
  __cil_tmp15 = (struct ScsiReqBlk *)0;
#line 828
  __cil_tmp16 = & __cil_tmp15->list;
#line 828
  __cil_tmp17 = (unsigned int )__cil_tmp16;
#line 828
  __cil_tmp18 = (char *)__mptr___0;
#line 828
  __cil_tmp19 = __cil_tmp18 - __cil_tmp17;
#line 828
  tmp___7 = (struct ScsiReqBlk *)__cil_tmp19;
  {
#line 828
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 828
    __cil_tmp20 = & dcb->srb_waiting_list;
#line 828
    __cil_tmp21 = (unsigned long )__cil_tmp20;
#line 828
    __cil_tmp22 = & i->list;
#line 828
    __cil_tmp23 = (unsigned long )__cil_tmp22;
#line 828
    if (__cil_tmp23 != __cil_tmp21) {

    } else {
#line 828
      goto while_break___0;
    }
    }
    {
#line 829
    __cil_tmp24 = (unsigned long )srb;
#line 829
    __cil_tmp25 = (unsigned long )i;
#line 829
    if (__cil_tmp25 == __cil_tmp24) {
      {
#line 830
      __cil_tmp26 = & srb->list;
#line 830
      list_del(__cil_tmp26);
      }
#line 831
      goto while_break___0;
    } else {

    }
    }
#line 828
    i = tmp___7;
#line 828
    __cil_tmp27 = tmp___7->list.next;
#line 828
    __mptr___1 = (struct list_head  const  *)__cil_tmp27;
#line 828
    __cil_tmp28 = (struct ScsiReqBlk *)0;
#line 828
    __cil_tmp29 = & __cil_tmp28->list;
#line 828
    __cil_tmp30 = (unsigned int )__cil_tmp29;
#line 828
    __cil_tmp31 = (char *)__mptr___1;
#line 828
    __cil_tmp32 = __cil_tmp31 - __cil_tmp30;
#line 828
    tmp___7 = (struct ScsiReqBlk *)__cil_tmp32;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 833
  return;
}
}
#line 836 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_going_to_waiting_move(struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ struct list_head *__cil_tmp3 ;
  struct list_head *__cil_tmp4 ;

  {
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;

#line 839
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 842
  __cil_tmp3 = & srb->list;
#line 842
  __cil_tmp4 = & dcb->srb_waiting_list;
#line 842
  list_move(__cil_tmp3, __cil_tmp4);
  }
#line 843
  return;
}
}
#line 846 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_waiting_to_going_move(struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ struct list_head *__cil_tmp3 ;
  struct list_head *__cil_tmp4 ;

  {
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;

#line 849
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 852
  __cil_tmp3 = & srb->list;
#line 852
  __cil_tmp4 = & dcb->srb_going_list;
#line 852
  list_move(__cil_tmp3, __cil_tmp4);
  }
#line 853
  return;
}
}
#line 861 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct lock_class_key __key___5  ;
#line 857 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void waiting_set_timer(struct AdapterCtlBlk *acb , unsigned long to ) 
{ int tmp___7 ;
  struct timer_list *__cil_tmp4 ;
  struct timer_list  const  *__cil_tmp5 ;
  struct timer_list *__cil_tmp6 ;
  struct Scsi_Host *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  long __cil_tmp10 ;
  unsigned long volatile   __cil_tmp11 ;
  unsigned long volatile   __cil_tmp12 ;
  long __cil_tmp13 ;
  long __cil_tmp14 ;
  struct Scsi_Host *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long volatile   __cil_tmp18 ;
  unsigned long volatile   __cil_tmp19 ;
  unsigned long volatile   __cil_tmp20 ;
  unsigned long volatile   __cil_tmp21 ;
  struct timer_list *__cil_tmp22 ;

  {
  {
#line 859
  __cil_tmp4 = & acb->waiting_timer;
#line 859
  __cil_tmp5 = (struct timer_list  const  *)__cil_tmp4;
#line 859
  tmp___7 = timer_pending(__cil_tmp5);
  }
#line 859
  if (tmp___7) {
#line 860
    return;
  } else {

  }
  {
#line 861
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 861
    __cil_tmp6 = & acb->waiting_timer;
#line 861
    init_timer_key(__cil_tmp6, "&acb->waiting_timer", & __key___5);
    }
#line 861
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 862
  acb->waiting_timer.function = & waiting_timeout;
#line 863
  acb->waiting_timer.data = (unsigned long )acb;
  {
#line 864
  __cil_tmp7 = acb->scsi_host;
#line 864
  __cil_tmp8 = __cil_tmp7->last_reset;
#line 864
  __cil_tmp9 = __cil_tmp8 - 125UL;
#line 864
  __cil_tmp10 = (long )__cil_tmp9;
#line 864
  __cil_tmp11 = (unsigned long volatile   )to;
#line 864
  __cil_tmp12 = jiffies + __cil_tmp11;
#line 864
  __cil_tmp13 = (long )__cil_tmp12;
#line 864
  __cil_tmp14 = __cil_tmp13 - __cil_tmp10;
#line 864
  if (__cil_tmp14 < 0L) {
#line 865
    __cil_tmp15 = acb->scsi_host;
#line 865
    __cil_tmp16 = __cil_tmp15->last_reset;
#line 865
    __cil_tmp17 = __cil_tmp16 - 125UL;
#line 865
    acb->waiting_timer.expires = __cil_tmp17 + 1UL;
  } else {
#line 868
    __cil_tmp18 = (unsigned long volatile   )1;
#line 868
    __cil_tmp19 = (unsigned long volatile   )to;
#line 868
    __cil_tmp20 = jiffies + __cil_tmp19;
#line 868
    __cil_tmp21 = __cil_tmp20 + __cil_tmp18;
#line 868
    acb->waiting_timer.expires = (unsigned long )__cil_tmp21;
  }
  }
  {
#line 869
  __cil_tmp22 = & acb->waiting_timer;
#line 869
  add_timer(__cil_tmp22);
  }
#line 870
  return;
}
}
#line 874 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void waiting_process_next(struct AdapterCtlBlk *acb ) 
{ struct DeviceCtlBlk *start ;
  struct DeviceCtlBlk *pos ;
  struct DeviceCtlBlk *dcb ;
  struct ScsiReqBlk *srb ;
  struct list_head *dcb_list_head ;
  int tmp___7 ;
  int tmp___8 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head *waiting_list_head ;
  struct list_head  const  *__mptr___2 ;
  u8 tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  void *__cil_tmp17 ;
  u8 __cil_tmp18 ;
  int __cil_tmp19 ;
  struct timer_list *__cil_tmp20 ;
  struct timer_list  const  *__cil_tmp21 ;
  struct timer_list *__cil_tmp22 ;
  struct list_head  const  *__cil_tmp23 ;
  struct list_head *__cil_tmp24 ;
  struct DeviceCtlBlk *__cil_tmp25 ;
  struct list_head *__cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct DeviceCtlBlk *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  struct list_head *__cil_tmp36 ;
  struct DeviceCtlBlk *__cil_tmp37 ;
  struct list_head *__cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  struct list_head *__cil_tmp42 ;
  struct DeviceCtlBlk *__cil_tmp43 ;
  struct list_head *__cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  struct DeviceCtlBlk *__cil_tmp48 ;
  struct list_head  const  *__cil_tmp49 ;
  struct list_head *__cil_tmp50 ;
  u16 __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  struct list_head *__cil_tmp53 ;
  struct ScsiReqBlk *__cil_tmp54 ;
  struct list_head *__cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;

  {
#line 876
  __cil_tmp17 = (void *)0;
#line 876
  start = (struct DeviceCtlBlk *)__cil_tmp17;
#line 880
  dcb_list_head = & acb->dcb_list;
#line 882
  if (acb->active_dcb) {
#line 884
    return;
  } else {
    {
#line 882
    __cil_tmp18 = acb->acb_flag;
#line 882
    __cil_tmp19 = (int )__cil_tmp18;
#line 882
    if (__cil_tmp19 & 7) {
#line 884
      return;
    } else {

    }
    }
  }
  {
#line 886
  __cil_tmp20 = & acb->waiting_timer;
#line 886
  __cil_tmp21 = (struct timer_list  const  *)__cil_tmp20;
#line 886
  tmp___7 = timer_pending(__cil_tmp21);
  }
#line 886
  if (tmp___7) {
    {
#line 887
    __cil_tmp22 = & acb->waiting_timer;
#line 887
    del_timer(__cil_tmp22);
    }
  } else {

  }
  {
#line 889
  __cil_tmp23 = (struct list_head  const  *)dcb_list_head;
#line 889
  tmp___8 = list_empty(__cil_tmp23);
  }
#line 889
  if (tmp___8) {
#line 890
    return;
  } else {

  }
#line 896
  __cil_tmp24 = dcb_list_head->next;
#line 896
  __mptr = (struct list_head  const  *)__cil_tmp24;
#line 896
  __cil_tmp25 = (struct DeviceCtlBlk *)0;
#line 896
  __cil_tmp26 = & __cil_tmp25->list;
#line 896
  __cil_tmp27 = (unsigned int )__cil_tmp26;
#line 896
  __cil_tmp28 = (char *)__mptr;
#line 896
  __cil_tmp29 = __cil_tmp28 - __cil_tmp27;
#line 896
  dcb = (struct DeviceCtlBlk *)__cil_tmp29;
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 896
    __cil_tmp30 = (unsigned long )dcb_list_head;
#line 896
    __cil_tmp31 = & dcb->list;
#line 896
    __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 896
    if (__cil_tmp32 != __cil_tmp30) {

    } else {
#line 896
      goto while_break;
    }
    }
    {
#line 897
    __cil_tmp33 = acb->dcb_run_robin;
#line 897
    __cil_tmp34 = (unsigned long )__cil_tmp33;
#line 897
    __cil_tmp35 = (unsigned long )dcb;
#line 897
    if (__cil_tmp35 == __cil_tmp34) {
#line 898
      start = dcb;
#line 899
      goto while_break;
    } else {

    }
    }
#line 896
    __cil_tmp36 = dcb->list.next;
#line 896
    __mptr___0 = (struct list_head  const  *)__cil_tmp36;
#line 896
    __cil_tmp37 = (struct DeviceCtlBlk *)0;
#line 896
    __cil_tmp38 = & __cil_tmp37->list;
#line 896
    __cil_tmp39 = (unsigned int )__cil_tmp38;
#line 896
    __cil_tmp40 = (char *)__mptr___0;
#line 896
    __cil_tmp41 = __cil_tmp40 - __cil_tmp39;
#line 896
    dcb = (struct DeviceCtlBlk *)__cil_tmp41;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 901
  if (! start) {
#line 903
    __cil_tmp42 = dcb_list_head->next;
#line 903
    __mptr___1 = (struct list_head  const  *)__cil_tmp42;
#line 903
    __cil_tmp43 = (struct DeviceCtlBlk *)0;
#line 903
    __cil_tmp44 = & __cil_tmp43->list;
#line 903
    __cil_tmp45 = (unsigned int )__cil_tmp44;
#line 903
    __cil_tmp46 = (char *)__mptr___1;
#line 903
    __cil_tmp47 = __cil_tmp46 - __cil_tmp45;
#line 903
    start = (struct DeviceCtlBlk *)__cil_tmp47;
#line 904
    acb->dcb_run_robin = start;
  } else {

  }
#line 912
  pos = start;
  {
#line 913
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 914
    waiting_list_head = & pos->srb_waiting_list;
#line 917
    __cil_tmp48 = acb->dcb_run_robin;
#line 917
    acb->dcb_run_robin = dcb_get_next(dcb_list_head, __cil_tmp48);
#line 920
    __cil_tmp49 = (struct list_head  const  *)waiting_list_head;
#line 920
    tmp___10 = list_empty(__cil_tmp49);
    }
#line 920
    if (tmp___10) {
      {
#line 923
      pos = dcb_get_next(dcb_list_head, pos);
      }
    } else {
      {
#line 920
      __cil_tmp50 = & pos->srb_going_list;
#line 920
      tmp___11 = list_size(__cil_tmp50);
      }
      {
#line 920
      __cil_tmp51 = pos->max_command;
#line 920
      __cil_tmp52 = (unsigned int )__cil_tmp51;
#line 920
      if (__cil_tmp52 <= tmp___11) {
        {
#line 923
        pos = dcb_get_next(dcb_list_head, pos);
        }
      } else {
        {
#line 925
        __cil_tmp53 = waiting_list_head->next;
#line 925
        __mptr___2 = (struct list_head  const  *)__cil_tmp53;
#line 925
        __cil_tmp54 = (struct ScsiReqBlk *)0;
#line 925
        __cil_tmp55 = & __cil_tmp54->list;
#line 925
        __cil_tmp56 = (unsigned int )__cil_tmp55;
#line 925
        __cil_tmp57 = (char *)__mptr___2;
#line 925
        __cil_tmp58 = __cil_tmp57 - __cil_tmp56;
#line 925
        srb = (struct ScsiReqBlk *)__cil_tmp58;
#line 929
        tmp___9 = start_scsi(acb, pos, srb);
        }
#line 929
        if (tmp___9) {
          {
#line 932
          waiting_set_timer(acb, 5UL);
          }
        } else {
          {
#line 930
          srb_waiting_to_going_move(pos, srb);
          }
        }
#line 933
        goto while_break___0;
      }
      }
    }
    {
#line 913
    __cil_tmp59 = (unsigned long )start;
#line 913
    __cil_tmp60 = (unsigned long )pos;
#line 913
    if (__cil_tmp60 != __cil_tmp59) {

    } else {
#line 913
      goto while_break___0;
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 936
  return;
}
}
#line 940 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void waiting_timeout(unsigned long ptr ) 
{ unsigned long flags ;
  struct AdapterCtlBlk *acb ;
  raw_spinlock_t *tmp___7 ;
  struct Scsi_Host *__cil_tmp5 ;
  spinlock_t *__cil_tmp6 ;
  struct Scsi_Host *__cil_tmp7 ;
  spinlock_t *__cil_tmp8 ;

  {
#line 943
  acb = (struct AdapterCtlBlk *)ptr;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;

#line 944
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 946
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 946
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 946
      __cil_tmp5 = acb->scsi_host;
#line 946
      __cil_tmp6 = __cil_tmp5->host_lock;
#line 946
      tmp___7 = spinlock_check(__cil_tmp6);
#line 946
      flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 946
      goto while_break___1;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: ;
#line 946
    goto while_break___0;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 947
  waiting_process_next(acb);
#line 948
  __cil_tmp7 = acb->scsi_host;
#line 948
  __cil_tmp8 = __cil_tmp7->host_lock;
#line 948
  spin_unlock_irqrestore(__cil_tmp8, flags);
  }
#line 949
  return;
}
}
#line 953 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct DeviceCtlBlk *find_dcb(struct AdapterCtlBlk *acb , u8 id , u8 lun ) 
{ 

  {
#line 955
  return (acb->children[id][lun]);
}
}
#line 960 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void send_srb(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ struct DeviceCtlBlk *dcb ;
  unsigned int tmp___7 ;
  u8 tmp___8 ;
  struct list_head *__cil_tmp6 ;
  u16 __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  u8 __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 962
  dcb = srb->dcb;
#line 964
  __cil_tmp6 = & dcb->srb_going_list;
#line 964
  tmp___7 = list_size(__cil_tmp6);
  }
  {
#line 964
  __cil_tmp7 = dcb->max_command;
#line 964
  __cil_tmp8 = (unsigned int )__cil_tmp7;
#line 964
  if (__cil_tmp8 <= tmp___7) {
    {
#line 967
    srb_waiting_append(dcb, srb);
#line 968
    waiting_process_next(acb);
    }
#line 969
    return;
  } else
#line 964
  if (acb->active_dcb) {
    {
#line 967
    srb_waiting_append(dcb, srb);
#line 968
    waiting_process_next(acb);
    }
#line 969
    return;
  } else {
    {
#line 964
    __cil_tmp9 = acb->acb_flag;
#line 964
    __cil_tmp10 = (int )__cil_tmp9;
#line 964
    if (__cil_tmp10 & 7) {
      {
#line 967
      srb_waiting_append(dcb, srb);
#line 968
      waiting_process_next(acb);
      }
#line 969
      return;
    } else {

    }
    }
  }
  }
  {
#line 972
  tmp___8 = start_scsi(acb, dcb, srb);
  }
#line 972
  if (tmp___8) {
    {
#line 975
    srb_waiting_insert(dcb, srb);
#line 976
    waiting_set_timer(acb, 5UL);
    }
  } else {
    {
#line 973
    srb_going_append(dcb, srb);
    }
  }
#line 978
  return;
}
}
#line 981 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void build_srb(struct scsi_cmnd *cmd , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ int nseg ;
  enum dma_data_direction dir ;
  long tmp___7 ;
  int i ;
  u32 reqlen ;
  unsigned int tmp___8 ;
  struct scatterlist *sg ;
  struct SGentry *sgp ;
  u32 busaddr ;
  u32 seglen ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  u8 __cil_tmp19 ;
  int __cil_tmp20 ;
  dma_addr_t __cil_tmp21 ;
  struct SGentry *__cil_tmp22 ;
  struct SGentry *__cil_tmp23 ;
  size_t __cil_tmp24 ;
  size_t __cil_tmp25 ;
  u8 __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  size_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  size_t __cil_tmp31 ;
  size_t __cil_tmp32 ;
  size_t __cil_tmp33 ;
  u32 __cil_tmp34 ;
  size_t __cil_tmp35 ;
  size_t __cil_tmp36 ;
  u8 __cil_tmp37 ;
  int __cil_tmp38 ;
  size_t __cil_tmp39 ;
  size_t __cil_tmp40 ;
  u32 __cil_tmp41 ;
  struct AdapterCtlBlk *__cil_tmp42 ;
  struct pci_dev *__cil_tmp43 ;
  struct SGentry *__cil_tmp44 ;
  void *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;

  {
#line 985
  dir = cmd->sc_data_direction;
  {
#line 986
  while (1) {
    while_continue: /* CIL Label */ ;

#line 986
    goto while_break;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: 
  {
#line 989
  srb->dcb = dcb;
#line 990
  srb->cmd = cmd;
#line 991
  srb->sg_count = (u8 )0;
#line 992
  srb->total_xfer_length = (size_t )0;
#line 993
  srb->sg_bus_addr = (dma_addr_t )0;
#line 994
  srb->sg_index = (u8 )0;
#line 995
  srb->adapter_status = (u8 )0;
#line 996
  srb->target_status = (u8 )0;
#line 997
  srb->msg_count = (u8 )0;
#line 998
  srb->status = (u8 )0;
#line 999
  srb->flag = (u8 )0;
#line 1000
  srb->state = (u16 )0;
#line 1001
  srb->retry_count = (u8 )0;
#line 1002
  srb->tag_number = (u8 )255;
#line 1003
  srb->scsi_phase = (u8 )5;
#line 1004
  srb->end_message = (u8 )0;
#line 1006
  nseg = scsi_dma_map(cmd);
  }
  {
#line 1007
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1007
    __cil_tmp14 = nseg < 0;
#line 1007
    __cil_tmp15 = ! __cil_tmp14;
#line 1007
    __cil_tmp16 = ! __cil_tmp15;
#line 1007
    __cil_tmp17 = (long )__cil_tmp16;
#line 1007
    tmp___7 = __builtin_expect(__cil_tmp17, 0L);
    }
#line 1007
    if (tmp___7) {
      {
#line 1007
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1007
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"),
                             "i" (1007), "i" (12UL));
        {
#line 1007
        while (1) {
          while_continue___2: /* CIL Label */ ;

        }
        while_break___10: /* CIL Label */ ;
        }

#line 1007
        goto while_break___1;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: ;
    } else {

    }
#line 1007
    goto while_break___0;
  }
  while_break___8: /* CIL Label */ ;
  }

  while_break___0: ;
  {
#line 1009
  __cil_tmp18 = (unsigned int )dir;
#line 1009
  if (__cil_tmp18 == 3U) {
#line 1009
    goto _L;
  } else
#line 1009
  if (! nseg) {
    _L: 
    {
#line 1010
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1010
      goto while_break___3;
    }
    while_break___11: /* CIL Label */ ;
    }

    while_break___3: ;
  } else {
    {
#line 1016
    tmp___8 = scsi_bufflen(cmd);
#line 1016
    reqlen = tmp___8;
#line 1018
    sgp = srb->segment_x;
#line 1020
    srb->sg_count = (u8 )nseg;
    }
    {
#line 1022
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1022
      goto while_break___4;
    }
    while_break___12: /* CIL Label */ ;
    }

    while_break___4: 
    {
#line 1027
    i = 0;
#line 1027
    sg = scsi_sglist(cmd);
    }
    {
#line 1027
    while (1) {
      while_continue___5: /* CIL Label */ ;

      {
#line 1027
      __cil_tmp19 = srb->sg_count;
#line 1027
      __cil_tmp20 = (int )__cil_tmp19;
#line 1027
      if (i < __cil_tmp20) {

      } else {
#line 1027
        goto while_break___5;
      }
      }
      {
#line 1028
      __cil_tmp21 = sg->dma_address;
#line 1028
      busaddr = (u32 )__cil_tmp21;
#line 1029
      seglen = sg->length;
#line 1030
      __cil_tmp22 = sgp + i;
#line 1030
      __cil_tmp22->address = busaddr;
#line 1031
      __cil_tmp23 = sgp + i;
#line 1031
      __cil_tmp23->length = seglen;
#line 1032
      __cil_tmp24 = (size_t )seglen;
#line 1032
      __cil_tmp25 = srb->total_xfer_length;
#line 1032
      srb->total_xfer_length = __cil_tmp25 + __cil_tmp24;
#line 1027
      i = i + 1;
#line 1027
      sg = sg_next(sg);
      }
    }
    while_break___13: /* CIL Label */ ;
    }

    while_break___5: 
#line 1034
    __cil_tmp26 = srb->sg_count;
#line 1034
    __cil_tmp27 = (int )__cil_tmp26;
#line 1034
    __cil_tmp28 = __cil_tmp27 - 1;
#line 1034
    sgp = sgp + __cil_tmp28;
    {
#line 1040
    __cil_tmp29 = (size_t )reqlen;
#line 1040
    __cil_tmp30 = srb->total_xfer_length;
#line 1040
    if (__cil_tmp30 > __cil_tmp29) {
#line 1041
      __cil_tmp31 = (size_t )reqlen;
#line 1041
      __cil_tmp32 = srb->total_xfer_length;
#line 1041
      __cil_tmp33 = __cil_tmp32 - __cil_tmp31;
#line 1041
      __cil_tmp34 = sgp->length;
#line 1041
      __cil_tmp35 = (size_t )__cil_tmp34;
#line 1041
      __cil_tmp36 = __cil_tmp35 - __cil_tmp33;
#line 1041
      sgp->length = (u32 )__cil_tmp36;
#line 1042
      srb->total_xfer_length = (size_t )reqlen;
    } else {

    }
    }
    {
#line 1046
    __cil_tmp37 = dcb->sync_period;
#line 1046
    __cil_tmp38 = (int )__cil_tmp37;
#line 1046
    if (__cil_tmp38 & 16) {
      {
#line 1046
      __cil_tmp39 = srb->total_xfer_length;
#line 1046
      if (__cil_tmp39 % 2UL) {
#line 1048
        __cil_tmp40 = srb->total_xfer_length;
#line 1048
        srb->total_xfer_length = __cil_tmp40 + 1UL;
#line 1049
        __cil_tmp41 = sgp->length;
#line 1049
        sgp->length = __cil_tmp41 + 1U;
      } else {

      }
      }
    } else {

    }
    }
    {
#line 1052
    __cil_tmp42 = dcb->acb;
#line 1052
    __cil_tmp43 = __cil_tmp42->dev;
#line 1052
    __cil_tmp44 = srb->segment_x;
#line 1052
    __cil_tmp45 = (void *)__cil_tmp44;
#line 1052
    __cil_tmp46 = 8UL * 64UL;
#line 1052
    srb->sg_bus_addr = pci_map_single(__cil_tmp43, __cil_tmp45, __cil_tmp46, 1);
    }
    {
#line 1057
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1057
      goto while_break___6;
    }
    while_break___14: /* CIL Label */ ;
    }

    while_break___6: ;
  }
  }
#line 1061
  srb->request_length = srb->total_xfer_length;
#line 1062
  return;
}
}
#line 1084 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_queue_command_lck(struct scsi_cmnd *cmd , void (*done)(struct scsi_cmnd * ) ) 
{ struct DeviceCtlBlk *dcb ;
  struct ScsiReqBlk *srb ;
  struct AdapterCtlBlk *acb ;
  int tmp___7 ;
  struct scsi_device *__cil_tmp7 ;
  struct Scsi_Host *__cil_tmp8 ;
  unsigned long *__cil_tmp9 ;
  struct Scsi_Host *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  struct scsi_device *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  struct Scsi_Host *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  struct scsi_device *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  struct scsi_device *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  struct scsi_device *__cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  u8 __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  struct scsi_device *__cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  struct scsi_device *__cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  struct scsi_device *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  u8 __cil_tmp32 ;
  struct scsi_device *__cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  u8 __cil_tmp35 ;
  struct scsi_device *__cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  struct scsi_device *__cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  struct list_head *__cil_tmp40 ;
  struct list_head  const  *__cil_tmp41 ;

  {
#line 1088
  __cil_tmp7 = cmd->device;
#line 1088
  __cil_tmp8 = __cil_tmp7->host;
#line 1088
  __cil_tmp9 = & __cil_tmp8->hostdata[0];
#line 1088
  acb = (struct AdapterCtlBlk *)__cil_tmp9;
  {
#line 1090
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1090
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
#line 1094
  cmd->result = 4 << 16;
  {
#line 1097
  __cil_tmp10 = acb->scsi_host;
#line 1097
  __cil_tmp11 = __cil_tmp10->max_id;
#line 1097
  __cil_tmp12 = cmd->device;
#line 1097
  __cil_tmp13 = __cil_tmp12->id;
#line 1097
  if (__cil_tmp13 >= __cil_tmp11) {
#line 1100
    goto complete;
  } else {
    {
#line 1097
    __cil_tmp14 = acb->scsi_host;
#line 1097
    __cil_tmp15 = __cil_tmp14->max_lun;
#line 1097
    __cil_tmp16 = cmd->device;
#line 1097
    __cil_tmp17 = __cil_tmp16->lun;
#line 1097
    if (__cil_tmp17 >= __cil_tmp15) {
#line 1100
      goto complete;
    } else {
      {
#line 1097
      __cil_tmp18 = cmd->device;
#line 1097
      __cil_tmp19 = __cil_tmp18->lun;
#line 1097
      if (__cil_tmp19 > 31U) {
#line 1100
        goto complete;
      } else {

      }
      }
    }
    }
  }
  }
  {
#line 1104
  __cil_tmp20 = cmd->device;
#line 1104
  __cil_tmp21 = __cil_tmp20->lun;
#line 1104
  __cil_tmp22 = 1 << __cil_tmp21;
#line 1104
  __cil_tmp23 = acb->dcb_map[(cmd->device)->id];
#line 1104
  __cil_tmp24 = (int )__cil_tmp23;
#line 1104
  __cil_tmp25 = __cil_tmp24 & __cil_tmp22;
#line 1104
  if (! __cil_tmp25) {
    {
#line 1105
    __cil_tmp26 = cmd->device;
#line 1105
    __cil_tmp27 = __cil_tmp26->id;
#line 1105
    __cil_tmp28 = cmd->device;
#line 1105
    __cil_tmp29 = __cil_tmp28->lun;
#line 1105
    printk("<6>dc395x: queue_command: Ignore target <%02i-%i>\n", __cil_tmp27, __cil_tmp29);
    }
#line 1107
    goto complete;
  } else {

  }
  }
  {
#line 1111
  __cil_tmp30 = cmd->device;
#line 1111
  __cil_tmp31 = __cil_tmp30->id;
#line 1111
  __cil_tmp32 = (u8 )__cil_tmp31;
#line 1111
  __cil_tmp33 = cmd->device;
#line 1111
  __cil_tmp34 = __cil_tmp33->lun;
#line 1111
  __cil_tmp35 = (u8 )__cil_tmp34;
#line 1111
  dcb = find_dcb(acb, __cil_tmp32, __cil_tmp35);
  }
#line 1112
  if (! dcb) {
    {
#line 1114
    __cil_tmp36 = cmd->device;
#line 1114
    __cil_tmp37 = __cil_tmp36->id;
#line 1114
    __cil_tmp38 = cmd->device;
#line 1114
    __cil_tmp39 = __cil_tmp38->lun;
#line 1114
    printk("<3>dc395x: queue_command: No such device <%02i-%i>", __cil_tmp37, __cil_tmp39);
    }
#line 1116
    goto complete;
  } else {

  }
  {
#line 1120
  cmd->scsi_done = done;
#line 1121
  cmd->result = 0;
#line 1123
  srb = srb_get_free(acb);
  }
#line 1124
  if (! srb) {
    {
#line 1130
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1130
      goto while_break___0;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: ;
#line 1131
    return (1);
  } else {

  }
  {
#line 1134
  build_srb(cmd, dcb, srb);
#line 1136
  __cil_tmp40 = & dcb->srb_waiting_list;
#line 1136
  __cil_tmp41 = (struct list_head  const  *)__cil_tmp40;
#line 1136
  tmp___7 = list_empty(__cil_tmp41);
  }
#line 1136
  if (tmp___7) {
    {
#line 1142
    send_srb(acb, srb);
    }
  } else {
    {
#line 1138
    srb_waiting_append(dcb, srb);
#line 1139
    waiting_process_next(acb);
    }
  }
  {
#line 1144
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1144
    goto while_break___1;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___1: ;
#line 1145
  return (0);
  complete: 
  {
#line 1154
  (*done)(cmd);
  }
#line 1155
  return (0);
}
}
#line 1158 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_queue_command(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) 
{ unsigned long irq_flags ;
  int rc ;
  raw_spinlock_t *tmp___7 ;
  spinlock_t *__cil_tmp6 ;
  void (*__cil_tmp7)(struct scsi_cmnd * ) ;
  spinlock_t *__cil_tmp8 ;

  {
  {
#line 1158
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 1158
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1158
      __cil_tmp6 = shost->host_lock;
#line 1158
      tmp___7 = spinlock_check(__cil_tmp6);
#line 1158
      irq_flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 1158
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
#line 1158
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1158
  scsi_cmd_get_serial(shost, cmd);
#line 1158
  __cil_tmp7 = cmd->scsi_done;
#line 1158
  rc = dc395x_queue_command_lck(cmd, __cil_tmp7);
#line 1158
  __cil_tmp8 = shost->host_lock;
#line 1158
  spin_unlock_irqrestore(__cil_tmp8, irq_flags);
  }
#line 1158
  return (rc);
}
}
#line 1163 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_bios_param(struct scsi_device *sdev , struct block_device *bdev ,
                             sector_t capacity , int *info ) 
{ int tmp___7 ;

  {
  {
#line 1187
  tmp___7 = scsicam_bios_param(bdev, capacity, info);
  }
#line 1187
  return (tmp___7);
}
}
#line 1192 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void dump_register_info(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb ,
                               struct ScsiReqBlk *srb ) 
{ u16 pstat ;
  struct pci_dev *dev ;
  char const   *tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  unsigned short tmp___11 ;
  unsigned char tmp___12 ;
  unsigned int tmp___13 ;
  unsigned char tmp___14 ;
  unsigned char tmp___15 ;
  unsigned char tmp___16 ;
  unsigned char tmp___17 ;
  unsigned char tmp___18 ;
  unsigned char tmp___19 ;
  unsigned short tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned short tmp___25 ;
  unsigned char tmp___26 ;
  unsigned char tmp___27 ;
  unsigned char tmp___28 ;
  unsigned char tmp___29 ;
  unsigned short tmp___30 ;
  unsigned char tmp___31 ;
  unsigned char tmp___32 ;
  unsigned char tmp___33 ;
  struct scsi_cmnd *__cil_tmp33 ;
  struct scsi_cmnd *__cil_tmp34 ;
  struct scsi_cmnd *__cil_tmp35 ;
  struct scsi_cmnd *__cil_tmp36 ;
  unsigned char *__cil_tmp37 ;
  unsigned char *__cil_tmp38 ;
  unsigned char __cil_tmp39 ;
  int __cil_tmp40 ;
  struct scsi_cmnd *__cil_tmp41 ;
  struct scsi_device *__cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  struct scsi_cmnd *__cil_tmp44 ;
  struct scsi_device *__cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  struct SGentry *__cil_tmp47 ;
  u8 __cil_tmp48 ;
  int __cil_tmp49 ;
  u8 __cil_tmp50 ;
  int __cil_tmp51 ;
  size_t __cil_tmp52 ;
  u16 __cil_tmp53 ;
  int __cil_tmp54 ;
  u8 __cil_tmp55 ;
  int __cil_tmp56 ;
  u8 __cil_tmp57 ;
  int __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  int __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  int __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  int __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  int __cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  int __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  int __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  int __cil_tmp79 ;
  unsigned long __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  int __cil_tmp82 ;
  unsigned long __cil_tmp83 ;
  unsigned long __cil_tmp84 ;
  int __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  int __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  int __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  int __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  int __cil_tmp112 ;
  unsigned long __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  int __cil_tmp115 ;
  unsigned long __cil_tmp116 ;
  unsigned long __cil_tmp117 ;
  int __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  unsigned long __cil_tmp120 ;
  int __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  unsigned long __cil_tmp123 ;
  int __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  int __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  int __cil_tmp130 ;
  unsigned long __cil_tmp131 ;
  unsigned long __cil_tmp132 ;
  int __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  int __cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  unsigned long __cil_tmp138 ;
  int __cil_tmp139 ;
  int __cil_tmp140 ;
  int __cil_tmp141 ;
  int __cil_tmp142 ;
  int __cil_tmp143 ;
  int __cil_tmp144 ;
  int __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  int __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  int __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  int __cil_tmp154 ;
  int __cil_tmp155 ;
  int __cil_tmp156 ;
  int __cil_tmp157 ;
  int __cil_tmp158 ;

  {
  {
#line 1196
  dev = acb->dev;
#line 1197
  pci_read_config_word(dev, 6, & pstat);
  }
#line 1198
  if (! dcb) {
#line 1199
    dcb = acb->active_dcb;
  } else {

  }
#line 1200
  if (! srb) {
#line 1200
    if (dcb) {
#line 1201
      srb = dcb->active_srb;
    } else {

    }
  } else {

  }
#line 1202
  if (srb) {
    {
#line 1203
    __cil_tmp33 = srb->cmd;
#line 1203
    if (! __cil_tmp33) {
      {
#line 1204
      __cil_tmp34 = srb->cmd;
#line 1204
      printk("<6>dc395x: dump: srb=%p cmd=%p OOOPS!\n", srb, __cil_tmp34);
      }
    } else {
      {
#line 1207
      __cil_tmp35 = srb->cmd;
#line 1207
      __cil_tmp36 = srb->cmd;
#line 1207
      __cil_tmp37 = __cil_tmp36->cmnd;
#line 1207
      __cil_tmp38 = __cil_tmp37 + 0;
#line 1207
      __cil_tmp39 = *__cil_tmp38;
#line 1207
      __cil_tmp40 = (int )__cil_tmp39;
#line 1207
      __cil_tmp41 = srb->cmd;
#line 1207
      __cil_tmp42 = __cil_tmp41->device;
#line 1207
      __cil_tmp43 = __cil_tmp42->id;
#line 1207
      __cil_tmp44 = srb->cmd;
#line 1207
      __cil_tmp45 = __cil_tmp44->device;
#line 1207
      __cil_tmp46 = __cil_tmp45->lun;
#line 1207
      printk("<6>dc395x: dump: srb=%p cmd=%p cmnd=0x%02x <%02i-%i>\n", srb, __cil_tmp35,
             __cil_tmp40, __cil_tmp43, __cil_tmp46);
      }
    }
    }
    {
#line 1212
    __cil_tmp47 = srb->segment_x;
#line 1212
    __cil_tmp48 = srb->sg_count;
#line 1212
    __cil_tmp49 = (int )__cil_tmp48;
#line 1212
    __cil_tmp50 = srb->sg_index;
#line 1212
    __cil_tmp51 = (int )__cil_tmp50;
#line 1212
    __cil_tmp52 = srb->total_xfer_length;
#line 1212
    printk("  sglist=%p cnt=%i idx=%i len=%zu\n", __cil_tmp47, __cil_tmp49, __cil_tmp51,
           __cil_tmp52);
    }
#line 1215
    if (acb->active_dcb) {
#line 1215
      tmp___7 = "";
    } else {
#line 1215
      tmp___7 = "not";
    }
    {
#line 1215
    __cil_tmp53 = srb->state;
#line 1215
    __cil_tmp54 = (int )__cil_tmp53;
#line 1215
    __cil_tmp55 = srb->status;
#line 1215
    __cil_tmp56 = (int )__cil_tmp55;
#line 1215
    __cil_tmp57 = srb->scsi_phase;
#line 1215
    __cil_tmp58 = (int )__cil_tmp57;
#line 1215
    printk("  state=0x%04x status=0x%02x phase=0x%02x (%sconn.)\n", __cil_tmp54, __cil_tmp56,
           __cil_tmp58, tmp___7);
    }
  } else {

  }
  {
#line 1219
  __cil_tmp59 = acb->io_port_base;
#line 1219
  __cil_tmp60 = __cil_tmp59 + 145UL;
#line 1219
  __cil_tmp61 = (int )__cil_tmp60;
#line 1219
  tmp___8 = inb(__cil_tmp61);
#line 1219
  __cil_tmp62 = acb->io_port_base;
#line 1219
  __cil_tmp63 = __cil_tmp62 + 144UL;
#line 1219
  __cil_tmp64 = (int )__cil_tmp63;
#line 1219
  tmp___9 = inb(__cil_tmp64);
#line 1219
  __cil_tmp65 = acb->io_port_base;
#line 1219
  __cil_tmp66 = __cil_tmp65 + 143UL;
#line 1219
  __cil_tmp67 = (int )__cil_tmp66;
#line 1219
  tmp___10 = inb(__cil_tmp67);
#line 1219
  __cil_tmp68 = acb->io_port_base;
#line 1219
  __cil_tmp69 = __cil_tmp68 + 141UL;
#line 1219
  __cil_tmp70 = (int )__cil_tmp69;
#line 1219
  tmp___11 = inw(__cil_tmp70);
#line 1219
  __cil_tmp71 = acb->io_port_base;
#line 1219
  __cil_tmp72 = __cil_tmp71 + 140UL;
#line 1219
  __cil_tmp73 = (int )__cil_tmp72;
#line 1219
  tmp___12 = inb(__cil_tmp73);
#line 1219
  __cil_tmp74 = acb->io_port_base;
#line 1219
  __cil_tmp75 = __cil_tmp74 + 136UL;
#line 1219
  __cil_tmp76 = (int )__cil_tmp75;
#line 1219
  tmp___13 = inl(__cil_tmp76);
#line 1219
  __cil_tmp77 = acb->io_port_base;
#line 1219
  __cil_tmp78 = __cil_tmp77 + 135UL;
#line 1219
  __cil_tmp79 = (int )__cil_tmp78;
#line 1219
  tmp___14 = inb(__cil_tmp79);
#line 1219
  __cil_tmp80 = acb->io_port_base;
#line 1219
  __cil_tmp81 = __cil_tmp80 + 134UL;
#line 1219
  __cil_tmp82 = (int )__cil_tmp81;
#line 1219
  tmp___15 = inb(__cil_tmp82);
#line 1219
  __cil_tmp83 = acb->io_port_base;
#line 1219
  __cil_tmp84 = __cil_tmp83 + 133UL;
#line 1219
  __cil_tmp85 = (int )__cil_tmp84;
#line 1219
  tmp___16 = inb(__cil_tmp85);
#line 1219
  __cil_tmp86 = acb->io_port_base;
#line 1219
  __cil_tmp87 = __cil_tmp86 + 132UL;
#line 1219
  __cil_tmp88 = (int )__cil_tmp87;
#line 1219
  tmp___17 = inb(__cil_tmp88);
#line 1219
  __cil_tmp89 = acb->io_port_base;
#line 1219
  __cil_tmp90 = __cil_tmp89 + 131UL;
#line 1219
  __cil_tmp91 = (int )__cil_tmp90;
#line 1219
  tmp___18 = inb(__cil_tmp91);
#line 1219
  __cil_tmp92 = acb->io_port_base;
#line 1219
  __cil_tmp93 = __cil_tmp92 + 130UL;
#line 1219
  __cil_tmp94 = (int )__cil_tmp93;
#line 1219
  tmp___19 = inb(__cil_tmp94);
#line 1219
  __cil_tmp95 = acb->io_port_base;
#line 1219
  __cil_tmp96 = __cil_tmp95 + 128UL;
#line 1219
  __cil_tmp97 = (int )__cil_tmp96;
#line 1219
  tmp___20 = inw(__cil_tmp97);
#line 1219
  __cil_tmp98 = (int )tmp___20;
#line 1219
  __cil_tmp99 = (int )tmp___19;
#line 1219
  __cil_tmp100 = (int )tmp___18;
#line 1219
  __cil_tmp101 = (int )tmp___17;
#line 1219
  __cil_tmp102 = (int )tmp___16;
#line 1219
  __cil_tmp103 = (int )tmp___15;
#line 1219
  __cil_tmp104 = (int )tmp___14;
#line 1219
  __cil_tmp105 = (int )tmp___12;
#line 1219
  __cil_tmp106 = (int )tmp___11;
#line 1219
  __cil_tmp107 = (int )tmp___10;
#line 1219
  __cil_tmp108 = (int )tmp___9;
#line 1219
  __cil_tmp109 = (int )tmp___8;
#line 1219
  printk("<6>dc395x: dump: SCSI{status=0x%04x fifocnt=0x%02x signals=0x%02x irqstat=0x%02x sync=0x%02x target=0x%02x rselid=0x%02x ctr=0x%08x irqen=0x%02x config=0x%04x config2=0x%02x cmd=0x%02x selto=0x%02x}\n",
         __cil_tmp98, __cil_tmp99, __cil_tmp100, __cil_tmp101, __cil_tmp102, __cil_tmp103,
         __cil_tmp104, tmp___13, __cil_tmp105, __cil_tmp106, __cil_tmp107, __cil_tmp108,
         __cil_tmp109);
#line 1236
  __cil_tmp110 = acb->io_port_base;
#line 1236
  __cil_tmp111 = __cil_tmp110 + 176UL;
#line 1236
  __cil_tmp112 = (int )__cil_tmp111;
#line 1236
  tmp___21 = inl(__cil_tmp112);
#line 1236
  __cil_tmp113 = acb->io_port_base;
#line 1236
  __cil_tmp114 = __cil_tmp113 + 180UL;
#line 1236
  __cil_tmp115 = (int )__cil_tmp114;
#line 1236
  tmp___22 = inl(__cil_tmp115);
#line 1236
  __cil_tmp116 = acb->io_port_base;
#line 1236
  __cil_tmp117 = __cil_tmp116 + 172UL;
#line 1236
  __cil_tmp118 = (int )__cil_tmp117;
#line 1236
  tmp___23 = inl(__cil_tmp118);
#line 1236
  __cil_tmp119 = acb->io_port_base;
#line 1236
  __cil_tmp120 = __cil_tmp119 + 168UL;
#line 1236
  __cil_tmp121 = (int )__cil_tmp120;
#line 1236
  tmp___24 = inl(__cil_tmp121);
#line 1236
  __cil_tmp122 = acb->io_port_base;
#line 1236
  __cil_tmp123 = __cil_tmp122 + 166UL;
#line 1236
  __cil_tmp124 = (int )__cil_tmp123;
#line 1236
  tmp___25 = inw(__cil_tmp124);
#line 1236
  __cil_tmp125 = acb->io_port_base;
#line 1236
  __cil_tmp126 = __cil_tmp125 + 164UL;
#line 1236
  __cil_tmp127 = (int )__cil_tmp126;
#line 1236
  tmp___26 = inb(__cil_tmp127);
#line 1236
  __cil_tmp128 = acb->io_port_base;
#line 1236
  __cil_tmp129 = __cil_tmp128 + 163UL;
#line 1236
  __cil_tmp130 = (int )__cil_tmp129;
#line 1236
  tmp___27 = inb(__cil_tmp130);
#line 1236
  __cil_tmp131 = acb->io_port_base;
#line 1236
  __cil_tmp132 = __cil_tmp131 + 162UL;
#line 1236
  __cil_tmp133 = (int )__cil_tmp132;
#line 1236
  tmp___28 = inb(__cil_tmp133);
#line 1236
  __cil_tmp134 = acb->io_port_base;
#line 1236
  __cil_tmp135 = __cil_tmp134 + 161UL;
#line 1236
  __cil_tmp136 = (int )__cil_tmp135;
#line 1236
  tmp___29 = inb(__cil_tmp136);
#line 1236
  __cil_tmp137 = acb->io_port_base;
#line 1236
  __cil_tmp138 = __cil_tmp137 + 160UL;
#line 1236
  __cil_tmp139 = (int )__cil_tmp138;
#line 1236
  tmp___30 = inw(__cil_tmp139);
#line 1236
  __cil_tmp140 = (int )tmp___30;
#line 1236
  __cil_tmp141 = (int )tmp___29;
#line 1236
  __cil_tmp142 = (int )tmp___28;
#line 1236
  __cil_tmp143 = (int )tmp___27;
#line 1236
  __cil_tmp144 = (int )tmp___26;
#line 1236
  __cil_tmp145 = (int )tmp___25;
#line 1236
  printk("<6>dc395x: dump: DMA{cmd=0x%04x fifocnt=0x%02x fstat=0x%02x irqstat=0x%02x irqen=0x%02x cfg=0x%04x tctr=0x%08x ctctr=0x%08x addr=0x%08x:0x%08x}\n",
         __cil_tmp140, __cil_tmp141, __cil_tmp142, __cil_tmp143, __cil_tmp144, __cil_tmp145,
         tmp___24, tmp___23, tmp___22, tmp___21);
#line 1249
  __cil_tmp146 = acb->io_port_base;
#line 1249
  __cil_tmp147 = __cil_tmp146 + 219UL;
#line 1249
  __cil_tmp148 = (int )__cil_tmp147;
#line 1249
  tmp___31 = inb(__cil_tmp148);
#line 1249
  __cil_tmp149 = acb->io_port_base;
#line 1249
  __cil_tmp150 = __cil_tmp149 + 213UL;
#line 1249
  __cil_tmp151 = (int )__cil_tmp150;
#line 1249
  tmp___32 = inb(__cil_tmp151);
#line 1249
  __cil_tmp152 = acb->io_port_base;
#line 1249
  __cil_tmp153 = __cil_tmp152 + 212UL;
#line 1249
  __cil_tmp154 = (int )__cil_tmp153;
#line 1249
  tmp___33 = inb(__cil_tmp154);
#line 1249
  __cil_tmp155 = (int )tmp___33;
#line 1249
  __cil_tmp156 = (int )tmp___32;
#line 1249
  __cil_tmp157 = (int )tmp___31;
#line 1249
  __cil_tmp158 = (int )pstat;
#line 1249
  printk("<6>dc395x: dump: gen{gctrl=0x%02x gstat=0x%02x gtmr=0x%02x} pci{status=0x%04x}\n",
         __cil_tmp155, __cil_tmp156, __cil_tmp157, __cil_tmp158);
  }
#line 1255
  return;
}
}
#line 1258 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
__inline static void clear_fifo(struct AdapterCtlBlk *acb , char *txt ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 1268
  __cil_tmp3 = acb->io_port_base;
#line 1268
  __cil_tmp4 = __cil_tmp3 + 128UL;
#line 1268
  __cil_tmp5 = (int )__cil_tmp4;
#line 1268
  outw((unsigned short)4, __cil_tmp5);
  }
#line 1269
  return;
}
}
#line 1272 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void reset_dev_param(struct AdapterCtlBlk *acb ) 
{ struct DeviceCtlBlk *dcb ;
  struct NvRamType *eeprom ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u8 period_index ;
  struct list_head *__cil_tmp7 ;
  struct DeviceCtlBlk *__cil_tmp8 ;
  struct list_head *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  struct list_head *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  u8 __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  u8 __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  u8 __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  u8 __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  u8 __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  u8 __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  struct DeviceCtlBlk *__cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 1275
  eeprom = & acb->eeprom;
  {
#line 1276
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1276
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 1278
  __cil_tmp7 = acb->dcb_list.next;
#line 1278
  __mptr = (struct list_head  const  *)__cil_tmp7;
#line 1278
  __cil_tmp8 = (struct DeviceCtlBlk *)0;
#line 1278
  __cil_tmp9 = & __cil_tmp8->list;
#line 1278
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 1278
  __cil_tmp11 = (char *)__mptr;
#line 1278
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 1278
  dcb = (struct DeviceCtlBlk *)__cil_tmp12;
  {
#line 1278
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 1278
    __cil_tmp13 = & acb->dcb_list;
#line 1278
    __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 1278
    __cil_tmp15 = & dcb->list;
#line 1278
    __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 1278
    if (__cil_tmp16 != __cil_tmp14) {

    } else {
#line 1278
      goto while_break___0;
    }
    }
#line 1281
    __cil_tmp17 = dcb->sync_mode;
#line 1281
    __cil_tmp18 = (int )__cil_tmp17;
#line 1281
    __cil_tmp19 = __cil_tmp18 & -11;
#line 1281
    dcb->sync_mode = (u8 )__cil_tmp19;
#line 1282
    dcb->sync_period = (u8 )0;
#line 1283
    dcb->sync_offset = (u8 )0;
#line 1285
    dcb->dev_mode = eeprom->target[dcb->target_id].cfg0;
#line 1286
    __cil_tmp20 = eeprom->target[dcb->target_id].period;
#line 1286
    __cil_tmp21 = (int )__cil_tmp20;
#line 1286
    __cil_tmp22 = __cil_tmp21 & 7;
#line 1286
    period_index = (u8 )__cil_tmp22;
#line 1287
    dcb->min_nego_period = clock_period[period_index];
    {
#line 1288
    __cil_tmp23 = dcb->dev_mode;
#line 1288
    __cil_tmp24 = (int )__cil_tmp23;
#line 1288
    __cil_tmp25 = __cil_tmp24 & 32;
#line 1288
    if (! __cil_tmp25) {
#line 1290
      __cil_tmp26 = dcb->sync_mode;
#line 1290
      __cil_tmp27 = (int )__cil_tmp26;
#line 1290
      __cil_tmp28 = __cil_tmp27 & -5;
#line 1290
      dcb->sync_mode = (u8 )__cil_tmp28;
    } else {
      {
#line 1288
      __cil_tmp29 = acb->config;
#line 1288
      __cil_tmp30 = (int )__cil_tmp29;
#line 1288
      __cil_tmp31 = __cil_tmp30 & 32;
#line 1288
      if (! __cil_tmp31) {
#line 1290
        __cil_tmp32 = dcb->sync_mode;
#line 1290
        __cil_tmp33 = (int )__cil_tmp32;
#line 1290
        __cil_tmp34 = __cil_tmp33 & -5;
#line 1290
        dcb->sync_mode = (u8 )__cil_tmp34;
      } else {

      }
      }
    }
    }
#line 1278
    __cil_tmp35 = dcb->list.next;
#line 1278
    __mptr___0 = (struct list_head  const  *)__cil_tmp35;
#line 1278
    __cil_tmp36 = (struct DeviceCtlBlk *)0;
#line 1278
    __cil_tmp37 = & __cil_tmp36->list;
#line 1278
    __cil_tmp38 = (unsigned int )__cil_tmp37;
#line 1278
    __cil_tmp39 = (char *)__mptr___0;
#line 1278
    __cil_tmp40 = __cil_tmp39 - __cil_tmp38;
#line 1278
    dcb = (struct DeviceCtlBlk *)__cil_tmp40;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 1292
  return;
}
}
#line 1300 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int __dc395x_eh_bus_reset(struct scsi_cmnd *cmd ) 
{ struct AdapterCtlBlk *acb ;
  int tmp___7 ;
  struct scsi_device *__cil_tmp4 ;
  struct Scsi_Host *__cil_tmp5 ;
  unsigned long *__cil_tmp6 ;
  struct scsi_device *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  struct scsi_device *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  struct timer_list *__cil_tmp11 ;
  struct timer_list  const  *__cil_tmp12 ;
  struct timer_list *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  struct Scsi_Host *__cil_tmp26 ;
  u8 __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long volatile   __cil_tmp30 ;
  unsigned long volatile   __cil_tmp31 ;
  unsigned long volatile   __cil_tmp32 ;
  unsigned long volatile   __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  u8 __cil_tmp41 ;
  u8 __cil_tmp42 ;
  void *__cil_tmp43 ;

  {
  {
#line 1302
  __cil_tmp4 = cmd->device;
#line 1302
  __cil_tmp5 = __cil_tmp4->host;
#line 1302
  __cil_tmp6 = & __cil_tmp5->hostdata[0];
#line 1302
  acb = (struct AdapterCtlBlk *)__cil_tmp6;
#line 1304
  __cil_tmp7 = cmd->device;
#line 1304
  __cil_tmp8 = __cil_tmp7->id;
#line 1304
  __cil_tmp9 = cmd->device;
#line 1304
  __cil_tmp10 = __cil_tmp9->lun;
#line 1304
  printk("<6>dc395x: eh_bus_reset: (0%p) target=<%02i-%i> cmd=%p\n", cmd, __cil_tmp8,
         __cil_tmp10, cmd);
#line 1308
  __cil_tmp11 = & acb->waiting_timer;
#line 1308
  __cil_tmp12 = (struct timer_list  const  *)__cil_tmp11;
#line 1308
  tmp___7 = timer_pending(__cil_tmp12);
  }
#line 1308
  if (tmp___7) {
    {
#line 1309
    __cil_tmp13 = & acb->waiting_timer;
#line 1309
    del_timer(__cil_tmp13);
    }
  } else {

  }
  {
#line 1314
  __cil_tmp14 = acb->io_port_base;
#line 1314
  __cil_tmp15 = __cil_tmp14 + 164UL;
#line 1314
  __cil_tmp16 = (int )__cil_tmp15;
#line 1314
  outb((unsigned char)0, __cil_tmp16);
#line 1315
  __cil_tmp17 = acb->io_port_base;
#line 1315
  __cil_tmp18 = __cil_tmp17 + 140UL;
#line 1315
  __cil_tmp19 = (int )__cil_tmp18;
#line 1315
  outb((unsigned char)0, __cil_tmp19);
#line 1316
  __cil_tmp20 = acb->io_port_base;
#line 1316
  __cil_tmp21 = __cil_tmp20 + 128UL;
#line 1316
  __cil_tmp22 = (int )__cil_tmp21;
#line 1316
  outb((unsigned char)16, __cil_tmp22);
#line 1317
  __cil_tmp23 = acb->io_port_base;
#line 1317
  __cil_tmp24 = __cil_tmp23 + 161UL;
#line 1317
  __cil_tmp25 = (int )__cil_tmp24;
#line 1317
  outb((unsigned char)16, __cil_tmp25);
#line 1319
  reset_scsi_bus(acb);
#line 1320
  __const_udelay(2147500UL);
#line 1323
  __cil_tmp26 = acb->scsi_host;
#line 1323
  __cil_tmp27 = acb->eeprom.delay_time;
#line 1323
  __cil_tmp28 = (int )__cil_tmp27;
#line 1323
  __cil_tmp29 = 250 * __cil_tmp28;
#line 1323
  __cil_tmp30 = (unsigned long volatile   )__cil_tmp29;
#line 1323
  __cil_tmp31 = (unsigned long volatile   )375;
#line 1323
  __cil_tmp32 = jiffies + __cil_tmp31;
#line 1323
  __cil_tmp33 = __cil_tmp32 + __cil_tmp30;
#line 1323
  __cil_tmp26->last_reset = (unsigned long )__cil_tmp33;
#line 1331
  __cil_tmp34 = acb->io_port_base;
#line 1331
  __cil_tmp35 = __cil_tmp34 + 161UL;
#line 1331
  __cil_tmp36 = (int )__cil_tmp35;
#line 1331
  outb((unsigned char)2, __cil_tmp36);
#line 1332
  __cil_tmp37 = (char *)"eh_bus_reset";
#line 1332
  clear_fifo(acb, __cil_tmp37);
#line 1334
  __cil_tmp38 = acb->io_port_base;
#line 1334
  __cil_tmp39 = __cil_tmp38 + 132UL;
#line 1334
  __cil_tmp40 = (int )__cil_tmp39;
#line 1334
  inb(__cil_tmp40);
#line 1335
  set_basic_config(acb);
#line 1337
  reset_dev_param(acb);
#line 1338
  __cil_tmp41 = (u8 )8;
#line 1338
  __cil_tmp42 = (u8 )0;
#line 1338
  doing_srb_done(acb, __cil_tmp41, cmd, __cil_tmp42);
#line 1339
  __cil_tmp43 = (void *)0;
#line 1339
  acb->active_dcb = (struct DeviceCtlBlk *)__cil_tmp43;
#line 1340
  acb->acb_flag = (u8 )0;
#line 1341
  waiting_process_next(acb);
  }
#line 1343
  return (8194);
}
}
#line 1346 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_eh_bus_reset(struct scsi_cmnd *cmd ) 
{ int rc ;
  struct scsi_device *__cil_tmp3 ;
  struct Scsi_Host *__cil_tmp4 ;
  spinlock_t *__cil_tmp5 ;
  struct scsi_device *__cil_tmp6 ;
  struct Scsi_Host *__cil_tmp7 ;
  spinlock_t *__cil_tmp8 ;

  {
  {
#line 1350
  __cil_tmp3 = cmd->device;
#line 1350
  __cil_tmp4 = __cil_tmp3->host;
#line 1350
  __cil_tmp5 = __cil_tmp4->host_lock;
#line 1350
  spin_lock_irq(__cil_tmp5);
#line 1351
  rc = __dc395x_eh_bus_reset(cmd);
#line 1352
  __cil_tmp6 = cmd->device;
#line 1352
  __cil_tmp7 = __cil_tmp6->host;
#line 1352
  __cil_tmp8 = __cil_tmp7->host_lock;
#line 1352
  spin_unlock_irq(__cil_tmp8);
  }
#line 1354
  return (rc);
}
}
#line 1362 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_eh_abort(struct scsi_cmnd *cmd ) 
{ struct AdapterCtlBlk *acb ;
  struct DeviceCtlBlk *dcb ;
  struct ScsiReqBlk *srb ;
  struct scsi_device *__cil_tmp5 ;
  struct Scsi_Host *__cil_tmp6 ;
  unsigned long *__cil_tmp7 ;
  struct scsi_device *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  struct scsi_device *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  struct scsi_device *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  u8 __cil_tmp14 ;
  struct scsi_device *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  u8 __cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  struct list_head *__cil_tmp19 ;

  {
  {
#line 1368
  __cil_tmp5 = cmd->device;
#line 1368
  __cil_tmp6 = __cil_tmp5->host;
#line 1368
  __cil_tmp7 = & __cil_tmp6->hostdata[0];
#line 1368
  acb = (struct AdapterCtlBlk *)__cil_tmp7;
#line 1372
  __cil_tmp8 = cmd->device;
#line 1372
  __cil_tmp9 = __cil_tmp8->id;
#line 1372
  __cil_tmp10 = cmd->device;
#line 1372
  __cil_tmp11 = __cil_tmp10->lun;
#line 1372
  printk("<6>dc395x: eh_abort: (0x%p) target=<%02i-%i> cmd=%p\n", cmd, __cil_tmp9,
         __cil_tmp11, cmd);
#line 1375
  __cil_tmp12 = cmd->device;
#line 1375
  __cil_tmp13 = __cil_tmp12->id;
#line 1375
  __cil_tmp14 = (u8 )__cil_tmp13;
#line 1375
  __cil_tmp15 = cmd->device;
#line 1375
  __cil_tmp16 = __cil_tmp15->lun;
#line 1375
  __cil_tmp17 = (u8 )__cil_tmp16;
#line 1375
  dcb = find_dcb(acb, __cil_tmp14, __cil_tmp17);
  }
#line 1376
  if (! dcb) {
    {
#line 1377
    printk("<7>dc395x: eh_abort: No such device\n");
    }
#line 1378
    return (8195);
  } else {

  }
  {
#line 1381
  __cil_tmp18 = & dcb->srb_waiting_list;
#line 1381
  srb = find_cmd(cmd, __cil_tmp18);
  }
#line 1382
  if (srb) {
    {
#line 1383
    srb_waiting_remove(dcb, srb);
#line 1384
    pci_unmap_srb_sense(acb, srb);
#line 1385
    pci_unmap_srb(acb, srb);
#line 1386
    free_tag(dcb, srb);
#line 1387
    srb_free_insert(acb, srb);
#line 1388
    printk("<7>dc395x: eh_abort: Command was waiting\n");
#line 1389
    cmd->result = 5 << 16;
    }
#line 1390
    return (8194);
  } else {

  }
  {
#line 1392
  __cil_tmp19 = & dcb->srb_going_list;
#line 1392
  srb = find_cmd(cmd, __cil_tmp19);
  }
#line 1393
  if (srb) {
    {
#line 1394
    printk("<7>dc395x: eh_abort: Command in progress\n");
    }
  } else {
    {
#line 1397
    printk("<7>dc395x: eh_abort: Command not found\n");
    }
  }
#line 1399
  return (8195);
}
}
#line 1404 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void build_sdtr(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ u8 *ptr ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  u8 *tmp___11 ;
  u8 __cil_tmp10 ;
  int __cil_tmp11 ;
  u8 *__cil_tmp12 ;
  u8 __cil_tmp13 ;
  int __cil_tmp14 ;
  u8 __cil_tmp15 ;
  int __cil_tmp16 ;
  u8 __cil_tmp17 ;
  int __cil_tmp18 ;
  u8 __cil_tmp19 ;
  int __cil_tmp20 ;
  u8 __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  u8 __cil_tmp25 ;
  int __cil_tmp26 ;
  u8 __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  u16 __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 1407
  __cil_tmp10 = srb->msg_count;
#line 1407
  __cil_tmp11 = (int )__cil_tmp10;
#line 1407
  __cil_tmp12 = & srb->msgout_buf[0];
#line 1407
  ptr = __cil_tmp12 + __cil_tmp11;
  {
#line 1408
  __cil_tmp13 = srb->msg_count;
#line 1408
  __cil_tmp14 = (int )__cil_tmp13;
#line 1408
  if (__cil_tmp14 > 1) {
    {
#line 1409
    __cil_tmp15 = srb->msg_count;
#line 1409
    __cil_tmp16 = (int )__cil_tmp15;
#line 1409
    __cil_tmp17 = srb->msgout_buf[0];
#line 1409
    __cil_tmp18 = (int )__cil_tmp17;
#line 1409
    __cil_tmp19 = srb->msgout_buf[1];
#line 1409
    __cil_tmp20 = (int )__cil_tmp19;
#line 1409
    printk("<6>dc395x: build_sdtr: msgout_buf BUSY (%i: %02x %02x)\n", __cil_tmp16,
           __cil_tmp18, __cil_tmp20);
    }
#line 1413
    return;
  } else {

  }
  }
  {
#line 1415
  __cil_tmp21 = dcb->dev_mode;
#line 1415
  __cil_tmp22 = (int )__cil_tmp21;
#line 1415
  __cil_tmp23 = __cil_tmp22 & 2;
#line 1415
  if (! __cil_tmp23) {
#line 1416
    dcb->sync_offset = (u8 )0;
#line 1417
    __cil_tmp24 = 200 >> 2;
#line 1417
    dcb->min_nego_period = (u8 )__cil_tmp24;
  } else {
    {
#line 1418
    __cil_tmp25 = dcb->sync_offset;
#line 1418
    __cil_tmp26 = (int )__cil_tmp25;
#line 1418
    if (__cil_tmp26 == 0) {
#line 1419
      dcb->sync_offset = (u8 )15;
    } else {

    }
    }
  }
  }
#line 1421
  tmp___7 = ptr;
#line 1421
  ptr = ptr + 1;
#line 1421
  *tmp___7 = (u8 )1;
#line 1422
  tmp___8 = ptr;
#line 1422
  ptr = ptr + 1;
#line 1422
  *tmp___8 = (u8 )3;
#line 1423
  tmp___9 = ptr;
#line 1423
  ptr = ptr + 1;
#line 1423
  *tmp___9 = (u8 )1;
#line 1424
  tmp___10 = ptr;
#line 1424
  ptr = ptr + 1;
#line 1424
  *tmp___10 = dcb->min_nego_period;
#line 1425
  tmp___11 = ptr;
#line 1425
  ptr = ptr + 1;
#line 1425
  *tmp___11 = dcb->sync_offset;
#line 1426
  __cil_tmp27 = srb->msg_count;
#line 1426
  __cil_tmp28 = (int )__cil_tmp27;
#line 1426
  __cil_tmp29 = __cil_tmp28 + 5;
#line 1426
  srb->msg_count = (u8 )__cil_tmp29;
#line 1427
  __cil_tmp30 = srb->state;
#line 1427
  __cil_tmp31 = (int )__cil_tmp30;
#line 1427
  __cil_tmp32 = __cil_tmp31 | 8192;
#line 1427
  srb->state = (u16 )__cil_tmp32;
#line 1428
  return;
}
}
#line 1432 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void build_wdtr(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ u8 wide ;
  int tmp___7 ;
  u8 *ptr ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  u8 *tmp___11 ;
  u8 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  u8 __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  u8 __cil_tmp17 ;
  int __cil_tmp18 ;
  u8 *__cil_tmp19 ;
  u8 __cil_tmp20 ;
  int __cil_tmp21 ;
  u8 __cil_tmp22 ;
  int __cil_tmp23 ;
  u8 __cil_tmp24 ;
  int __cil_tmp25 ;
  u8 __cil_tmp26 ;
  int __cil_tmp27 ;
  u8 __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  u16 __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
  {
#line 1435
  __cil_tmp11 = acb->config;
#line 1435
  __cil_tmp12 = (int )__cil_tmp11;
#line 1435
  __cil_tmp13 = __cil_tmp12 & 32;
#line 1435
  __cil_tmp14 = dcb->dev_mode;
#line 1435
  __cil_tmp15 = (int )__cil_tmp14;
#line 1435
  __cil_tmp16 = __cil_tmp15 & 32;
#line 1435
  if (__cil_tmp16 & __cil_tmp13) {
#line 1435
    tmp___7 = 1;
  } else {
#line 1435
    tmp___7 = 0;
  }
  }
#line 1435
  wide = (u8 )tmp___7;
#line 1437
  __cil_tmp17 = srb->msg_count;
#line 1437
  __cil_tmp18 = (int )__cil_tmp17;
#line 1437
  __cil_tmp19 = & srb->msgout_buf[0];
#line 1437
  ptr = __cil_tmp19 + __cil_tmp18;
  {
#line 1438
  __cil_tmp20 = srb->msg_count;
#line 1438
  __cil_tmp21 = (int )__cil_tmp20;
#line 1438
  if (__cil_tmp21 > 1) {
    {
#line 1439
    __cil_tmp22 = srb->msg_count;
#line 1439
    __cil_tmp23 = (int )__cil_tmp22;
#line 1439
    __cil_tmp24 = srb->msgout_buf[0];
#line 1439
    __cil_tmp25 = (int )__cil_tmp24;
#line 1439
    __cil_tmp26 = srb->msgout_buf[1];
#line 1439
    __cil_tmp27 = (int )__cil_tmp26;
#line 1439
    printk("<6>dc395x: build_wdtr: msgout_buf BUSY (%i: %02x %02x)\n", __cil_tmp23,
           __cil_tmp25, __cil_tmp27);
    }
#line 1443
    return;
  } else {

  }
  }
#line 1445
  tmp___8 = ptr;
#line 1445
  ptr = ptr + 1;
#line 1445
  *tmp___8 = (u8 )1;
#line 1446
  tmp___9 = ptr;
#line 1446
  ptr = ptr + 1;
#line 1446
  *tmp___9 = (u8 )2;
#line 1447
  tmp___10 = ptr;
#line 1447
  ptr = ptr + 1;
#line 1447
  *tmp___10 = (u8 )3;
#line 1448
  tmp___11 = ptr;
#line 1448
  ptr = ptr + 1;
#line 1448
  *tmp___11 = wide;
#line 1449
  __cil_tmp28 = srb->msg_count;
#line 1449
  __cil_tmp29 = (int )__cil_tmp28;
#line 1449
  __cil_tmp30 = __cil_tmp29 + 4;
#line 1449
  srb->msg_count = (u8 )__cil_tmp30;
#line 1450
  __cil_tmp31 = srb->state;
#line 1450
  __cil_tmp32 = (int )__cil_tmp31;
#line 1450
  __cil_tmp33 = __cil_tmp32 | 16384;
#line 1450
  srb->state = (u16 )__cil_tmp33;
#line 1451
  return;
}
}
#line 1493 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static u8 start_scsi(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ u16 s_stat2 ;
  u16 return_code ;
  u8 s_stat ;
  u8 scsicommand ;
  u8 i ;
  u8 identify_message ;
  u8 *ptr ;
  unsigned char tmp___7 ;
  unsigned short tmp___8 ;
  struct scsi_cmnd *tmp___9 ;
  unsigned short tmp___10 ;
  u32 tag_mask ;
  u8 tag_number ;
  u8 *tmp___11 ;
  unsigned short tmp___12 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  struct DeviceCtlBlk *__cil_tmp26 ;
  struct DeviceCtlBlk *__cil_tmp27 ;
  struct ScsiReqBlk *__cil_tmp28 ;
  struct scsi_cmnd *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  struct Scsi_Host *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  long __cil_tmp37 ;
  long __cil_tmp38 ;
  long __cil_tmp39 ;
  char *__cil_tmp40 ;
  struct Scsi_Host *__cil_tmp41 ;
  int __cil_tmp42 ;
  unsigned char __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  int __cil_tmp46 ;
  u8 __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  u8 __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  int __cil_tmp54 ;
  u8 __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  int __cil_tmp58 ;
  u8 __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  struct scsi_cmnd *__cil_tmp63 ;
  unsigned char *__cil_tmp64 ;
  unsigned char *__cil_tmp65 ;
  unsigned char __cil_tmp66 ;
  int __cil_tmp67 ;
  struct scsi_cmnd *__cil_tmp68 ;
  unsigned char *__cil_tmp69 ;
  unsigned char *__cil_tmp70 ;
  unsigned char __cil_tmp71 ;
  int __cil_tmp72 ;
  u8 __cil_tmp73 ;
  int __cil_tmp74 ;
  u8 __cil_tmp75 ;
  int __cil_tmp76 ;
  u8 __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  u8 __cil_tmp80 ;
  int __cil_tmp81 ;
  u8 __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  u8 __cil_tmp85 ;
  int __cil_tmp86 ;
  u8 __cil_tmp87 ;
  int __cil_tmp88 ;
  u8 __cil_tmp89 ;
  int __cil_tmp90 ;
  u8 __cil_tmp91 ;
  int __cil_tmp92 ;
  u8 __cil_tmp93 ;
  int __cil_tmp94 ;
  u8 __cil_tmp95 ;
  int __cil_tmp96 ;
  u8 __cil_tmp97 ;
  int __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  int __cil_tmp101 ;
  u8 __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  u32 __cil_tmp105 ;
  u16 __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  u16 __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  struct scsi_cmnd *__cil_tmp114 ;
  struct scsi_cmnd *__cil_tmp115 ;
  struct scsi_device *__cil_tmp116 ;
  unsigned int __cil_tmp117 ;
  struct scsi_cmnd *__cil_tmp118 ;
  struct scsi_device *__cil_tmp119 ;
  unsigned int __cil_tmp120 ;
  unsigned long __cil_tmp121 ;
  unsigned long __cil_tmp122 ;
  int __cil_tmp123 ;
  unsigned long __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  int __cil_tmp126 ;
  unsigned long __cil_tmp127 ;
  unsigned long __cil_tmp128 ;
  int __cil_tmp129 ;
  u32 __cil_tmp130 ;
  u8 __cil_tmp131 ;
  int __cil_tmp132 ;
  unsigned long __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  int __cil_tmp135 ;
  u8 __cil_tmp136 ;
  int __cil_tmp137 ;
  int __cil_tmp138 ;
  unsigned char __cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  int __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  int __cil_tmp145 ;
  unsigned long __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  int __cil_tmp148 ;
  unsigned long __cil_tmp149 ;
  unsigned long __cil_tmp150 ;
  int __cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  unsigned long __cil_tmp153 ;
  int __cil_tmp154 ;
  struct scsi_cmnd *__cil_tmp155 ;
  struct scsi_cmnd *__cil_tmp156 ;
  unsigned short __cil_tmp157 ;
  int __cil_tmp158 ;
  int __cil_tmp159 ;
  u8 __cil_tmp160 ;
  unsigned long __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  int __cil_tmp163 ;
  int __cil_tmp164 ;
  int __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  unsigned long __cil_tmp167 ;
  int __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  int __cil_tmp171 ;
  int __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  int __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  int __cil_tmp178 ;

  {
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1499
    goto while_break;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1502
  srb->tag_number = (u8 )255;
#line 1504
  __cil_tmp19 = acb->io_port_base;
#line 1504
  __cil_tmp20 = __cil_tmp19 + 131UL;
#line 1504
  __cil_tmp21 = (int )__cil_tmp20;
#line 1504
  tmp___7 = inb(__cil_tmp21);
#line 1504
  s_stat = tmp___7;
#line 1505
  s_stat2 = (u16 )0;
#line 1506
  __cil_tmp22 = acb->io_port_base;
#line 1506
  __cil_tmp23 = __cil_tmp22 + 128UL;
#line 1506
  __cil_tmp24 = (int )__cil_tmp23;
#line 1506
  tmp___8 = inw(__cil_tmp24);
#line 1506
  s_stat2 = tmp___8;
  }
  {
#line 1508
  __cil_tmp25 = (int )s_stat;
#line 1508
  if (__cil_tmp25 & 32) {
    {
#line 1509
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1509
      goto while_break___0;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: ;
#line 1522
    return ((u8 )1);
  } else {

  }
  }
#line 1525
  if (acb->active_dcb) {
    {
#line 1526
    __cil_tmp26 = acb->active_dcb;
#line 1526
    if (__cil_tmp26->active_srb) {
#line 1526
      __cil_tmp27 = acb->active_dcb;
#line 1526
      __cil_tmp28 = __cil_tmp27->active_srb;
#line 1526
      tmp___9 = __cil_tmp28->cmd;
    } else {
#line 1526
      tmp___9 = (struct scsi_cmnd *)0;
    }
    }
    {
#line 1526
    __cil_tmp29 = srb->cmd;
#line 1526
    printk("<7>dc395x: start_scsi: (0x%p) Attempt to start acommand while another command (0x%p) is active.",
           __cil_tmp29, tmp___9);
    }
#line 1531
    return ((u8 )1);
  } else {

  }
  {
#line 1533
  __cil_tmp30 = acb->io_port_base;
#line 1533
  __cil_tmp31 = __cil_tmp30 + 128UL;
#line 1533
  __cil_tmp32 = (int )__cil_tmp31;
#line 1533
  tmp___10 = inw(__cil_tmp32);
  }
  {
#line 1533
  __cil_tmp33 = (int )tmp___10;
#line 1533
  if (__cil_tmp33 & 128) {
    {
#line 1534
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1534
      goto while_break___1;
    }
    while_break___9: /* CIL Label */ ;
    }

    while_break___1: ;
#line 1535
    return ((u8 )1);
  } else {

  }
  }
  {
#line 1539
  __cil_tmp34 = acb->scsi_host;
#line 1539
  __cil_tmp35 = __cil_tmp34->last_reset;
#line 1539
  __cil_tmp36 = __cil_tmp35 - 125UL;
#line 1539
  __cil_tmp37 = (long )__cil_tmp36;
#line 1539
  __cil_tmp38 = (long )jiffies;
#line 1539
  __cil_tmp39 = __cil_tmp38 - __cil_tmp37;
#line 1539
  if (__cil_tmp39 < 0L) {
    {
#line 1540
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1540
      goto while_break___2;
    }
    while_break___10: /* CIL Label */ ;
    }

    while_break___2: ;
#line 1541
    return ((u8 )1);
  } else {

  }
  }
  {
#line 1545
  __cil_tmp40 = (char *)"start_scsi";
#line 1545
  clear_fifo(acb, __cil_tmp40);
#line 1546
  __cil_tmp41 = acb->scsi_host;
#line 1546
  __cil_tmp42 = __cil_tmp41->this_id;
#line 1546
  __cil_tmp43 = (unsigned char )__cil_tmp42;
#line 1546
  __cil_tmp44 = acb->io_port_base;
#line 1546
  __cil_tmp45 = __cil_tmp44 + 135UL;
#line 1546
  __cil_tmp46 = (int )__cil_tmp45;
#line 1546
  outb(__cil_tmp43, __cil_tmp46);
#line 1547
  __cil_tmp47 = dcb->target_id;
#line 1547
  __cil_tmp48 = acb->io_port_base;
#line 1547
  __cil_tmp49 = __cil_tmp48 + 134UL;
#line 1547
  __cil_tmp50 = (int )__cil_tmp49;
#line 1547
  outb(__cil_tmp47, __cil_tmp50);
#line 1548
  __cil_tmp51 = dcb->sync_period;
#line 1548
  __cil_tmp52 = acb->io_port_base;
#line 1548
  __cil_tmp53 = __cil_tmp52 + 133UL;
#line 1548
  __cil_tmp54 = (int )__cil_tmp53;
#line 1548
  outb(__cil_tmp51, __cil_tmp54);
#line 1549
  __cil_tmp55 = dcb->sync_offset;
#line 1549
  __cil_tmp56 = acb->io_port_base;
#line 1549
  __cil_tmp57 = __cil_tmp56 + 132UL;
#line 1549
  __cil_tmp58 = (int )__cil_tmp57;
#line 1549
  outb(__cil_tmp55, __cil_tmp58);
#line 1550
  srb->scsi_phase = (u8 )5;
#line 1552
  identify_message = dcb->identify_msg;
  }
  {
#line 1555
  __cil_tmp59 = srb->flag;
#line 1555
  __cil_tmp60 = (int )__cil_tmp59;
#line 1555
  if (__cil_tmp60 & 1) {
#line 1556
    __cil_tmp61 = (int )identify_message;
#line 1556
    __cil_tmp62 = __cil_tmp61 & 191;
#line 1556
    identify_message = (u8 )__cil_tmp62;
  } else {

  }
  }
  {
#line 1558
  __cil_tmp63 = srb->cmd;
#line 1558
  __cil_tmp64 = __cil_tmp63->cmnd;
#line 1558
  __cil_tmp65 = __cil_tmp64 + 0;
#line 1558
  __cil_tmp66 = *__cil_tmp65;
#line 1558
  __cil_tmp67 = (int )__cil_tmp66;
#line 1558
  if (__cil_tmp67 == 18) {
#line 1558
    goto _L___1;
  } else {
    {
#line 1558
    __cil_tmp68 = srb->cmd;
#line 1558
    __cil_tmp69 = __cil_tmp68->cmnd;
#line 1558
    __cil_tmp70 = __cil_tmp69 + 0;
#line 1558
    __cil_tmp71 = *__cil_tmp70;
#line 1558
    __cil_tmp72 = (int )__cil_tmp71;
#line 1558
    if (__cil_tmp72 == 3) {
#line 1558
      goto _L___1;
    } else {
      {
#line 1558
      __cil_tmp73 = srb->flag;
#line 1558
      __cil_tmp74 = (int )__cil_tmp73;
#line 1558
      if (__cil_tmp74 & 1) {
        _L___1: 
        {
#line 1558
        __cil_tmp75 = dcb->sync_mode;
#line 1558
        __cil_tmp76 = (int )__cil_tmp75;
#line 1558
        if (__cil_tmp76 & 4) {
          {
#line 1558
          __cil_tmp77 = dcb->sync_mode;
#line 1558
          __cil_tmp78 = (int )__cil_tmp77;
#line 1558
          __cil_tmp79 = __cil_tmp78 & 8;
#line 1558
          if (! __cil_tmp79) {
#line 1558
            goto _L;
          } else {
#line 1558
            goto _L___0;
          }
          }
        } else {
          _L___0: 
          {
#line 1558
          __cil_tmp80 = dcb->sync_mode;
#line 1558
          __cil_tmp81 = (int )__cil_tmp80;
#line 1558
          if (__cil_tmp81 & 1) {
            {
#line 1558
            __cil_tmp82 = dcb->sync_mode;
#line 1558
            __cil_tmp83 = (int )__cil_tmp82;
#line 1558
            __cil_tmp84 = __cil_tmp83 & 2;
#line 1558
            if (! __cil_tmp84) {
              _L: 
              {
#line 1558
              __cil_tmp85 = dcb->target_lun;
#line 1558
              __cil_tmp86 = (int )__cil_tmp85;
#line 1558
              if (__cil_tmp86 == 0) {
#line 1566
                srb->msgout_buf[0] = identify_message;
#line 1567
                srb->msg_count = (u8 )1;
#line 1568
                scsicommand = (u8 )184;
#line 1569
                srb->state = (u16 )4;
                {
#line 1571
                __cil_tmp87 = dcb->sync_mode;
#line 1571
                __cil_tmp88 = (int )__cil_tmp87;
#line 1571
                if (__cil_tmp88 & 4) {
                  {
#line 1571
                  __cil_tmp89 = dcb->inquiry7;
#line 1571
                  __cil_tmp90 = (int )__cil_tmp89;
#line 1571
                  if (__cil_tmp90 & 32) {
                    {
#line 1573
                    build_wdtr(acb, dcb, srb);
                    }
#line 1574
                    goto no_cmd;
                  } else {

                  }
                  }
                } else {

                }
                }
                {
#line 1577
                __cil_tmp91 = dcb->sync_mode;
#line 1577
                __cil_tmp92 = (int )__cil_tmp91;
#line 1577
                if (__cil_tmp92 & 1) {
                  {
#line 1577
                  __cil_tmp93 = dcb->inquiry7;
#line 1577
                  __cil_tmp94 = (int )__cil_tmp93;
#line 1577
                  if (__cil_tmp94 & 16) {
                    {
#line 1579
                    build_sdtr(acb, dcb, srb);
                    }
#line 1580
                    goto no_cmd;
                  } else {

                  }
                  }
                } else {

                }
                }
                {
#line 1582
                __cil_tmp95 = dcb->sync_mode;
#line 1582
                __cil_tmp96 = (int )__cil_tmp95;
#line 1582
                if (__cil_tmp96 & 4) {
                  {
#line 1582
                  __cil_tmp97 = dcb->inquiry7;
#line 1582
                  __cil_tmp98 = (int )__cil_tmp97;
#line 1582
                  if (__cil_tmp98 & 32) {
                    {
#line 1584
                    build_wdtr(acb, dcb, srb);
                    }
#line 1585
                    goto no_cmd;
                  } else {

                  }
                  }
                } else {

                }
                }
#line 1587
                srb->msg_count = (u8 )0;
              } else {

              }
              }
            } else {

            }
            }
          } else {

          }
          }
        }
        }
      } else {

      }
      }
    }
    }
  }
  }
  {
#line 1590
  __cil_tmp99 = acb->io_port_base;
#line 1590
  __cil_tmp100 = __cil_tmp99 + 152UL;
#line 1590
  __cil_tmp101 = (int )__cil_tmp100;
#line 1590
  outb(identify_message, __cil_tmp101);
#line 1592
  scsicommand = (u8 )96;
#line 1593
  srb->state = (u16 )64;
  }
  {
#line 1595
  __cil_tmp102 = dcb->sync_mode;
#line 1595
  __cil_tmp103 = (int )__cil_tmp102;
#line 1595
  if (__cil_tmp103 & 32) {
    {
#line 1595
    __cil_tmp104 = (int )identify_message;
#line 1595
    if (__cil_tmp104 & 192) {
#line 1598
      tag_mask = (u32 )1;
#line 1599
      tag_number = (u8 )0;
      {
#line 1600
      while (1) {
        while_continue___3: /* CIL Label */ ;

        {
#line 1600
        __cil_tmp105 = dcb->tag_mask;
#line 1600
        if (tag_mask & __cil_tmp105) {
          {
#line 1600
          __cil_tmp106 = dcb->max_command;
#line 1600
          __cil_tmp107 = (int )__cil_tmp106;
#line 1600
          __cil_tmp108 = (int )tag_number;
#line 1600
          if (__cil_tmp108 < __cil_tmp107) {

          } else {
#line 1600
            goto while_break___3;
          }
          }
        } else {
#line 1600
          goto while_break___3;
        }
        }
#line 1602
        tag_mask = tag_mask << 1;
#line 1603
        __cil_tmp109 = (int )tag_number;
#line 1603
        __cil_tmp110 = __cil_tmp109 + 1;
#line 1603
        tag_number = (u8 )__cil_tmp110;
      }
      while_break___11: /* CIL Label */ ;
      }

      while_break___3: ;
      {
#line 1605
      __cil_tmp111 = dcb->max_command;
#line 1605
      __cil_tmp112 = (int )__cil_tmp111;
#line 1605
      __cil_tmp113 = (int )tag_number;
#line 1605
      if (__cil_tmp113 >= __cil_tmp112) {
        {
#line 1606
        __cil_tmp114 = srb->cmd;
#line 1606
        __cil_tmp115 = srb->cmd;
#line 1606
        __cil_tmp116 = __cil_tmp115->device;
#line 1606
        __cil_tmp117 = __cil_tmp116->id;
#line 1606
        __cil_tmp118 = srb->cmd;
#line 1606
        __cil_tmp119 = __cil_tmp118->device;
#line 1606
        __cil_tmp120 = __cil_tmp119->lun;
#line 1606
        printk("<4>dc395x: start_scsi: (0x%p) Out of tags target=<%02i-%i>)\n", __cil_tmp114,
               __cil_tmp117, __cil_tmp120);
#line 1610
        srb->state = (u16 )2;
#line 1611
        __cil_tmp121 = acb->io_port_base;
#line 1611
        __cil_tmp122 = __cil_tmp121 + 128UL;
#line 1611
        __cil_tmp123 = (int )__cil_tmp122;
#line 1611
        outw((unsigned short)1, __cil_tmp123);
        }
#line 1613
        return ((u8 )1);
      } else {

      }
      }
      {
#line 1616
      __cil_tmp124 = acb->io_port_base;
#line 1616
      __cil_tmp125 = __cil_tmp124 + 152UL;
#line 1616
      __cil_tmp126 = (int )__cil_tmp125;
#line 1616
      outb((unsigned char)32, __cil_tmp126);
#line 1617
      __cil_tmp127 = acb->io_port_base;
#line 1617
      __cil_tmp128 = __cil_tmp127 + 152UL;
#line 1617
      __cil_tmp129 = (int )__cil_tmp128;
#line 1617
      outb(tag_number, __cil_tmp129);
#line 1618
      __cil_tmp130 = dcb->tag_mask;
#line 1618
      dcb->tag_mask = __cil_tmp130 | tag_mask;
#line 1619
      srb->tag_number = tag_number;
#line 1620
      scsicommand = (u8 )100;
#line 1621
      srb->state = (u16 )64;
      }
    } else {

    }
    }
  } else {

  }
  }
  {
#line 1626
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 1626
    goto while_break___4;
  }
  while_break___12: /* CIL Label */ ;
  }

  while_break___4: ;
  {
#line 1629
  __cil_tmp131 = srb->flag;
#line 1629
  __cil_tmp132 = (int )__cil_tmp131;
#line 1629
  if (__cil_tmp132 & 1) {
    {
#line 1630
    __cil_tmp133 = acb->io_port_base;
#line 1630
    __cil_tmp134 = __cil_tmp133 + 152UL;
#line 1630
    __cil_tmp135 = (int )__cil_tmp134;
#line 1630
    outb((unsigned char)3, __cil_tmp135);
#line 1631
    __cil_tmp136 = dcb->target_lun;
#line 1631
    __cil_tmp137 = (int )__cil_tmp136;
#line 1631
    __cil_tmp138 = __cil_tmp137 << 5;
#line 1631
    __cil_tmp139 = (unsigned char )__cil_tmp138;
#line 1631
    __cil_tmp140 = acb->io_port_base;
#line 1631
    __cil_tmp141 = __cil_tmp140 + 152UL;
#line 1631
    __cil_tmp142 = (int )__cil_tmp141;
#line 1631
    outb(__cil_tmp139, __cil_tmp142);
#line 1632
    __cil_tmp143 = acb->io_port_base;
#line 1632
    __cil_tmp144 = __cil_tmp143 + 152UL;
#line 1632
    __cil_tmp145 = (int )__cil_tmp144;
#line 1632
    outb((unsigned char)0, __cil_tmp145);
#line 1633
    __cil_tmp146 = acb->io_port_base;
#line 1633
    __cil_tmp147 = __cil_tmp146 + 152UL;
#line 1633
    __cil_tmp148 = (int )__cil_tmp147;
#line 1633
    outb((unsigned char)0, __cil_tmp148);
#line 1634
    __cil_tmp149 = acb->io_port_base;
#line 1634
    __cil_tmp150 = __cil_tmp149 + 152UL;
#line 1634
    __cil_tmp151 = (int )__cil_tmp150;
#line 1634
    outb((unsigned char)96, __cil_tmp151);
#line 1635
    __cil_tmp152 = acb->io_port_base;
#line 1635
    __cil_tmp153 = __cil_tmp152 + 152UL;
#line 1635
    __cil_tmp154 = (int )__cil_tmp153;
#line 1635
    outb((unsigned char)0, __cil_tmp154);
    }
  } else {
#line 1637
    __cil_tmp155 = srb->cmd;
#line 1637
    ptr = __cil_tmp155->cmnd;
#line 1638
    i = (u8 )0;
    {
#line 1638
    while (1) {
      while_continue___5: /* CIL Label */ ;

      {
#line 1638
      __cil_tmp156 = srb->cmd;
#line 1638
      __cil_tmp157 = __cil_tmp156->cmd_len;
#line 1638
      __cil_tmp158 = (int )__cil_tmp157;
#line 1638
      __cil_tmp159 = (int )i;
#line 1638
      if (__cil_tmp159 < __cil_tmp158) {

      } else {
#line 1638
        goto while_break___5;
      }
      }
      {
#line 1639
      tmp___11 = ptr;
#line 1639
      ptr = ptr + 1;
#line 1639
      __cil_tmp160 = *tmp___11;
#line 1639
      __cil_tmp161 = acb->io_port_base;
#line 1639
      __cil_tmp162 = __cil_tmp161 + 152UL;
#line 1639
      __cil_tmp163 = (int )__cil_tmp162;
#line 1639
      outb(__cil_tmp160, __cil_tmp163);
#line 1638
      __cil_tmp164 = (int )i;
#line 1638
      __cil_tmp165 = __cil_tmp164 + 1;
#line 1638
      i = (u8 )__cil_tmp165;
      }
    }
    while_break___13: /* CIL Label */ ;
    }

    while_break___5: ;
  }
  }
  no_cmd: 
  {
#line 1642
  __cil_tmp166 = acb->io_port_base;
#line 1642
  __cil_tmp167 = __cil_tmp166 + 128UL;
#line 1642
  __cil_tmp168 = (int )__cil_tmp167;
#line 1642
  outw((unsigned short)3, __cil_tmp168);
#line 1644
  __cil_tmp169 = acb->io_port_base;
#line 1644
  __cil_tmp170 = __cil_tmp169 + 128UL;
#line 1644
  __cil_tmp171 = (int )__cil_tmp170;
#line 1644
  tmp___12 = inw(__cil_tmp171);
  }
  {
#line 1644
  __cil_tmp172 = (int )tmp___12;
#line 1644
  if (__cil_tmp172 & 128) {
    {
#line 1650
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1650
      goto while_break___6;
    }
    while_break___14: /* CIL Label */ ;
    }

    while_break___6: 
    {
#line 1652
    srb->state = (u16 )2;
#line 1653
    free_tag(dcb, srb);
#line 1654
    srb->msg_count = (u8 )0;
#line 1655
    return_code = (u16 )1;
    }
  } else {
    {
#line 1662
    srb->scsi_phase = (u8 )5;
#line 1663
    dcb->active_srb = srb;
#line 1664
    acb->active_dcb = dcb;
#line 1665
    return_code = (u16 )0;
#line 1667
    __cil_tmp173 = acb->io_port_base;
#line 1667
    __cil_tmp174 = __cil_tmp173 + 128UL;
#line 1667
    __cil_tmp175 = (int )__cil_tmp174;
#line 1667
    outw((unsigned short)3, __cil_tmp175);
#line 1670
    __cil_tmp176 = acb->io_port_base;
#line 1670
    __cil_tmp177 = __cil_tmp176 + 144UL;
#line 1670
    __cil_tmp178 = (int )__cil_tmp177;
#line 1670
    outb(scsicommand, __cil_tmp178);
    }
  }
  }
#line 1672
  return ((u8 )return_code);
}
}
#line 1682 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
__inline static void enable_msgout_abort(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  u16 __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  u16 __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  u16 __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1685
  srb->msgout_buf[0] = (u8 )6;
#line 1686
  srb->msg_count = (u8 )1;
#line 1687
  __cil_tmp3 = acb->io_port_base;
#line 1687
  __cil_tmp4 = __cil_tmp3 + 128UL;
#line 1687
  __cil_tmp5 = (int )__cil_tmp4;
#line 1687
  outw((unsigned short)512, __cil_tmp5);
#line 1687
  __cil_tmp6 = srb->state;
#line 1687
  __cil_tmp7 = (int )__cil_tmp6;
#line 1687
  __cil_tmp8 = __cil_tmp7 | 4;
#line 1687
  srb->state = (u16 )__cil_tmp8;
#line 1688
  __cil_tmp9 = srb->state;
#line 1688
  __cil_tmp10 = (int )__cil_tmp9;
#line 1688
  __cil_tmp11 = __cil_tmp10 & -9;
#line 1688
  srb->state = (u16 )__cil_tmp11;
#line 1689
  __cil_tmp12 = srb->state;
#line 1689
  __cil_tmp13 = (int )__cil_tmp12;
#line 1689
  __cil_tmp14 = __cil_tmp13 | 4;
#line 1689
  srb->state = (u16 )__cil_tmp14;
  }
#line 1690
  return;
}
}
#line 1700 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void dc395x_handle_interrupt(struct AdapterCtlBlk *acb , u16 scsi_status ) 
{ struct DeviceCtlBlk *dcb ;
  struct ScsiReqBlk *srb ;
  u16 phase ;
  u8 scsi_intstatus ;
  unsigned long flags ;
  void (*dc395x_statev)(struct AdapterCtlBlk * , struct ScsiReqBlk * , u16 * ) ;
  raw_spinlock_t *tmp___7 ;
  unsigned char tmp___8 ;
  int tmp___9 ;
  struct Scsi_Host *__cil_tmp12 ;
  spinlock_t *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  struct timer_list *__cil_tmp20 ;
  struct timer_list  const  *__cil_tmp21 ;
  struct timer_list *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  u8 __cil_tmp30 ;
  int __cil_tmp31 ;
  u8 __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  struct Scsi_Host *__cil_tmp37 ;
  spinlock_t *__cil_tmp38 ;

  {
  {
#line 1711
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 1711
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1711
      __cil_tmp12 = acb->scsi_host;
#line 1711
      __cil_tmp13 = __cil_tmp12->host_lock;
#line 1711
      tmp___7 = spinlock_check(__cil_tmp13);
#line 1711
      flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 1711
      goto while_break___0;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: ;
#line 1711
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1714
  __cil_tmp14 = acb->io_port_base;
#line 1714
  __cil_tmp15 = __cil_tmp14 + 132UL;
#line 1714
  __cil_tmp16 = (int )__cil_tmp15;
#line 1714
  tmp___8 = inb(__cil_tmp16);
#line 1714
  scsi_intstatus = tmp___8;
  }
  {
#line 1715
  __cil_tmp17 = (int )scsi_status;
#line 1715
  __cil_tmp18 = __cil_tmp17 & 8199;
#line 1715
  if (__cil_tmp18 == 8194) {
    {
#line 1716
    __cil_tmp19 = (int )scsi_status;
#line 1716
    printk("<7>dc395x: COP after COP completed? %04x\n", __cil_tmp19);
    }
  } else {

  }
  }
  {
#line 1724
  __cil_tmp20 = & acb->selto_timer;
#line 1724
  __cil_tmp21 = (struct timer_list  const  *)__cil_tmp20;
#line 1724
  tmp___9 = timer_pending(__cil_tmp21);
  }
#line 1724
  if (tmp___9) {
    {
#line 1725
    __cil_tmp22 = & acb->selto_timer;
#line 1725
    del_timer(__cil_tmp22);
    }
  } else {

  }
  {
#line 1727
  __cil_tmp23 = (int )scsi_intstatus;
#line 1727
  if (__cil_tmp23 & 48) {
    {
#line 1728
    disconnect(acb);
    }
#line 1729
    goto out_unlock;
  } else {

  }
  }
  {
#line 1731
  __cil_tmp24 = (int )scsi_intstatus;
#line 1731
  if (__cil_tmp24 & 8) {
    {
#line 1732
    reselect(acb);
    }
#line 1733
    goto out_unlock;
  } else {

  }
  }
  {
#line 1735
  __cil_tmp25 = (int )scsi_intstatus;
#line 1735
  if (__cil_tmp25 & 64) {
    {
#line 1736
    printk("<6>dc395x: Host does not support target mode!\n");
    }
#line 1737
    goto out_unlock;
  } else {

  }
  }
  {
#line 1739
  __cil_tmp26 = (int )scsi_intstatus;
#line 1739
  if (__cil_tmp26 & 4) {
    {
#line 1740
    scsi_reset_detect(acb);
    }
#line 1741
    goto out_unlock;
  } else {

  }
  }
  {
#line 1743
  __cil_tmp27 = (int )scsi_intstatus;
#line 1743
  if (__cil_tmp27 & 3) {
#line 1744
    dcb = acb->active_dcb;
#line 1745
    if (! dcb) {
      {
#line 1746
      __cil_tmp28 = (int )scsi_status;
#line 1746
      __cil_tmp29 = (int )scsi_intstatus;
#line 1746
      printk("<7>dc395x: Oops: BusService (%04x %02x) w/o ActiveDCB!\n", __cil_tmp28,
             __cil_tmp29);
      }
#line 1749
      goto out_unlock;
    } else {

    }
#line 1751
    srb = dcb->active_srb;
    {
#line 1752
    __cil_tmp30 = dcb->flag;
#line 1752
    __cil_tmp31 = (int )__cil_tmp30;
#line 1752
    if (__cil_tmp31 & 1) {
      {
#line 1753
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1753
        goto while_break___1;
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___1: 
      {
#line 1754
      enable_msgout_abort(acb, srb);
      }
    } else {

    }
    }
    {
#line 1758
    __cil_tmp32 = srb->scsi_phase;
#line 1758
    phase = (u16 )__cil_tmp32;
#line 1773
    dc395x_statev = (void (*)(struct AdapterCtlBlk * , struct ScsiReqBlk * , u16 * ))dc395x_scsi_phase0[phase];
#line 1774
    (*dc395x_statev)(acb, srb, & scsi_status);
#line 1781
    __cil_tmp33 = (int )scsi_status;
#line 1781
    __cil_tmp34 = __cil_tmp33 & 7;
#line 1781
    srb->scsi_phase = (u8 )__cil_tmp34;
#line 1782
    __cil_tmp35 = (int )scsi_status;
#line 1782
    __cil_tmp36 = __cil_tmp35 & 7;
#line 1782
    phase = (u16 )__cil_tmp36;
#line 1796
    dc395x_statev = (void (*)(struct AdapterCtlBlk * , struct ScsiReqBlk * , u16 * ))dc395x_scsi_phase1[phase];
#line 1797
    (*dc395x_statev)(acb, srb, & scsi_status);
    }
  } else {

  }
  }
  out_unlock: 
  {
#line 1800
  __cil_tmp37 = acb->scsi_host;
#line 1800
  __cil_tmp38 = __cil_tmp37->host_lock;
#line 1800
  spin_unlock_irqrestore(__cil_tmp38, flags);
  }
#line 1801
  return;
}
}
#line 1804 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static irqreturn_t dc395x_interrupt(int irq , void *dev_id ) 
{ struct AdapterCtlBlk *acb ;
  u16 scsi_status ;
  u8 dma_status ;
  irqreturn_t handled ;
  unsigned short tmp___7 ;
  unsigned char tmp___8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  void *__cil_tmp18 ;

  {
  {
#line 1806
  acb = (struct AdapterCtlBlk *)dev_id;
#line 1809
  handled = (irqreturn_t )0;
#line 1814
  __cil_tmp9 = acb->io_port_base;
#line 1814
  __cil_tmp10 = __cil_tmp9 + 128UL;
#line 1814
  __cil_tmp11 = (int )__cil_tmp10;
#line 1814
  tmp___7 = inw(__cil_tmp11);
#line 1814
  scsi_status = tmp___7;
#line 1815
  __cil_tmp12 = acb->io_port_base;
#line 1815
  __cil_tmp13 = __cil_tmp12 + 163UL;
#line 1815
  __cil_tmp14 = (int )__cil_tmp13;
#line 1815
  tmp___8 = inb(__cil_tmp14);
#line 1815
  dma_status = tmp___8;
  }
  {
#line 1816
  __cil_tmp15 = (int )scsi_status;
#line 1816
  if (__cil_tmp15 & 128) {
    {
#line 1818
    dc395x_handle_interrupt(acb, scsi_status);
#line 1819
    handled = (irqreturn_t )1;
    }
  } else {
    {
#line 1821
    __cil_tmp16 = (int )dma_status;
#line 1821
    if (__cil_tmp16 & 32) {
      {
#line 1823
      __cil_tmp17 = (int )dma_status;
#line 1823
      printk("<6>dc395x: Interrupt from DMA engine: 0x%02x!\n", __cil_tmp17);
#line 1833
      printk("<6>dc395x: Ignoring DMA error (probably a bad thing) ...\n");
#line 1834
      __cil_tmp18 = (void *)0;
#line 1834
      acb = (struct AdapterCtlBlk *)__cil_tmp18;
#line 1836
      handled = (irqreturn_t )1;
      }
    } else {

    }
    }
  }
  }
#line 1839
  return (handled);
}
}
#line 1843 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void msgout_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ u16 __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  u16 __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1846
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1846
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 1847
  __cil_tmp4 = srb->state;
#line 1847
  __cil_tmp5 = (int )__cil_tmp4;
#line 1847
  if (__cil_tmp5 & 36864) {
#line 1848
    *pscsi_status = (u16 )5;
  } else {

  }
  }
  {
#line 1850
  __cil_tmp6 = acb->io_port_base;
#line 1850
  __cil_tmp7 = __cil_tmp6 + 128UL;
#line 1850
  __cil_tmp8 = (int )__cil_tmp7;
#line 1850
  outw((unsigned short)2, __cil_tmp8);
#line 1851
  __cil_tmp9 = srb->state;
#line 1851
  __cil_tmp10 = (int )__cil_tmp9;
#line 1851
  __cil_tmp11 = __cil_tmp10 & -5;
#line 1851
  srb->state = (u16 )__cil_tmp11;
  }
#line 1852
  return;
}
}
#line 1855 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void msgout_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ u16 i ;
  u8 *ptr ;
  u8 *tmp___7 ;
  char *__cil_tmp7 ;
  u16 __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  u16 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  struct scsi_cmnd *__cil_tmp14 ;
  u8 __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  u8 __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  u8 __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  u8 __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;

  {
  {
#line 1860
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1860
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1862
  __cil_tmp7 = (char *)"msgout_phase1";
#line 1862
  clear_fifo(acb, __cil_tmp7);
  }
  {
#line 1863
  __cil_tmp8 = srb->state;
#line 1863
  __cil_tmp9 = (int )__cil_tmp8;
#line 1863
  __cil_tmp10 = __cil_tmp9 & 4;
#line 1863
  if (! __cil_tmp10) {
    {
#line 1864
    __cil_tmp11 = srb->state;
#line 1864
    __cil_tmp12 = (int )__cil_tmp11;
#line 1864
    __cil_tmp13 = __cil_tmp12 | 4;
#line 1864
    srb->state = (u16 )__cil_tmp13;
#line 1865
    __cil_tmp14 = srb->cmd;
#line 1865
    printk("<7>dc395x: msgout_phase1: (0x%p) Phase unexpected\n", __cil_tmp14);
    }
  } else {

  }
  }
  {
#line 1869
  __cil_tmp15 = srb->msg_count;
#line 1869
  if (! __cil_tmp15) {
    {
#line 1870
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1870
      goto while_break___0;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 1872
    __cil_tmp16 = acb->io_port_base;
#line 1872
    __cil_tmp17 = __cil_tmp16 + 152UL;
#line 1872
    __cil_tmp18 = (int )__cil_tmp17;
#line 1872
    outb((unsigned char)8, __cil_tmp18);
#line 1873
    __cil_tmp19 = acb->io_port_base;
#line 1873
    __cil_tmp20 = __cil_tmp19 + 128UL;
#line 1873
    __cil_tmp21 = (int )__cil_tmp20;
#line 1873
    outw((unsigned short)2, __cil_tmp21);
#line 1874
    __cil_tmp22 = acb->io_port_base;
#line 1874
    __cil_tmp23 = __cil_tmp22 + 144UL;
#line 1874
    __cil_tmp24 = (int )__cil_tmp23;
#line 1874
    outb((unsigned char)192, __cil_tmp24);
    }
#line 1875
    return;
  } else {

  }
  }
#line 1877
  ptr = & srb->msgout_buf[0];
#line 1878
  i = (u16 )0;
  {
#line 1878
  while (1) {
    while_continue___1: /* CIL Label */ ;

    {
#line 1878
    __cil_tmp25 = srb->msg_count;
#line 1878
    __cil_tmp26 = (int )__cil_tmp25;
#line 1878
    __cil_tmp27 = (int )i;
#line 1878
    if (__cil_tmp27 < __cil_tmp26) {

    } else {
#line 1878
      goto while_break___1;
    }
    }
    {
#line 1879
    tmp___7 = ptr;
#line 1879
    ptr = ptr + 1;
#line 1879
    __cil_tmp28 = *tmp___7;
#line 1879
    __cil_tmp29 = acb->io_port_base;
#line 1879
    __cil_tmp30 = __cil_tmp29 + 152UL;
#line 1879
    __cil_tmp31 = (int )__cil_tmp30;
#line 1879
    outb(__cil_tmp28, __cil_tmp31);
#line 1878
    __cil_tmp32 = (int )i;
#line 1878
    __cil_tmp33 = __cil_tmp32 + 1;
#line 1878
    i = (u16 )__cil_tmp33;
    }
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___1: 
#line 1880
  srb->msg_count = (u8 )0;
  {
#line 1881
  __cil_tmp34 = srb->msgout_buf[0];
#line 1881
  __cil_tmp35 = (int )__cil_tmp34;
#line 1881
  if (__cil_tmp35 == 6) {
#line 1882
    srb->state = (u16 )4096;
  } else {

  }
  }
  {
#line 1884
  __cil_tmp36 = acb->io_port_base;
#line 1884
  __cil_tmp37 = __cil_tmp36 + 144UL;
#line 1884
  __cil_tmp38 = (int )__cil_tmp37;
#line 1884
  outb((unsigned char)192, __cil_tmp38);
  }
#line 1885
  return;
}
}
#line 1888 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void command_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1891
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1891
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1892
  __cil_tmp4 = acb->io_port_base;
#line 1892
  __cil_tmp5 = __cil_tmp4 + 128UL;
#line 1892
  __cil_tmp6 = (int )__cil_tmp5;
#line 1892
  outw((unsigned short)2, __cil_tmp6);
  }
#line 1893
  return;
}
}
#line 1896 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void command_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ struct DeviceCtlBlk *dcb ;
  u8 *ptr ;
  u16 i ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  u8 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  struct scsi_cmnd *__cil_tmp14 ;
  struct scsi_cmnd *__cil_tmp15 ;
  unsigned short __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  u8 __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  u8 __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned char __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  int __cil_tmp46 ;
  u16 __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  int __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  int __cil_tmp55 ;

  {
  {
#line 1902
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1902
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1904
  __cil_tmp7 = (char *)"command_phase1";
#line 1904
  clear_fifo(acb, __cil_tmp7);
#line 1905
  __cil_tmp8 = acb->io_port_base;
#line 1905
  __cil_tmp9 = __cil_tmp8 + 128UL;
#line 1905
  __cil_tmp10 = (int )__cil_tmp9;
#line 1905
  outw((unsigned short)1024, __cil_tmp10);
  }
  {
#line 1906
  __cil_tmp11 = srb->flag;
#line 1906
  __cil_tmp12 = (int )__cil_tmp11;
#line 1906
  __cil_tmp13 = __cil_tmp12 & 1;
#line 1906
  if (! __cil_tmp13) {
#line 1907
    __cil_tmp14 = srb->cmd;
#line 1907
    ptr = __cil_tmp14->cmnd;
#line 1908
    i = (u16 )0;
    {
#line 1908
    while (1) {
      while_continue___0: /* CIL Label */ ;

      {
#line 1908
      __cil_tmp15 = srb->cmd;
#line 1908
      __cil_tmp16 = __cil_tmp15->cmd_len;
#line 1908
      __cil_tmp17 = (int )__cil_tmp16;
#line 1908
      __cil_tmp18 = (int )i;
#line 1908
      if (__cil_tmp18 < __cil_tmp17) {

      } else {
#line 1908
        goto while_break___0;
      }
      }
      {
#line 1909
      __cil_tmp19 = *ptr;
#line 1909
      __cil_tmp20 = acb->io_port_base;
#line 1909
      __cil_tmp21 = __cil_tmp20 + 152UL;
#line 1909
      __cil_tmp22 = (int )__cil_tmp21;
#line 1909
      outb(__cil_tmp19, __cil_tmp22);
#line 1910
      ptr = ptr + 1;
#line 1908
      __cil_tmp23 = (int )i;
#line 1908
      __cil_tmp24 = __cil_tmp23 + 1;
#line 1908
      i = (u16 )__cil_tmp24;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  } else {
    {
#line 1913
    __cil_tmp25 = acb->io_port_base;
#line 1913
    __cil_tmp26 = __cil_tmp25 + 152UL;
#line 1913
    __cil_tmp27 = (int )__cil_tmp26;
#line 1913
    outb((unsigned char)3, __cil_tmp27);
#line 1914
    dcb = acb->active_dcb;
#line 1916
    __cil_tmp28 = dcb->target_lun;
#line 1916
    __cil_tmp29 = (int )__cil_tmp28;
#line 1916
    __cil_tmp30 = __cil_tmp29 << 5;
#line 1916
    __cil_tmp31 = (unsigned char )__cil_tmp30;
#line 1916
    __cil_tmp32 = acb->io_port_base;
#line 1916
    __cil_tmp33 = __cil_tmp32 + 152UL;
#line 1916
    __cil_tmp34 = (int )__cil_tmp33;
#line 1916
    outb(__cil_tmp31, __cil_tmp34);
#line 1917
    __cil_tmp35 = acb->io_port_base;
#line 1917
    __cil_tmp36 = __cil_tmp35 + 152UL;
#line 1917
    __cil_tmp37 = (int )__cil_tmp36;
#line 1917
    outb((unsigned char)0, __cil_tmp37);
#line 1918
    __cil_tmp38 = acb->io_port_base;
#line 1918
    __cil_tmp39 = __cil_tmp38 + 152UL;
#line 1918
    __cil_tmp40 = (int )__cil_tmp39;
#line 1918
    outb((unsigned char)0, __cil_tmp40);
#line 1919
    __cil_tmp41 = acb->io_port_base;
#line 1919
    __cil_tmp42 = __cil_tmp41 + 152UL;
#line 1919
    __cil_tmp43 = (int )__cil_tmp42;
#line 1919
    outb((unsigned char)96, __cil_tmp43);
#line 1920
    __cil_tmp44 = acb->io_port_base;
#line 1920
    __cil_tmp45 = __cil_tmp44 + 152UL;
#line 1920
    __cil_tmp46 = (int )__cil_tmp45;
#line 1920
    outb((unsigned char)0, __cil_tmp46);
    }
  }
  }
  {
#line 1922
  __cil_tmp47 = srb->state;
#line 1922
  __cil_tmp48 = (int )__cil_tmp47;
#line 1922
  __cil_tmp49 = __cil_tmp48 | 32;
#line 1922
  srb->state = (u16 )__cil_tmp49;
#line 1924
  __cil_tmp50 = acb->io_port_base;
#line 1924
  __cil_tmp51 = __cil_tmp50 + 128UL;
#line 1924
  __cil_tmp52 = (int )__cil_tmp51;
#line 1924
  outw((unsigned short)2, __cil_tmp52);
#line 1926
  __cil_tmp53 = acb->io_port_base;
#line 1926
  __cil_tmp54 = __cil_tmp53 + 144UL;
#line 1926
  __cil_tmp55 = (int )__cil_tmp54;
#line 1926
  outb((unsigned char)192, __cil_tmp55);
  }
#line 1927
  return;
}
}
#line 1934 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void sg_verify_length(struct ScsiReqBlk *srb ) 
{ 

  {
#line 1947
  return;
}
}
#line 1954 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void sg_update_list(struct ScsiReqBlk *srb , u32 left ) 
{ u8 idx ;
  u32 xferred ;
  struct SGentry *psge ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  u8 __cil_tmp9 ;
  int __cil_tmp10 ;
  struct SGentry *__cil_tmp11 ;
  u8 __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  u32 __cil_tmp15 ;
  u32 __cil_tmp16 ;
  u32 __cil_tmp17 ;
  u32 __cil_tmp18 ;
  struct DeviceCtlBlk *__cil_tmp19 ;
  struct AdapterCtlBlk *__cil_tmp20 ;
  struct pci_dev *__cil_tmp21 ;
  dma_addr_t __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;

  {
#line 1957
  __cil_tmp6 = (size_t )left;
#line 1957
  __cil_tmp7 = srb->total_xfer_length;
#line 1957
  __cil_tmp8 = __cil_tmp7 - __cil_tmp6;
#line 1957
  xferred = (u32 )__cil_tmp8;
#line 1958
  __cil_tmp9 = srb->sg_index;
#line 1958
  __cil_tmp10 = (int )__cil_tmp9;
#line 1958
  __cil_tmp11 = srb->segment_x;
#line 1958
  psge = __cil_tmp11 + __cil_tmp10;
  {
#line 1960
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1960
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 1963
  if (xferred == 0U) {
#line 1965
    return;
  } else {

  }
  {
#line 1968
  sg_verify_length(srb);
#line 1969
  srb->total_xfer_length = (size_t )left;
#line 1970
  idx = srb->sg_index;
  }
  {
#line 1970
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 1970
    __cil_tmp12 = srb->sg_count;
#line 1970
    __cil_tmp13 = (int )__cil_tmp12;
#line 1970
    __cil_tmp14 = (int )idx;
#line 1970
    if (__cil_tmp14 < __cil_tmp13) {

    } else {
#line 1970
      goto while_break___0;
    }
    }
    {
#line 1971
    __cil_tmp15 = psge->length;
#line 1971
    if (xferred >= __cil_tmp15) {
#line 1973
      __cil_tmp16 = psge->length;
#line 1973
      xferred = xferred - __cil_tmp16;
    } else {
      {
#line 1976
      __cil_tmp17 = psge->length;
#line 1976
      psge->length = __cil_tmp17 - xferred;
#line 1977
      __cil_tmp18 = psge->address;
#line 1977
      psge->address = __cil_tmp18 + xferred;
#line 1978
      srb->sg_index = idx;
#line 1979
      __cil_tmp19 = srb->dcb;
#line 1979
      __cil_tmp20 = __cil_tmp19->acb;
#line 1979
      __cil_tmp21 = __cil_tmp20->dev;
#line 1979
      __cil_tmp22 = srb->sg_bus_addr;
#line 1979
      __cil_tmp23 = 8UL * 64UL;
#line 1979
      pci_dma_sync_single_for_device(__cil_tmp21, __cil_tmp22, __cil_tmp23, 1);
      }
#line 1984
      goto while_break___0;
    }
    }
#line 1986
    psge = psge + 1;
#line 1970
    __cil_tmp24 = (int )idx;
#line 1970
    __cil_tmp25 = __cil_tmp24 + 1;
#line 1970
    idx = (u8 )__cil_tmp25;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 1988
  sg_verify_length(srb);
  }
#line 1989
  return;
}
}
#line 1998 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void sg_subtract_one(struct ScsiReqBlk *srb ) 
{ size_t __cil_tmp2 ;
  size_t __cil_tmp3 ;
  u32 __cil_tmp4 ;

  {
  {
#line 2000
  __cil_tmp2 = srb->total_xfer_length;
#line 2000
  __cil_tmp3 = __cil_tmp2 - 1UL;
#line 2000
  __cil_tmp4 = (u32 )__cil_tmp3;
#line 2000
  sg_update_list(srb, __cil_tmp4);
  }
#line 2001
  return;
}
}
#line 2012 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void cleanup_after_transfer(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  unsigned short tmp___11 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  char *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;

  {
  {
#line 2016
  __cil_tmp8 = acb->io_port_base;
#line 2016
  __cil_tmp9 = __cil_tmp8 + 160UL;
#line 2016
  __cil_tmp10 = (int )__cil_tmp9;
#line 2016
  tmp___11 = inw(__cil_tmp10);
  }
  {
#line 2016
  __cil_tmp11 = (int )tmp___11;
#line 2016
  if (__cil_tmp11 & 1) {
    {
#line 2017
    __cil_tmp12 = acb->io_port_base;
#line 2017
    __cil_tmp13 = __cil_tmp12 + 130UL;
#line 2017
    __cil_tmp14 = (int )__cil_tmp13;
#line 2017
    tmp___7 = inb(__cil_tmp14);
    }
    {
#line 2017
    __cil_tmp15 = (int )tmp___7;
#line 2017
    if (__cil_tmp15 & 64) {

    } else {
      {
#line 2018
      __cil_tmp16 = (char *)"cleanup/in";
#line 2018
      clear_fifo(acb, __cil_tmp16);
      }
    }
    }
    {
#line 2019
    __cil_tmp17 = acb->io_port_base;
#line 2019
    __cil_tmp18 = __cil_tmp17 + 162UL;
#line 2019
    __cil_tmp19 = (int )__cil_tmp18;
#line 2019
    tmp___8 = inb(__cil_tmp19);
    }
    {
#line 2019
    __cil_tmp20 = (int )tmp___8;
#line 2019
    if (__cil_tmp20 & 128) {

    } else {
      {
#line 2020
      __cil_tmp21 = acb->io_port_base;
#line 2020
      __cil_tmp22 = __cil_tmp21 + 161UL;
#line 2020
      __cil_tmp23 = (int )__cil_tmp22;
#line 2020
      outb((unsigned char)2, __cil_tmp23);
      }
    }
    }
  } else {
    {
#line 2022
    __cil_tmp24 = acb->io_port_base;
#line 2022
    __cil_tmp25 = __cil_tmp24 + 162UL;
#line 2022
    __cil_tmp26 = (int )__cil_tmp25;
#line 2022
    tmp___9 = inb(__cil_tmp26);
    }
    {
#line 2022
    __cil_tmp27 = (int )tmp___9;
#line 2022
    if (__cil_tmp27 & 128) {

    } else {
      {
#line 2023
      __cil_tmp28 = acb->io_port_base;
#line 2023
      __cil_tmp29 = __cil_tmp28 + 161UL;
#line 2023
      __cil_tmp30 = (int )__cil_tmp29;
#line 2023
      outb((unsigned char)2, __cil_tmp30);
      }
    }
    }
    {
#line 2024
    __cil_tmp31 = acb->io_port_base;
#line 2024
    __cil_tmp32 = __cil_tmp31 + 130UL;
#line 2024
    __cil_tmp33 = (int )__cil_tmp32;
#line 2024
    tmp___10 = inb(__cil_tmp33);
    }
    {
#line 2024
    __cil_tmp34 = (int )tmp___10;
#line 2024
    if (__cil_tmp34 & 64) {

    } else {
      {
#line 2025
      __cil_tmp35 = (char *)"cleanup/out";
#line 2025
      clear_fifo(acb, __cil_tmp35);
      }
    }
    }
  }
  }
  {
#line 2027
  __cil_tmp36 = acb->io_port_base;
#line 2027
  __cil_tmp37 = __cil_tmp36 + 128UL;
#line 2027
  __cil_tmp38 = (int )__cil_tmp37;
#line 2027
  outw((unsigned short)2, __cil_tmp38);
  }
#line 2028
  return;
}
}
#line 2038 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void data_out_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ struct DeviceCtlBlk *dcb ;
  u16 scsi_status ;
  u32 d_left_counter ;
  unsigned char tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  long oldxferred ;
  int diff ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  u16 __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  u8 __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  u8 __cil_tmp31 ;
  int __cil_tmp32 ;
  size_t __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  u8 __cil_tmp37 ;
  int __cil_tmp38 ;
  struct scsi_cmnd *__cil_tmp39 ;
  int __cil_tmp40 ;
  size_t __cil_tmp41 ;
  size_t __cil_tmp42 ;
  size_t __cil_tmp43 ;
  u8 __cil_tmp44 ;
  int __cil_tmp45 ;
  u32 __cil_tmp46 ;
  u8 __cil_tmp47 ;
  int __cil_tmp48 ;
  struct SGentry *__cil_tmp49 ;
  struct SGentry *__cil_tmp50 ;
  u32 __cil_tmp51 ;
  struct scsi_cmnd *__cil_tmp52 ;
  size_t __cil_tmp53 ;
  size_t __cil_tmp54 ;
  size_t __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  unsigned long __cil_tmp64 ;
  size_t __cil_tmp65 ;
  size_t __cil_tmp66 ;
  size_t __cil_tmp67 ;
  u16 __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;

  {
#line 2041
  dcb = srb->dcb;
#line 2042
  scsi_status = *pscsi_status;
#line 2043
  d_left_counter = (u32 )0;
  {
#line 2044
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2044
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 2059
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2059
    goto while_break___0;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 2067
  __cil_tmp14 = acb->io_port_base;
#line 2067
  __cil_tmp15 = __cil_tmp14 + 161UL;
#line 2067
  __cil_tmp16 = (int )__cil_tmp15;
#line 2067
  outb((unsigned char)10, __cil_tmp16);
  }
  {
#line 2069
  __cil_tmp17 = srb->state;
#line 2069
  __cil_tmp18 = (int )__cil_tmp17;
#line 2069
  __cil_tmp19 = __cil_tmp18 & 512;
#line 2069
  if (! __cil_tmp19) {
    {
#line 2070
    __cil_tmp20 = (int )scsi_status;
#line 2070
    if (__cil_tmp20 & 8) {
#line 2071
      __cil_tmp21 = srb->status;
#line 2071
      __cil_tmp22 = (int )__cil_tmp21;
#line 2071
      __cil_tmp23 = __cil_tmp22 | 16;
#line 2071
      srb->status = (u8 )__cil_tmp23;
    } else {

    }
    }
    {
#line 2079
    __cil_tmp24 = (int )scsi_status;
#line 2079
    __cil_tmp25 = __cil_tmp24 & 2048;
#line 2079
    if (! __cil_tmp25) {
      {
#line 2084
      __cil_tmp26 = acb->io_port_base;
#line 2084
      __cil_tmp27 = __cil_tmp26 + 130UL;
#line 2084
      __cil_tmp28 = (int )__cil_tmp27;
#line 2084
      tmp___7 = inb(__cil_tmp28);
#line 2084
      __cil_tmp29 = (int )tmp___7;
#line 2084
      __cil_tmp30 = __cil_tmp29 & 31;
#line 2084
      d_left_counter = (u32 )__cil_tmp30;
      }
      {
#line 2087
      __cil_tmp31 = dcb->sync_period;
#line 2087
      __cil_tmp32 = (int )__cil_tmp31;
#line 2087
      if (__cil_tmp32 & 16) {
#line 2088
        d_left_counter = d_left_counter << 1;
      } else {

      }
      }
      {
#line 2090
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2090
        goto while_break___1;
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___1: ;
    } else {

    }
    }
    {
#line 2110
    __cil_tmp33 = srb->total_xfer_length;
#line 2110
    if (__cil_tmp33 > 4UL) {
      {
#line 2111
      __cil_tmp34 = acb->io_port_base;
#line 2111
      __cil_tmp35 = __cil_tmp34 + 136UL;
#line 2111
      __cil_tmp36 = (int )__cil_tmp35;
#line 2111
      tmp___8 = inl(__cil_tmp36);
#line 2111
      d_left_counter = d_left_counter + tmp___8;
      }
    } else {

    }
    }
#line 2117
    if (d_left_counter == 1U) {
      {
#line 2117
      __cil_tmp37 = dcb->sync_period;
#line 2117
      __cil_tmp38 = (int )__cil_tmp37;
#line 2117
      if (__cil_tmp38 & 16) {
        {
#line 2117
        __cil_tmp39 = srb->cmd;
#line 2117
        tmp___9 = scsi_bufflen(__cil_tmp39);
        }
#line 2117
        if (tmp___9 % 2U) {
          {
#line 2119
          d_left_counter = (u32 )0;
#line 2120
          __cil_tmp40 = (int )scsi_status;
#line 2120
          printk("<6>dc395x: data_out_phase0: Discard 1 byte (0x%02x)\n", __cil_tmp40);
          }
        } else {

        }
      } else {

      }
      }
    } else {

    }
#line 2134
    if (d_left_counter == 0U) {
#line 2135
      srb->total_xfer_length = (size_t )0;
    } else {
#line 2142
      __cil_tmp41 = (size_t )d_left_counter;
#line 2142
      __cil_tmp42 = srb->total_xfer_length;
#line 2142
      __cil_tmp43 = __cil_tmp42 - __cil_tmp41;
#line 2142
      oldxferred = (long )__cil_tmp43;
      {
#line 2144
      __cil_tmp44 = dcb->sync_period;
#line 2144
      __cil_tmp45 = (int )__cil_tmp44;
#line 2144
      if (__cil_tmp45 & 16) {
#line 2144
        tmp___10 = 2;
      } else {
#line 2144
        tmp___10 = 1;
      }
      }
      {
#line 2144
      diff = tmp___10;
#line 2146
      sg_update_list(srb, d_left_counter);
      }
      {
#line 2148
      __cil_tmp46 = (u32 )diff;
#line 2148
      __cil_tmp47 = srb->sg_index;
#line 2148
      __cil_tmp48 = (int )__cil_tmp47;
#line 2148
      __cil_tmp49 = srb->segment_x;
#line 2148
      __cil_tmp50 = __cil_tmp49 + __cil_tmp48;
#line 2148
      __cil_tmp51 = __cil_tmp50->length;
#line 2148
      if (__cil_tmp51 == __cil_tmp46) {
        {
#line 2148
        __cil_tmp52 = srb->cmd;
#line 2148
        tmp___11 = scsi_sg_count(__cil_tmp52);
        }
#line 2148
        if (tmp___11) {
          {
#line 2153
          printk("<6>dc395x: data_out_phase0: Work around chip bug (%i)?\n", diff);
#line 2155
          __cil_tmp53 = (size_t )diff;
#line 2155
          __cil_tmp54 = srb->total_xfer_length;
#line 2155
          __cil_tmp55 = __cil_tmp54 - __cil_tmp53;
#line 2155
          d_left_counter = (u32 )__cil_tmp55;
#line 2157
          sg_update_list(srb, d_left_counter);
          }
        } else {
#line 2148
          goto _L;
        }
      } else {
        _L: 
        {
#line 2148
        __cil_tmp56 = (unsigned long )diff;
#line 2148
        __cil_tmp57 = 1UL << 12;
#line 2148
        __cil_tmp58 = __cil_tmp57 - __cil_tmp56;
#line 2148
        __cil_tmp59 = 1UL << 12;
#line 2148
        __cil_tmp60 = __cil_tmp59 - 1UL;
#line 2148
        __cil_tmp61 = ~ __cil_tmp60;
#line 2148
        __cil_tmp62 = ~ __cil_tmp61;
#line 2148
        __cil_tmp63 = (unsigned long )oldxferred;
#line 2148
        __cil_tmp64 = __cil_tmp63 & __cil_tmp62;
#line 2148
        if (__cil_tmp64 == __cil_tmp58) {
          {
#line 2153
          printk("<6>dc395x: data_out_phase0: Work around chip bug (%i)?\n", diff);
#line 2155
          __cil_tmp65 = (size_t )diff;
#line 2155
          __cil_tmp66 = srb->total_xfer_length;
#line 2155
          __cil_tmp67 = __cil_tmp66 - __cil_tmp65;
#line 2155
          d_left_counter = (u32 )__cil_tmp67;
#line 2157
          sg_update_list(srb, d_left_counter);
          }
        } else {

        }
        }
      }
      }
    }
  } else {

  }
  }
  {
#line 2165
  __cil_tmp68 = *pscsi_status;
#line 2165
  __cil_tmp69 = (int )__cil_tmp68;
#line 2165
  __cil_tmp70 = __cil_tmp69 & 7;
#line 2165
  if (__cil_tmp70 != 0) {
    {
#line 2166
    cleanup_after_transfer(acb, srb);
    }
  } else {

  }
  }
#line 2168
  return;
}
}
#line 2171 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void data_out_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ char *__cil_tmp4 ;
  u16 __cil_tmp5 ;

  {
  {
#line 2174
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2174
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2176
  __cil_tmp4 = (char *)"data_out_phase1";
#line 2176
  clear_fifo(acb, __cil_tmp4);
#line 2178
  __cil_tmp5 = (u16 )256;
#line 2178
  data_io_transfer(acb, srb, __cil_tmp5);
  }
#line 2179
  return;
}
}
#line 2181 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void data_in_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ u16 scsi_status ;
  u32 d_left_counter ;
  unsigned int sc ;
  unsigned int fc ;
  unsigned char tmp___7 ;
  unsigned int tmp___8 ;
  unsigned char tmp___9 ;
  int tmp___10 ;
  size_t left_io ;
  unsigned char *virt ;
  unsigned char *base ;
  unsigned long flags ;
  size_t len ;
  size_t offset ;
  struct scatterlist *tmp___11 ;
  void *tmp___12 ;
  u8 byte ;
  unsigned char tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char tmp___15 ;
  int __ret_warn_on ;
  long tmp___16 ;
  u8 byte___0 ;
  unsigned char tmp___17 ;
  unsigned char *tmp___18 ;
  int tmp___19 ;
  u16 __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  struct scsi_cmnd *__cil_tmp34 ;
  u8 __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  int __cil_tmp47 ;
  struct DeviceCtlBlk *__cil_tmp48 ;
  u8 __cil_tmp49 ;
  int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  unsigned int __cil_tmp52 ;
  size_t __cil_tmp53 ;
  struct DeviceCtlBlk *__cil_tmp54 ;
  u8 __cil_tmp55 ;
  int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int __cil_tmp59 ;
  void *__cil_tmp60 ;
  size_t __cil_tmp61 ;
  struct scsi_cmnd *__cil_tmp62 ;
  u8 __cil_tmp63 ;
  int __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  int __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  long __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  long __cil_tmp82 ;
  struct DeviceCtlBlk *__cil_tmp83 ;
  u8 __cil_tmp84 ;
  int __cil_tmp85 ;
  size_t __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  int __cil_tmp89 ;
  size_t __cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  int __cil_tmp93 ;
  void *__cil_tmp94 ;
  int __cil_tmp95 ;
  u16 __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;

  {
#line 2184
  scsi_status = *pscsi_status;
  {
#line 2186
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2186
    goto while_break;
  }
  while_break___10: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 2202
  __cil_tmp30 = srb->state;
#line 2202
  __cil_tmp31 = (int )__cil_tmp30;
#line 2202
  __cil_tmp32 = __cil_tmp31 & 512;
#line 2202
  if (! __cil_tmp32) {
    {
#line 2206
    __cil_tmp33 = (int )scsi_status;
#line 2206
    if (__cil_tmp33 & 8) {
      {
#line 2207
      __cil_tmp34 = srb->cmd;
#line 2207
      printk("<6>dc395x: data_in_phase0: (0x%p) Parity Error\n", __cil_tmp34);
#line 2209
      __cil_tmp35 = srb->status;
#line 2209
      __cil_tmp36 = (int )__cil_tmp35;
#line 2209
      __cil_tmp37 = __cil_tmp36 | 16;
#line 2209
      srb->status = (u8 )__cil_tmp37;
      }
    } else {

    }
    }
    {
#line 2217
    __cil_tmp38 = acb->io_port_base;
#line 2217
    __cil_tmp39 = __cil_tmp38 + 162UL;
#line 2217
    __cil_tmp40 = (int )__cil_tmp39;
#line 2217
    tmp___7 = inb(__cil_tmp40);
    }
    {
#line 2217
    __cil_tmp41 = (int )tmp___7;
#line 2217
    if (__cil_tmp41 & 128) {

    } else {
      {
#line 2236
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2236
        goto while_break___0;
      }
      while_break___11: /* CIL Label */ ;
      }

      while_break___0: ;
    }
    }
    {
#line 2242
    __cil_tmp42 = acb->io_port_base;
#line 2242
    __cil_tmp43 = __cil_tmp42 + 136UL;
#line 2242
    __cil_tmp44 = (int )__cil_tmp43;
#line 2242
    tmp___8 = inl(__cil_tmp44);
#line 2242
    sc = tmp___8;
#line 2243
    __cil_tmp45 = acb->io_port_base;
#line 2243
    __cil_tmp46 = __cil_tmp45 + 130UL;
#line 2243
    __cil_tmp47 = (int )__cil_tmp46;
#line 2243
    tmp___9 = inb(__cil_tmp47);
#line 2243
    fc = (unsigned int )tmp___9;
    }
    {
#line 2244
    __cil_tmp48 = srb->dcb;
#line 2244
    __cil_tmp49 = __cil_tmp48->sync_period;
#line 2244
    __cil_tmp50 = (int )__cil_tmp49;
#line 2244
    if (__cil_tmp50 & 16) {
#line 2244
      tmp___10 = 1;
    } else {
#line 2244
      tmp___10 = 0;
    }
    }
#line 2244
    __cil_tmp51 = fc & 31U;
#line 2244
    __cil_tmp52 = __cil_tmp51 << tmp___10;
#line 2244
    d_left_counter = sc + __cil_tmp52;
    {
#line 2247
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 2247
      goto while_break___1;
    }
    while_break___12: /* CIL Label */ ;
    }

    while_break___1: ;
#line 2260
    if (d_left_counter) {
      {
#line 2260
      __cil_tmp53 = srb->total_xfer_length;
#line 2260
      if (__cil_tmp53 <= 4UL) {
#line 2262
        left_io = srb->total_xfer_length;
        {
#line 2266
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 2266
          goto while_break___2;
        }
        while_break___13: /* CIL Label */ ;
        }

        while_break___2: ;
        {
#line 2272
        __cil_tmp54 = srb->dcb;
#line 2272
        __cil_tmp55 = __cil_tmp54->sync_period;
#line 2272
        __cil_tmp56 = (int )__cil_tmp55;
#line 2272
        if (__cil_tmp56 & 16) {
          {
#line 2273
          __cil_tmp57 = acb->io_port_base;
#line 2273
          __cil_tmp58 = __cil_tmp57 + 143UL;
#line 2273
          __cil_tmp59 = (int )__cil_tmp58;
#line 2273
          outb((unsigned char)2, __cil_tmp59);
          }
        } else {

        }
        }
        {
#line 2275
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 2275
          if (left_io) {

          } else {
#line 2275
            goto while_break___3;
          }
#line 2276
          __cil_tmp60 = (void *)0;
#line 2276
          base = (unsigned char *)__cil_tmp60;
#line 2277
          flags = 0UL;
#line 2278
          len = left_io;
#line 2279
          __cil_tmp61 = srb->request_length;
#line 2279
          offset = __cil_tmp61 - left_io;
          {
#line 2281
          while (1) {
            while_continue___4: /* CIL Label */ ;

            {
#line 2281
            while (1) {
              while_continue___5: /* CIL Label */ ;
              {
#line 2281
              flags = arch_local_irq_save();
              }
#line 2281
              goto while_break___5;
            }
            while_break___16: /* CIL Label */ ;
            }

            while_break___5: 
            {
#line 2281
            trace_hardirqs_off();
            }
#line 2281
            goto while_break___4;
          }
          while_break___15: /* CIL Label */ ;
          }

          while_break___4: 
          {
#line 2284
          __cil_tmp62 = srb->cmd;
#line 2284
          tmp___11 = scsi_sglist(__cil_tmp62);
#line 2284
          __cil_tmp63 = srb->sg_count;
#line 2284
          __cil_tmp64 = (int )__cil_tmp63;
#line 2284
          tmp___12 = scsi_kmap_atomic_sg(tmp___11, __cil_tmp64, & offset, & len);
#line 2284
          base = (unsigned char *)tmp___12;
#line 2286
          virt = base + offset;
#line 2288
          left_io = left_io - len;
          }
          {
#line 2290
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 2290
            if (len) {

            } else {
#line 2290
              goto while_break___6;
            }
            {
#line 2292
            __cil_tmp65 = acb->io_port_base;
#line 2292
            __cil_tmp66 = __cil_tmp65 + 152UL;
#line 2292
            __cil_tmp67 = (int )__cil_tmp66;
#line 2292
            tmp___13 = inb(__cil_tmp67);
#line 2292
            byte = tmp___13;
#line 2293
            tmp___14 = virt;
#line 2293
            virt = virt + 1;
#line 2293
            *tmp___14 = byte;
#line 2298
            d_left_counter = d_left_counter - 1U;
#line 2299
            sg_subtract_one(srb);
#line 2301
            len = len - 1UL;
#line 2303
            __cil_tmp68 = acb->io_port_base;
#line 2303
            __cil_tmp69 = __cil_tmp68 + 130UL;
#line 2303
            __cil_tmp70 = (int )__cil_tmp69;
#line 2303
            tmp___15 = inb(__cil_tmp70);
#line 2303
            fc = (unsigned int )tmp___15;
            }
#line 2305
            if (fc == 64U) {
#line 2306
              left_io = (size_t )0;
#line 2307
              goto while_break___6;
            } else {

            }
          }
          while_break___17: /* CIL Label */ ;
          }

          while_break___6: 
          {
#line 2311
          __cil_tmp71 = ! d_left_counter;
#line 2311
          __cil_tmp72 = fc != 64U;
#line 2311
          __cil_tmp73 = __cil_tmp72 == __cil_tmp71;
#line 2311
          __cil_tmp74 = ! __cil_tmp73;
#line 2311
          __ret_warn_on = ! __cil_tmp74;
#line 2311
          __cil_tmp75 = ! __ret_warn_on;
#line 2311
          __cil_tmp76 = ! __cil_tmp75;
#line 2311
          __cil_tmp77 = (long )__cil_tmp76;
#line 2311
          tmp___16 = __builtin_expect(__cil_tmp77, 0L);
          }
#line 2311
          if (tmp___16) {
            {
#line 2311
            __cil_tmp78 = (int const   )2311;
#line 2311
            __cil_tmp79 = (int )__cil_tmp78;
#line 2311
            warn_slowpath_null("/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c",
                               __cil_tmp79);
            }
          } else {

          }
          {
#line 2311
          __cil_tmp80 = ! __ret_warn_on;
#line 2311
          __cil_tmp81 = ! __cil_tmp80;
#line 2311
          __cil_tmp82 = (long )__cil_tmp81;
#line 2311
          __builtin_expect(__cil_tmp82, 0L);
          }
#line 2313
          if (fc == 64U) {
            {
#line 2313
            __cil_tmp83 = srb->dcb;
#line 2313
            __cil_tmp84 = __cil_tmp83->sync_period;
#line 2313
            __cil_tmp85 = (int )__cil_tmp84;
#line 2313
            if (__cil_tmp85 & 16) {
              {
#line 2315
              __cil_tmp86 = srb->total_xfer_length;
#line 2315
              if (__cil_tmp86 > 0UL) {
                {
#line 2316
                __cil_tmp87 = acb->io_port_base;
#line 2316
                __cil_tmp88 = __cil_tmp87 + 152UL;
#line 2316
                __cil_tmp89 = (int )__cil_tmp88;
#line 2316
                tmp___17 = inb(__cil_tmp89);
#line 2316
                byte___0 = tmp___17;
#line 2318
                tmp___18 = virt;
#line 2318
                virt = virt + 1;
#line 2318
                *tmp___18 = byte___0;
#line 2319
                __cil_tmp90 = srb->total_xfer_length;
#line 2319
                srb->total_xfer_length = __cil_tmp90 - 1UL;
                }
              } else {

              }
              }
              {
#line 2324
              __cil_tmp91 = acb->io_port_base;
#line 2324
              __cil_tmp92 = __cil_tmp91 + 143UL;
#line 2324
              __cil_tmp93 = (int )__cil_tmp92;
#line 2324
              outb((unsigned char)0, __cil_tmp93);
              }
            } else {

            }
            }
          } else {

          }
          {
#line 2327
          __cil_tmp94 = (void *)base;
#line 2327
          scsi_kunmap_atomic_sg(__cil_tmp94);
          }
          {
#line 2328
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 2328
            tmp___19 = arch_irqs_disabled_flags(flags);
            }
#line 2328
            if (tmp___19) {
              {
#line 2328
              while (1) {
                while_continue___8: /* CIL Label */ ;
                {
#line 2328
                arch_local_irq_restore(flags);
                }
#line 2328
                goto while_break___8;
              }
              while_break___19: /* CIL Label */ ;
              }

              while_break___8: 
              {
#line 2328
              trace_hardirqs_off();
              }
            } else {
              {
#line 2328
              trace_hardirqs_on();
              }
              {
#line 2328
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 2328
                arch_local_irq_restore(flags);
                }
#line 2328
                goto while_break___9;
              }
              while_break___20: /* CIL Label */ ;
              }

              while_break___9: ;
            }
#line 2328
            goto while_break___7;
          }
          while_break___18: /* CIL Label */ ;
          }

          while_break___7: ;
        }
        while_break___14: /* CIL Label */ ;
        }

        while_break___3: ;
      } else {

      }
      }
    } else {

    }
#line 2360
    if (d_left_counter == 0U) {
#line 2374
      srb->total_xfer_length = (size_t )d_left_counter;
    } else {
      {
#line 2360
      __cil_tmp95 = (int )scsi_status;
#line 2360
      if (__cil_tmp95 & 256) {
#line 2374
        srb->total_xfer_length = (size_t )d_left_counter;
      } else {
        {
#line 2384
        sg_update_list(srb, d_left_counter);
        }
      }
      }
    }
  } else {

  }
  }
  {
#line 2388
  __cil_tmp96 = *pscsi_status;
#line 2388
  __cil_tmp97 = (int )__cil_tmp96;
#line 2388
  __cil_tmp98 = __cil_tmp97 & 7;
#line 2388
  if (__cil_tmp98 != 1) {
    {
#line 2389
    cleanup_after_transfer(acb, srb);
    }
  } else {

  }
  }
#line 2391
  return;
}
}
#line 2394 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void data_in_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ u16 __cil_tmp4 ;

  {
  {
#line 2397
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2397
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2399
  __cil_tmp4 = (u16 )257;
#line 2399
  data_io_transfer(acb, srb, __cil_tmp4);
  }
#line 2400
  return;
}
}
#line 2403 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void data_io_transfer(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ,
                             u16 io_dir ) 
{ struct DeviceCtlBlk *dcb ;
  u8 bval ;
  u8 dma_status ;
  unsigned char tmp___7 ;
  unsigned int tmp___8 ;
  int ln ;
  size_t left_io ;
  unsigned char *virt ;
  unsigned char *base ;
  unsigned long flags ;
  size_t len ;
  size_t offset ;
  struct scatterlist *tmp___9 ;
  void *tmp___10 ;
  unsigned char *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  u8 data ;
  u8 data2 ;
  unsigned char tmp___14 ;
  unsigned char tmp___15 ;
  unsigned char tmp___16 ;
  struct ScsiReqBlk *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  u8 __cil_tmp29 ;
  int __cil_tmp30 ;
  u8 __cil_tmp31 ;
  int __cil_tmp32 ;
  size_t __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  u16 __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  int __cil_tmp46 ;
  struct scsi_cmnd *__cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  u8 __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  dma_addr_t __cil_tmp53 ;
  dma_addr_t __cil_tmp54 ;
  dma_addr_t __cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int __cil_tmp59 ;
  u8 __cil_tmp60 ;
  int __cil_tmp61 ;
  u8 __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  u32 __cil_tmp65 ;
  u32 __cil_tmp66 ;
  unsigned long __cil_tmp67 ;
  unsigned long __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  struct SGentry *__cil_tmp72 ;
  struct SGentry *__cil_tmp73 ;
  u32 __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  int __cil_tmp77 ;
  struct SGentry *__cil_tmp78 ;
  struct SGentry *__cil_tmp79 ;
  u32 __cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  int __cil_tmp83 ;
  size_t __cil_tmp84 ;
  unsigned int __cil_tmp85 ;
  unsigned long __cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  int __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  int __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  unsigned long __cil_tmp97 ;
  int __cil_tmp98 ;
  unsigned long __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  int __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  unsigned long __cil_tmp103 ;
  int __cil_tmp104 ;
  size_t __cil_tmp105 ;
  u16 __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  size_t __cil_tmp109 ;
  unsigned int __cil_tmp110 ;
  unsigned long __cil_tmp111 ;
  unsigned long __cil_tmp112 ;
  int __cil_tmp113 ;
  unsigned long __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  unsigned long __cil_tmp118 ;
  unsigned long __cil_tmp119 ;
  int __cil_tmp120 ;
  size_t __cil_tmp121 ;
  struct DeviceCtlBlk *__cil_tmp122 ;
  u8 __cil_tmp123 ;
  int __cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  int __cil_tmp127 ;
  void *__cil_tmp128 ;
  size_t __cil_tmp129 ;
  struct scsi_cmnd *__cil_tmp130 ;
  u8 __cil_tmp131 ;
  int __cil_tmp132 ;
  unsigned char __cil_tmp133 ;
  unsigned long __cil_tmp134 ;
  unsigned long __cil_tmp135 ;
  int __cil_tmp136 ;
  void *__cil_tmp137 ;
  struct DeviceCtlBlk *__cil_tmp138 ;
  u8 __cil_tmp139 ;
  int __cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  int __cil_tmp143 ;
  unsigned long __cil_tmp144 ;
  unsigned long __cil_tmp145 ;
  int __cil_tmp146 ;
  unsigned long __cil_tmp147 ;
  unsigned long __cil_tmp148 ;
  int __cil_tmp149 ;
  u8 __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  u8 __cil_tmp153 ;
  int __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  unsigned long __cil_tmp156 ;
  int __cil_tmp157 ;
  unsigned long __cil_tmp158 ;
  unsigned long __cil_tmp159 ;
  int __cil_tmp160 ;
  int __cil_tmp161 ;
  unsigned long __cil_tmp162 ;
  unsigned long __cil_tmp163 ;
  int __cil_tmp164 ;
  unsigned long __cil_tmp165 ;
  unsigned long __cil_tmp166 ;
  int __cil_tmp167 ;
  unsigned char __cil_tmp168 ;
  unsigned long __cil_tmp169 ;
  unsigned long __cil_tmp170 ;
  int __cil_tmp171 ;
  unsigned char __cil_tmp172 ;
  unsigned long __cil_tmp173 ;
  unsigned long __cil_tmp174 ;
  int __cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  unsigned long __cil_tmp177 ;
  int __cil_tmp178 ;
  unsigned long __cil_tmp179 ;
  unsigned long __cil_tmp180 ;
  int __cil_tmp181 ;
  int __cil_tmp182 ;
  unsigned long __cil_tmp183 ;
  unsigned long __cil_tmp184 ;
  int __cil_tmp185 ;
  unsigned char __cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  unsigned long __cil_tmp188 ;
  int __cil_tmp189 ;
  u16 __cil_tmp190 ;
  int __cil_tmp191 ;
  int __cil_tmp192 ;
  unsigned long __cil_tmp193 ;
  unsigned long __cil_tmp194 ;
  int __cil_tmp195 ;
  int __cil_tmp196 ;
  unsigned long __cil_tmp197 ;
  unsigned long __cil_tmp198 ;
  int __cil_tmp199 ;

  {
#line 2406
  dcb = srb->dcb;
  {
#line 2408
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2408
    goto while_break;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 2413
  __cil_tmp26 = acb->tmp_srb;
#line 2413
  __cil_tmp27 = (unsigned long )__cil_tmp26;
#line 2413
  __cil_tmp28 = (unsigned long )srb;
#line 2413
  if (__cil_tmp28 == __cil_tmp27) {
    {
#line 2414
    printk("<3>dc395x: data_io_transfer: Using tmp_srb!\n");
    }
  } else {

  }
  }
  {
#line 2415
  __cil_tmp29 = srb->sg_count;
#line 2415
  __cil_tmp30 = (int )__cil_tmp29;
#line 2415
  __cil_tmp31 = srb->sg_index;
#line 2415
  __cil_tmp32 = (int )__cil_tmp31;
#line 2415
  if (__cil_tmp32 >= __cil_tmp30) {
#line 2417
    return;
  } else {

  }
  }
  {
#line 2420
  __cil_tmp33 = srb->total_xfer_length;
#line 2420
  if (__cil_tmp33 > 4UL) {
    {
#line 2421
    __cil_tmp34 = acb->io_port_base;
#line 2421
    __cil_tmp35 = __cil_tmp34 + 163UL;
#line 2421
    __cil_tmp36 = (int )__cil_tmp35;
#line 2421
    tmp___7 = inb(__cil_tmp36);
#line 2421
    dma_status = tmp___7;
    }
    {
#line 2426
    __cil_tmp37 = (int )dma_status;
#line 2426
    if (__cil_tmp37 & 128) {
      {
#line 2427
      printk("<7>dc395x: data_io_transfer: Xfer pending! Expect trouble!\n");
#line 2429
      dump_register_info(acb, dcb, srb);
#line 2430
      __cil_tmp38 = acb->io_port_base;
#line 2430
      __cil_tmp39 = __cil_tmp38 + 161UL;
#line 2430
      __cil_tmp40 = (int )__cil_tmp39;
#line 2430
      outb((unsigned char)2, __cil_tmp40);
      }
    } else {

    }
    }
    {
#line 2437
    __cil_tmp41 = srb->state;
#line 2437
    __cil_tmp42 = (int )__cil_tmp41;
#line 2437
    __cil_tmp43 = __cil_tmp42 | 256;
#line 2437
    srb->state = (u16 )__cil_tmp43;
#line 2438
    __cil_tmp44 = acb->io_port_base;
#line 2438
    __cil_tmp45 = __cil_tmp44 + 180UL;
#line 2438
    __cil_tmp46 = (int )__cil_tmp45;
#line 2438
    outl(0U, __cil_tmp46);
#line 2439
    __cil_tmp47 = srb->cmd;
#line 2439
    tmp___8 = scsi_sg_count(__cil_tmp47);
    }
#line 2439
    if (tmp___8) {
      {
#line 2440
      __cil_tmp48 = (int )io_dir;
#line 2440
      __cil_tmp49 = __cil_tmp48 | 2;
#line 2440
      io_dir = (u16 )__cil_tmp49;
#line 2441
      __cil_tmp50 = srb->sg_index;
#line 2441
      __cil_tmp51 = (unsigned long )__cil_tmp50;
#line 2441
      __cil_tmp52 = 8UL * __cil_tmp51;
#line 2441
      __cil_tmp53 = (dma_addr_t )__cil_tmp52;
#line 2441
      __cil_tmp54 = srb->sg_bus_addr;
#line 2441
      __cil_tmp55 = __cil_tmp54 + __cil_tmp53;
#line 2441
      __cil_tmp56 = (unsigned int )__cil_tmp55;
#line 2441
      __cil_tmp57 = acb->io_port_base;
#line 2441
      __cil_tmp58 = __cil_tmp57 + 176UL;
#line 2441
      __cil_tmp59 = (int )__cil_tmp58;
#line 2441
      outl(__cil_tmp56, __cil_tmp59);
#line 2446
      __cil_tmp60 = srb->sg_index;
#line 2446
      __cil_tmp61 = (int )__cil_tmp60;
#line 2446
      __cil_tmp62 = srb->sg_count;
#line 2446
      __cil_tmp63 = (int )__cil_tmp62;
#line 2446
      __cil_tmp64 = __cil_tmp63 - __cil_tmp61;
#line 2446
      __cil_tmp65 = (u32 )__cil_tmp64;
#line 2446
      __cil_tmp66 = __cil_tmp65 << 3;
#line 2446
      __cil_tmp67 = acb->io_port_base;
#line 2446
      __cil_tmp68 = __cil_tmp67 + 168UL;
#line 2446
      __cil_tmp69 = (int )__cil_tmp68;
#line 2446
      outl(__cil_tmp66, __cil_tmp69);
      }
    } else {
      {
#line 2450
      __cil_tmp70 = (int )io_dir;
#line 2450
      __cil_tmp71 = __cil_tmp70 & -3;
#line 2450
      io_dir = (u16 )__cil_tmp71;
#line 2451
      __cil_tmp72 = srb->segment_x;
#line 2451
      __cil_tmp73 = __cil_tmp72 + 0;
#line 2451
      __cil_tmp74 = __cil_tmp73->address;
#line 2451
      __cil_tmp75 = acb->io_port_base;
#line 2451
      __cil_tmp76 = __cil_tmp75 + 176UL;
#line 2451
      __cil_tmp77 = (int )__cil_tmp76;
#line 2451
      outl(__cil_tmp74, __cil_tmp77);
#line 2453
      __cil_tmp78 = srb->segment_x;
#line 2453
      __cil_tmp79 = __cil_tmp78 + 0;
#line 2453
      __cil_tmp80 = __cil_tmp79->length;
#line 2453
      __cil_tmp81 = acb->io_port_base;
#line 2453
      __cil_tmp82 = __cil_tmp81 + 168UL;
#line 2453
      __cil_tmp83 = (int )__cil_tmp82;
#line 2453
      outl(__cil_tmp80, __cil_tmp83);
      }
    }
    {
#line 2457
    __cil_tmp84 = srb->total_xfer_length;
#line 2457
    __cil_tmp85 = (unsigned int )__cil_tmp84;
#line 2457
    __cil_tmp86 = acb->io_port_base;
#line 2457
    __cil_tmp87 = __cil_tmp86 + 136UL;
#line 2457
    __cil_tmp88 = (int )__cil_tmp87;
#line 2457
    outl(__cil_tmp85, __cil_tmp88);
#line 2459
    __cil_tmp89 = acb->io_port_base;
#line 2459
    __cil_tmp90 = __cil_tmp89 + 128UL;
#line 2459
    __cil_tmp91 = (int )__cil_tmp90;
#line 2459
    outw((unsigned short)2, __cil_tmp91);
    }
    {
#line 2460
    __cil_tmp92 = (int )io_dir;
#line 2460
    if (__cil_tmp92 & 1) {
      {
#line 2461
      __cil_tmp93 = acb->io_port_base;
#line 2461
      __cil_tmp94 = __cil_tmp93 + 144UL;
#line 2461
      __cil_tmp95 = (int )__cil_tmp94;
#line 2461
      outb((unsigned char)195, __cil_tmp95);
#line 2463
      __cil_tmp96 = acb->io_port_base;
#line 2463
      __cil_tmp97 = __cil_tmp96 + 160UL;
#line 2463
      __cil_tmp98 = (int )__cil_tmp97;
#line 2463
      outw(io_dir, __cil_tmp98);
      }
    } else {
      {
#line 2465
      __cil_tmp99 = acb->io_port_base;
#line 2465
      __cil_tmp100 = __cil_tmp99 + 160UL;
#line 2465
      __cil_tmp101 = (int )__cil_tmp100;
#line 2465
      outw(io_dir, __cil_tmp101);
#line 2466
      __cil_tmp102 = acb->io_port_base;
#line 2466
      __cil_tmp103 = __cil_tmp102 + 144UL;
#line 2466
      __cil_tmp104 = (int )__cil_tmp103;
#line 2466
      outb((unsigned char)193, __cil_tmp104);
      }
    }
    }
  } else {
    {
#line 2472
    __cil_tmp105 = srb->total_xfer_length;
#line 2472
    if (__cil_tmp105 > 0UL) {
      {
#line 2477
      __cil_tmp106 = srb->state;
#line 2477
      __cil_tmp107 = (int )__cil_tmp106;
#line 2477
      __cil_tmp108 = __cil_tmp107 | 256;
#line 2477
      srb->state = (u16 )__cil_tmp108;
#line 2479
      __cil_tmp109 = srb->total_xfer_length;
#line 2479
      __cil_tmp110 = (unsigned int )__cil_tmp109;
#line 2479
      __cil_tmp111 = acb->io_port_base;
#line 2479
      __cil_tmp112 = __cil_tmp111 + 136UL;
#line 2479
      __cil_tmp113 = (int )__cil_tmp112;
#line 2479
      outl(__cil_tmp110, __cil_tmp113);
#line 2481
      __cil_tmp114 = acb->io_port_base;
#line 2481
      __cil_tmp115 = __cil_tmp114 + 128UL;
#line 2481
      __cil_tmp116 = (int )__cil_tmp115;
#line 2481
      outw((unsigned short)2, __cil_tmp116);
      }
      {
#line 2482
      __cil_tmp117 = (int )io_dir;
#line 2482
      if (__cil_tmp117 & 1) {
        {
#line 2483
        __cil_tmp118 = acb->io_port_base;
#line 2483
        __cil_tmp119 = __cil_tmp118 + 144UL;
#line 2483
        __cil_tmp120 = (int )__cil_tmp119;
#line 2483
        outb((unsigned char)194, __cil_tmp120);
        }
      } else {
#line 2486
        __cil_tmp121 = srb->total_xfer_length;
#line 2486
        ln = (int )__cil_tmp121;
#line 2487
        left_io = srb->total_xfer_length;
        {
#line 2489
        __cil_tmp122 = srb->dcb;
#line 2489
        __cil_tmp123 = __cil_tmp122->sync_period;
#line 2489
        __cil_tmp124 = (int )__cil_tmp123;
#line 2489
        if (__cil_tmp124 & 16) {
          {
#line 2490
          __cil_tmp125 = acb->io_port_base;
#line 2490
          __cil_tmp126 = __cil_tmp125 + 143UL;
#line 2490
          __cil_tmp127 = (int )__cil_tmp126;
#line 2490
          outb((unsigned char)2, __cil_tmp127);
          }
        } else {

        }
        }
        {
#line 2493
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 2493
          if (left_io) {

          } else {
#line 2493
            goto while_break___0;
          }
#line 2494
          __cil_tmp128 = (void *)0;
#line 2494
          base = (unsigned char *)__cil_tmp128;
#line 2495
          flags = 0UL;
#line 2496
          len = left_io;
#line 2497
          __cil_tmp129 = srb->request_length;
#line 2497
          offset = __cil_tmp129 - left_io;
          {
#line 2499
          while (1) {
            while_continue___1: /* CIL Label */ ;

            {
#line 2499
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 2499
              flags = arch_local_irq_save();
              }
#line 2499
              goto while_break___2;
            }
            while_break___10: /* CIL Label */ ;
            }

            while_break___2: 
            {
#line 2499
            trace_hardirqs_off();
            }
#line 2499
            goto while_break___1;
          }
          while_break___9: /* CIL Label */ ;
          }

          while_break___1: 
          {
#line 2501
          __cil_tmp130 = srb->cmd;
#line 2501
          tmp___9 = scsi_sglist(__cil_tmp130);
#line 2501
          __cil_tmp131 = srb->sg_count;
#line 2501
          __cil_tmp132 = (int )__cil_tmp131;
#line 2501
          tmp___10 = scsi_kmap_atomic_sg(tmp___9, __cil_tmp132, & offset, & len);
#line 2501
          base = (unsigned char *)tmp___10;
#line 2503
          virt = base + offset;
#line 2505
          left_io = left_io - len;
          }
          {
#line 2507
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2507
            tmp___12 = len;
#line 2507
            len = len - 1UL;
#line 2507
            if (tmp___12) {

            } else {
#line 2507
              goto while_break___3;
            }
            {
#line 2511
            tmp___11 = virt;
#line 2511
            virt = virt + 1;
#line 2511
            __cil_tmp133 = *tmp___11;
#line 2511
            __cil_tmp134 = acb->io_port_base;
#line 2511
            __cil_tmp135 = __cil_tmp134 + 152UL;
#line 2511
            __cil_tmp136 = (int )__cil_tmp135;
#line 2511
            outb(__cil_tmp133, __cil_tmp136);
#line 2513
            sg_subtract_one(srb);
            }
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
          {
#line 2516
          __cil_tmp137 = (void *)base;
#line 2516
          scsi_kunmap_atomic_sg(__cil_tmp137);
          }
          {
#line 2517
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 2517
            tmp___13 = arch_irqs_disabled_flags(flags);
            }
#line 2517
            if (tmp___13) {
              {
#line 2517
              while (1) {
                while_continue___5: /* CIL Label */ ;
                {
#line 2517
                arch_local_irq_restore(flags);
                }
#line 2517
                goto while_break___5;
              }
              while_break___13: /* CIL Label */ ;
              }

              while_break___5: 
              {
#line 2517
              trace_hardirqs_off();
              }
            } else {
              {
#line 2517
              trace_hardirqs_on();
              }
              {
#line 2517
              while (1) {
                while_continue___6: /* CIL Label */ ;
                {
#line 2517
                arch_local_irq_restore(flags);
                }
#line 2517
                goto while_break___6;
              }
              while_break___14: /* CIL Label */ ;
              }

              while_break___6: ;
            }
#line 2517
            goto while_break___4;
          }
          while_break___12: /* CIL Label */ ;
          }

          while_break___4: ;
        }
        while_break___8: /* CIL Label */ ;
        }

        while_break___0: ;
        {
#line 2519
        __cil_tmp138 = srb->dcb;
#line 2519
        __cil_tmp139 = __cil_tmp138->sync_period;
#line 2519
        __cil_tmp140 = (int )__cil_tmp139;
#line 2519
        if (__cil_tmp140 & 16) {
#line 2520
          if (ln % 2) {
            {
#line 2521
            __cil_tmp141 = acb->io_port_base;
#line 2521
            __cil_tmp142 = __cil_tmp141 + 152UL;
#line 2521
            __cil_tmp143 = (int )__cil_tmp142;
#line 2521
            outb((unsigned char)0, __cil_tmp143);
            }
          } else {

          }
          {
#line 2525
          __cil_tmp144 = acb->io_port_base;
#line 2525
          __cil_tmp145 = __cil_tmp144 + 143UL;
#line 2525
          __cil_tmp146 = (int )__cil_tmp145;
#line 2525
          outb((unsigned char)0, __cil_tmp146);
          }
        } else {

        }
        }
        {
#line 2530
        __cil_tmp147 = acb->io_port_base;
#line 2530
        __cil_tmp148 = __cil_tmp147 + 144UL;
#line 2530
        __cil_tmp149 = (int )__cil_tmp148;
#line 2530
        outb((unsigned char)192, __cil_tmp149);
        }
      }
      }
    } else {
#line 2536
      data = (u8 )0;
#line 2536
      data2 = (u8 )0;
#line 2537
      if (srb->sg_count) {
#line 2538
        srb->adapter_status = (u8 )18;
#line 2539
        __cil_tmp150 = srb->status;
#line 2539
        __cil_tmp151 = (int )__cil_tmp150;
#line 2539
        __cil_tmp152 = __cil_tmp151 | 4;
#line 2539
        srb->status = (u8 )__cil_tmp152;
      } else {

      }
      {
#line 2546
      __cil_tmp153 = dcb->sync_period;
#line 2546
      __cil_tmp154 = (int )__cil_tmp153;
#line 2546
      if (__cil_tmp154 & 16) {
        {
#line 2547
        __cil_tmp155 = acb->io_port_base;
#line 2547
        __cil_tmp156 = __cil_tmp155 + 136UL;
#line 2547
        __cil_tmp157 = (int )__cil_tmp156;
#line 2547
        outl(2U, __cil_tmp157);
#line 2548
        __cil_tmp158 = acb->io_port_base;
#line 2548
        __cil_tmp159 = __cil_tmp158 + 143UL;
#line 2548
        __cil_tmp160 = (int )__cil_tmp159;
#line 2548
        outb((unsigned char)2, __cil_tmp160);
        }
        {
#line 2550
        __cil_tmp161 = (int )io_dir;
#line 2550
        if (__cil_tmp161 & 1) {
          {
#line 2551
          __cil_tmp162 = acb->io_port_base;
#line 2551
          __cil_tmp163 = __cil_tmp162 + 152UL;
#line 2551
          __cil_tmp164 = (int )__cil_tmp163;
#line 2551
          tmp___14 = inb(__cil_tmp164);
#line 2551
          data = tmp___14;
#line 2552
          __cil_tmp165 = acb->io_port_base;
#line 2552
          __cil_tmp166 = __cil_tmp165 + 152UL;
#line 2552
          __cil_tmp167 = (int )__cil_tmp166;
#line 2552
          tmp___15 = inb(__cil_tmp167);
#line 2552
          data2 = tmp___15;
          }
        } else {
          {
#line 2557
          __cil_tmp168 = (unsigned char )'K';
#line 2557
          __cil_tmp169 = acb->io_port_base;
#line 2557
          __cil_tmp170 = __cil_tmp169 + 152UL;
#line 2557
          __cil_tmp171 = (int )__cil_tmp170;
#line 2557
          outb(__cil_tmp168, __cil_tmp171);
#line 2558
          __cil_tmp172 = (unsigned char )'G';
#line 2558
          __cil_tmp173 = acb->io_port_base;
#line 2558
          __cil_tmp174 = __cil_tmp173 + 152UL;
#line 2558
          __cil_tmp175 = (int )__cil_tmp174;
#line 2558
          outb(__cil_tmp172, __cil_tmp175);
          }
        }
        }
        {
#line 2560
        __cil_tmp176 = acb->io_port_base;
#line 2560
        __cil_tmp177 = __cil_tmp176 + 143UL;
#line 2560
        __cil_tmp178 = (int )__cil_tmp177;
#line 2560
        outb((unsigned char)0, __cil_tmp178);
        }
      } else {
        {
#line 2562
        __cil_tmp179 = acb->io_port_base;
#line 2562
        __cil_tmp180 = __cil_tmp179 + 136UL;
#line 2562
        __cil_tmp181 = (int )__cil_tmp180;
#line 2562
        outl(1U, __cil_tmp181);
        }
        {
#line 2565
        __cil_tmp182 = (int )io_dir;
#line 2565
        if (__cil_tmp182 & 1) {
          {
#line 2566
          __cil_tmp183 = acb->io_port_base;
#line 2566
          __cil_tmp184 = __cil_tmp183 + 152UL;
#line 2566
          __cil_tmp185 = (int )__cil_tmp184;
#line 2566
          tmp___16 = inb(__cil_tmp185);
#line 2566
          data = tmp___16;
          }
        } else {
          {
#line 2568
          __cil_tmp186 = (unsigned char )'K';
#line 2568
          __cil_tmp187 = acb->io_port_base;
#line 2568
          __cil_tmp188 = __cil_tmp187 + 152UL;
#line 2568
          __cil_tmp189 = (int )__cil_tmp188;
#line 2568
          outb(__cil_tmp186, __cil_tmp189);
          }
        }
        }
      }
      }
      {
#line 2570
      __cil_tmp190 = srb->state;
#line 2570
      __cil_tmp191 = (int )__cil_tmp190;
#line 2570
      __cil_tmp192 = __cil_tmp191 | 512;
#line 2570
      srb->state = (u16 )__cil_tmp192;
#line 2571
      __cil_tmp193 = acb->io_port_base;
#line 2571
      __cil_tmp194 = __cil_tmp193 + 128UL;
#line 2571
      __cil_tmp195 = (int )__cil_tmp194;
#line 2571
      outw((unsigned short)2, __cil_tmp195);
      }
      {
#line 2573
      __cil_tmp196 = (int )io_dir;
#line 2573
      if (__cil_tmp196 & 1) {
#line 2573
        bval = (u8 )194;
      } else {
#line 2573
        bval = (u8 )192;
      }
      }
      {
#line 2574
      __cil_tmp197 = acb->io_port_base;
#line 2574
      __cil_tmp198 = __cil_tmp197 + 144UL;
#line 2574
      __cil_tmp199 = (int )__cil_tmp198;
#line 2574
      outb(bval, __cil_tmp199);
      }
    }
    }
  }
  }
#line 2576
  return;
}
}
#line 2579 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void status_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 2582
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2582
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2584
  __cil_tmp6 = acb->io_port_base;
#line 2584
  __cil_tmp7 = __cil_tmp6 + 152UL;
#line 2584
  __cil_tmp8 = (int )__cil_tmp7;
#line 2584
  tmp___7 = inb(__cil_tmp8);
#line 2584
  srb->target_status = tmp___7;
#line 2585
  __cil_tmp9 = acb->io_port_base;
#line 2585
  __cil_tmp10 = __cil_tmp9 + 152UL;
#line 2585
  __cil_tmp11 = (int )__cil_tmp10;
#line 2585
  tmp___8 = inb(__cil_tmp11);
#line 2585
  srb->end_message = tmp___8;
#line 2586
  srb->state = (u16 )2048;
#line 2587
  *pscsi_status = (u16 )5;
#line 2588
  __cil_tmp12 = acb->io_port_base;
#line 2588
  __cil_tmp13 = __cil_tmp12 + 128UL;
#line 2588
  __cil_tmp14 = (int )__cil_tmp13;
#line 2588
  outw((unsigned short)2, __cil_tmp14);
#line 2589
  __cil_tmp15 = acb->io_port_base;
#line 2589
  __cil_tmp16 = __cil_tmp15 + 144UL;
#line 2589
  __cil_tmp17 = (int )__cil_tmp16;
#line 2589
  outb((unsigned char)216, __cil_tmp17);
  }
#line 2590
  return;
}
}
#line 2593 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void status_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 2596
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2596
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2598
  srb->state = (u16 )1024;
#line 2599
  __cil_tmp4 = acb->io_port_base;
#line 2599
  __cil_tmp5 = __cil_tmp4 + 128UL;
#line 2599
  __cil_tmp6 = (int )__cil_tmp5;
#line 2599
  outw((unsigned short)2, __cil_tmp6);
#line 2600
  __cil_tmp7 = acb->io_port_base;
#line 2600
  __cil_tmp8 = __cil_tmp7 + 144UL;
#line 2600
  __cil_tmp9 = (int )__cil_tmp8;
#line 2600
  outb((unsigned char)18, __cil_tmp9);
  }
#line 2601
  return;
}
}
#line 2605 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
__inline static u8 msgin_completed(u8 *msgbuf , u32 len ) 
{ u8 __cil_tmp3 ;
  int __cil_tmp4 ;
  u8 *__cil_tmp5 ;
  u8 __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  u32 __cil_tmp9 ;
  u8 __cil_tmp10 ;
  int __cil_tmp11 ;
  u8 __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 2607
  __cil_tmp3 = *msgbuf;
#line 2607
  __cil_tmp4 = (int )__cil_tmp3;
#line 2607
  if (__cil_tmp4 == 1) {
#line 2608
    if (len < 2U) {
#line 2609
      return ((u8 )0);
    } else {

    }
    {
#line 2610
    __cil_tmp5 = msgbuf + 1;
#line 2610
    __cil_tmp6 = *__cil_tmp5;
#line 2610
    __cil_tmp7 = (int )__cil_tmp6;
#line 2610
    __cil_tmp8 = __cil_tmp7 + 2;
#line 2610
    __cil_tmp9 = (u32 )__cil_tmp8;
#line 2610
    if (len < __cil_tmp9) {
#line 2611
      return ((u8 )0);
    } else {

    }
    }
  } else {
    {
#line 2612
    __cil_tmp10 = *msgbuf;
#line 2612
    __cil_tmp11 = (int )__cil_tmp10;
#line 2612
    if (__cil_tmp11 >= 32) {
      {
#line 2612
      __cil_tmp12 = *msgbuf;
#line 2612
      __cil_tmp13 = (int )__cil_tmp12;
#line 2612
      if (__cil_tmp13 <= 47) {
#line 2613
        if (len < 2U) {
#line 2614
          return ((u8 )0);
        } else {

        }
      } else {

      }
      }
    } else {

    }
    }
  }
  }
#line 2615
  return ((u8 )1);
}
}
#line 2619 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
__inline static void msgin_reject(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  u16 __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  u16 __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  u16 __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  u8 __cil_tmp15 ;
  int __cil_tmp16 ;
  struct DeviceCtlBlk *__cil_tmp17 ;
  u8 __cil_tmp18 ;
  int __cil_tmp19 ;
  struct DeviceCtlBlk *__cil_tmp20 ;
  u8 __cil_tmp21 ;
  int __cil_tmp22 ;

  {
  {
#line 2622
  srb->msgout_buf[0] = (u8 )7;
#line 2623
  srb->msg_count = (u8 )1;
#line 2624
  __cil_tmp3 = acb->io_port_base;
#line 2624
  __cil_tmp4 = __cil_tmp3 + 128UL;
#line 2624
  __cil_tmp5 = (int )__cil_tmp4;
#line 2624
  outw((unsigned short)512, __cil_tmp5);
#line 2624
  __cil_tmp6 = srb->state;
#line 2624
  __cil_tmp7 = (int )__cil_tmp6;
#line 2624
  __cil_tmp8 = __cil_tmp7 | 4;
#line 2624
  srb->state = (u16 )__cil_tmp8;
#line 2625
  __cil_tmp9 = srb->state;
#line 2625
  __cil_tmp10 = (int )__cil_tmp9;
#line 2625
  __cil_tmp11 = __cil_tmp10 & -9;
#line 2625
  srb->state = (u16 )__cil_tmp11;
#line 2626
  __cil_tmp12 = srb->state;
#line 2626
  __cil_tmp13 = (int )__cil_tmp12;
#line 2626
  __cil_tmp14 = __cil_tmp13 | 4;
#line 2626
  srb->state = (u16 )__cil_tmp14;
#line 2627
  __cil_tmp15 = srb->msgin_buf[0];
#line 2627
  __cil_tmp16 = (int )__cil_tmp15;
#line 2627
  __cil_tmp17 = srb->dcb;
#line 2627
  __cil_tmp18 = __cil_tmp17->target_id;
#line 2627
  __cil_tmp19 = (int )__cil_tmp18;
#line 2627
  __cil_tmp20 = srb->dcb;
#line 2627
  __cil_tmp21 = __cil_tmp20->target_lun;
#line 2627
  __cil_tmp22 = (int )__cil_tmp21;
#line 2627
  printk("<6>dc395x: msgin_reject: 0x%02x <%02i-%i>\n", __cil_tmp16, __cil_tmp19,
         __cil_tmp22);
  }
#line 2630
  return;
}
}
#line 2633 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct ScsiReqBlk *msgin_qtag(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb ,
                                     u8 tag ) 
{ struct ScsiReqBlk *srb ;
  struct ScsiReqBlk *i ;
  int tmp___7 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  size_t __len ;
  void *__ret ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  u32 __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  u32 __cil_tmp17 ;
  int __cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  struct list_head  const  *__cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  struct ScsiReqBlk *__cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  struct list_head *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  u8 __cil_tmp32 ;
  int __cil_tmp33 ;
  struct list_head *__cil_tmp34 ;
  struct ScsiReqBlk *__cil_tmp35 ;
  struct list_head *__cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  u8 __cil_tmp40 ;
  int __cil_tmp41 ;
  u16 __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  u8 __cil_tmp45 ;
  u8 *__cil_tmp46 ;
  void *__cil_tmp47 ;
  struct ScsiReqBlk *__cil_tmp48 ;
  u8 *__cil_tmp49 ;
  void const   *__cil_tmp50 ;
  struct ScsiReqBlk *__cil_tmp51 ;
  u16 __cil_tmp52 ;
  int __cil_tmp53 ;
  u16 __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  u16 __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  int __cil_tmp62 ;
  u16 __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;

  {
#line 2636
  __cil_tmp11 = (void *)0;
#line 2636
  srb = (struct ScsiReqBlk *)__cil_tmp11;
  {
#line 2638
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2638
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 2641
  __cil_tmp12 = (int )tag;
#line 2641
  __cil_tmp13 = 1 << __cil_tmp12;
#line 2641
  __cil_tmp14 = (unsigned int )__cil_tmp13;
#line 2641
  __cil_tmp15 = dcb->tag_mask;
#line 2641
  __cil_tmp16 = __cil_tmp15 & __cil_tmp14;
#line 2641
  if (! __cil_tmp16) {
    {
#line 2642
    __cil_tmp17 = dcb->tag_mask;
#line 2642
    __cil_tmp18 = (int )tag;
#line 2642
    printk("<7>dc395x: msgin_qtag: tag_mask=0x%08x does not reserve tag %i!\n", __cil_tmp17,
           __cil_tmp18);
    }
  } else {

  }
  }
  {
#line 2646
  __cil_tmp19 = & dcb->srb_going_list;
#line 2646
  __cil_tmp20 = (struct list_head  const  *)__cil_tmp19;
#line 2646
  tmp___7 = list_empty(__cil_tmp20);
  }
#line 2646
  if (tmp___7) {
#line 2647
    goto mingx0;
  } else {

  }
#line 2648
  __cil_tmp21 = dcb->srb_going_list.next;
#line 2648
  __mptr = (struct list_head  const  *)__cil_tmp21;
#line 2648
  __cil_tmp22 = (struct ScsiReqBlk *)0;
#line 2648
  __cil_tmp23 = & __cil_tmp22->list;
#line 2648
  __cil_tmp24 = (unsigned int )__cil_tmp23;
#line 2648
  __cil_tmp25 = (char *)__mptr;
#line 2648
  __cil_tmp26 = __cil_tmp25 - __cil_tmp24;
#line 2648
  i = (struct ScsiReqBlk *)__cil_tmp26;
  {
#line 2648
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 2648
    __cil_tmp27 = & dcb->srb_going_list;
#line 2648
    __cil_tmp28 = (unsigned long )__cil_tmp27;
#line 2648
    __cil_tmp29 = & i->list;
#line 2648
    __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 2648
    if (__cil_tmp30 != __cil_tmp28) {

    } else {
#line 2648
      goto while_break___0;
    }
    }
    {
#line 2649
    __cil_tmp31 = (int )tag;
#line 2649
    __cil_tmp32 = i->tag_number;
#line 2649
    __cil_tmp33 = (int )__cil_tmp32;
#line 2649
    if (__cil_tmp33 == __cil_tmp31) {
#line 2650
      srb = i;
#line 2651
      goto while_break___0;
    } else {

    }
    }
#line 2648
    __cil_tmp34 = i->list.next;
#line 2648
    __mptr___0 = (struct list_head  const  *)__cil_tmp34;
#line 2648
    __cil_tmp35 = (struct ScsiReqBlk *)0;
#line 2648
    __cil_tmp36 = & __cil_tmp35->list;
#line 2648
    __cil_tmp37 = (unsigned int )__cil_tmp36;
#line 2648
    __cil_tmp38 = (char *)__mptr___0;
#line 2648
    __cil_tmp39 = __cil_tmp38 - __cil_tmp37;
#line 2648
    i = (struct ScsiReqBlk *)__cil_tmp39;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: ;
#line 2654
  if (! srb) {
#line 2655
    goto mingx0;
  } else {

  }
  {
#line 2657
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2657
    goto while_break___1;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___1: ;
  {
#line 2659
  __cil_tmp40 = dcb->flag;
#line 2659
  __cil_tmp41 = (int )__cil_tmp40;
#line 2659
  if (__cil_tmp41 & 1) {
    {
#line 2661
    enable_msgout_abort(acb, srb);
    }
  } else {

  }
  }
  {
#line 2664
  __cil_tmp42 = srb->state;
#line 2664
  __cil_tmp43 = (int )__cil_tmp42;
#line 2664
  __cil_tmp44 = __cil_tmp43 & 128;
#line 2664
  if (! __cil_tmp44) {
#line 2665
    goto mingx0;
  } else {

  }
  }
  {
#line 2667
  __cil_tmp45 = acb->msg_len;
#line 2667
  __len = (size_t )__cil_tmp45;
#line 2667
  __cil_tmp46 = & srb->msgin_buf[0];
#line 2667
  __cil_tmp47 = (void *)__cil_tmp46;
#line 2667
  __cil_tmp48 = dcb->active_srb;
#line 2667
  __cil_tmp49 = & __cil_tmp48->msgin_buf[0];
#line 2667
  __cil_tmp50 = (void const   *)__cil_tmp49;
#line 2667
  __ret = __builtin_memcpy(__cil_tmp47, __cil_tmp50, __len);
#line 2668
  __cil_tmp51 = dcb->active_srb;
#line 2668
  __cil_tmp52 = __cil_tmp51->state;
#line 2668
  __cil_tmp53 = (int )__cil_tmp52;
#line 2668
  __cil_tmp54 = srb->state;
#line 2668
  __cil_tmp55 = (int )__cil_tmp54;
#line 2668
  __cil_tmp56 = __cil_tmp55 | __cil_tmp53;
#line 2668
  srb->state = (u16 )__cil_tmp56;
#line 2669
  __cil_tmp57 = srb->state;
#line 2669
  __cil_tmp58 = (int )__cil_tmp57;
#line 2669
  __cil_tmp59 = __cil_tmp58 | 256;
#line 2669
  srb->state = (u16 )__cil_tmp59;
#line 2670
  dcb->active_srb = srb;
  }
#line 2672
  return (srb);
  mingx0: 
  {
#line 2675
  srb = acb->tmp_srb;
#line 2676
  srb->state = (u16 )32768;
#line 2677
  dcb->active_srb = srb;
#line 2678
  srb->msgout_buf[0] = (u8 )13;
#line 2679
  srb->msg_count = (u8 )1;
#line 2680
  __cil_tmp60 = acb->io_port_base;
#line 2680
  __cil_tmp61 = __cil_tmp60 + 128UL;
#line 2680
  __cil_tmp62 = (int )__cil_tmp61;
#line 2680
  outw((unsigned short)512, __cil_tmp62);
#line 2680
  __cil_tmp63 = srb->state;
#line 2680
  __cil_tmp64 = (int )__cil_tmp63;
#line 2680
  __cil_tmp65 = __cil_tmp64 | 4;
#line 2680
  srb->state = (u16 )__cil_tmp65;
#line 2681
  __cil_tmp66 = (int )tag;
#line 2681
  printk("<7>dc395x: msgin_qtag: Unknown tag %i - abort\n", __cil_tmp66);
  }
#line 2682
  return (srb);
}
}
#line 2686 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
__inline static void reprogram_regs(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb ) 
{ u8 __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  u8 __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  u8 __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 2689
  __cil_tmp3 = dcb->target_id;
#line 2689
  __cil_tmp4 = acb->io_port_base;
#line 2689
  __cil_tmp5 = __cil_tmp4 + 134UL;
#line 2689
  __cil_tmp6 = (int )__cil_tmp5;
#line 2689
  outb(__cil_tmp3, __cil_tmp6);
#line 2690
  __cil_tmp7 = dcb->sync_period;
#line 2690
  __cil_tmp8 = acb->io_port_base;
#line 2690
  __cil_tmp9 = __cil_tmp8 + 133UL;
#line 2690
  __cil_tmp10 = (int )__cil_tmp9;
#line 2690
  outb(__cil_tmp7, __cil_tmp10);
#line 2691
  __cil_tmp11 = dcb->sync_offset;
#line 2691
  __cil_tmp12 = acb->io_port_base;
#line 2691
  __cil_tmp13 = __cil_tmp12 + 132UL;
#line 2691
  __cil_tmp14 = (int )__cil_tmp13;
#line 2691
  outb(__cil_tmp11, __cil_tmp14);
#line 2692
  set_xfer_rate(acb, dcb);
  }
#line 2693
  return;
}
}
#line 2697 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void msgin_set_async(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ struct DeviceCtlBlk *dcb ;
  u8 __cil_tmp4 ;
  int __cil_tmp5 ;
  u8 __cil_tmp6 ;
  int __cil_tmp7 ;
  u8 __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  u8 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  u16 __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  u8 __cil_tmp18 ;
  int __cil_tmp19 ;
  u8 __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  u16 __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
  {
#line 2699
  dcb = srb->dcb;
#line 2700
  __cil_tmp4 = dcb->target_id;
#line 2700
  __cil_tmp5 = (int )__cil_tmp4;
#line 2700
  __cil_tmp6 = dcb->target_lun;
#line 2700
  __cil_tmp7 = (int )__cil_tmp6;
#line 2700
  printk("<7>dc395x: msgin_set_async: No sync transfers <%02i-%i>\n", __cil_tmp5,
         __cil_tmp7);
#line 2703
  __cil_tmp8 = dcb->sync_mode;
#line 2703
  __cil_tmp9 = (int )__cil_tmp8;
#line 2703
  __cil_tmp10 = __cil_tmp9 & -2;
#line 2703
  dcb->sync_mode = (u8 )__cil_tmp10;
#line 2704
  __cil_tmp11 = dcb->sync_mode;
#line 2704
  __cil_tmp12 = (int )__cil_tmp11;
#line 2704
  __cil_tmp13 = __cil_tmp12 | 2;
#line 2704
  dcb->sync_mode = (u8 )__cil_tmp13;
#line 2706
  dcb->sync_offset = (u8 )0;
#line 2707
  __cil_tmp14 = 200 >> 2;
#line 2707
  dcb->min_nego_period = (u8 )__cil_tmp14;
#line 2708
  __cil_tmp15 = srb->state;
#line 2708
  __cil_tmp16 = (int )__cil_tmp15;
#line 2708
  __cil_tmp17 = __cil_tmp16 & -8193;
#line 2708
  srb->state = (u16 )__cil_tmp17;
#line 2709
  reprogram_regs(acb, dcb);
  }
  {
#line 2710
  __cil_tmp18 = dcb->sync_mode;
#line 2710
  __cil_tmp19 = (int )__cil_tmp18;
#line 2710
  if (__cil_tmp19 & 4) {
    {
#line 2710
    __cil_tmp20 = dcb->sync_mode;
#line 2710
    __cil_tmp21 = (int )__cil_tmp20;
#line 2710
    __cil_tmp22 = __cil_tmp21 & 8;
#line 2710
    if (! __cil_tmp22) {
      {
#line 2712
      build_wdtr(acb, dcb, srb);
#line 2713
      __cil_tmp23 = acb->io_port_base;
#line 2713
      __cil_tmp24 = __cil_tmp23 + 128UL;
#line 2713
      __cil_tmp25 = (int )__cil_tmp24;
#line 2713
      outw((unsigned short)512, __cil_tmp25);
#line 2713
      __cil_tmp26 = srb->state;
#line 2713
      __cil_tmp27 = (int )__cil_tmp26;
#line 2713
      __cil_tmp28 = __cil_tmp27 | 4;
#line 2713
      srb->state = (u16 )__cil_tmp28;
      }
      {
#line 2714
      while (1) {
        while_continue: /* CIL Label */ ;

#line 2714
        goto while_break;
      }
      while_break___0: /* CIL Label */ ;
      }

      while_break: ;
    } else {

    }
    }
  } else {

  }
  }
#line 2716
  return;
}
}
#line 2720 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void msgin_set_sync(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ struct DeviceCtlBlk *dcb ;
  u8 bval ;
  int fact ;
  char const   *tmp___7 ;
  size_t __len ;
  void *__ret ;
  u8 __cil_tmp9 ;
  int __cil_tmp10 ;
  u8 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  u8 __cil_tmp14 ;
  int __cil_tmp15 ;
  u8 __cil_tmp16 ;
  int __cil_tmp17 ;
  u8 __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  u8 __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  u8 __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  u8 __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  u8 __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  u8 __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  u8 __cil_tmp42 ;
  int __cil_tmp43 ;
  u8 __cil_tmp44 ;
  int __cil_tmp45 ;
  u8 __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  u8 __cil_tmp49 ;
  int __cil_tmp50 ;
  u8 __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  u8 __cil_tmp54 ;
  int __cil_tmp55 ;
  u8 __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  u8 __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  u16 __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  u8 __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  u8 __cil_tmp71 ;
  int __cil_tmp72 ;
  u8 *__cil_tmp73 ;
  void *__cil_tmp74 ;
  u8 *__cil_tmp75 ;
  void const   *__cil_tmp76 ;
  u8 *__cil_tmp77 ;
  void *__cil_tmp78 ;
  u8 *__cil_tmp79 ;
  void const   *__cil_tmp80 ;
  unsigned long __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  int __cil_tmp83 ;
  u16 __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  u8 __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  u8 __cil_tmp90 ;
  int __cil_tmp91 ;
  u8 __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  unsigned long __cil_tmp95 ;
  unsigned long __cil_tmp96 ;
  int __cil_tmp97 ;
  u16 __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  u16 __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  u8 __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;

  {
#line 2722
  dcb = srb->dcb;
  {
#line 2725
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2725
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 2732
  __cil_tmp9 = srb->msgin_buf[4];
#line 2732
  __cil_tmp10 = (int )__cil_tmp9;
#line 2732
  if (__cil_tmp10 > 15) {
#line 2733
    srb->msgin_buf[4] = (u8 )15;
  } else {

  }
  }
  {
#line 2734
  __cil_tmp11 = dcb->dev_mode;
#line 2734
  __cil_tmp12 = (int )__cil_tmp11;
#line 2734
  __cil_tmp13 = __cil_tmp12 & 2;
#line 2734
  if (! __cil_tmp13) {
#line 2735
    dcb->sync_offset = (u8 )0;
  } else {
    {
#line 2736
    __cil_tmp14 = dcb->sync_offset;
#line 2736
    __cil_tmp15 = (int )__cil_tmp14;
#line 2736
    if (__cil_tmp15 == 0) {
#line 2737
      dcb->sync_offset = srb->msgin_buf[4];
    } else {

    }
    }
  }
  }
  {
#line 2738
  __cil_tmp16 = dcb->sync_offset;
#line 2738
  __cil_tmp17 = (int )__cil_tmp16;
#line 2738
  __cil_tmp18 = srb->msgin_buf[4];
#line 2738
  __cil_tmp19 = (int )__cil_tmp18;
#line 2738
  if (__cil_tmp19 > __cil_tmp17) {
#line 2739
    srb->msgin_buf[4] = dcb->sync_offset;
  } else {
#line 2741
    dcb->sync_offset = srb->msgin_buf[4];
  }
  }
#line 2742
  bval = (u8 )0;
  {
#line 2743
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 2743
    __cil_tmp20 = (int )bval;
#line 2743
    if (__cil_tmp20 < 7) {
      {
#line 2743
      __cil_tmp21 = (int )clock_period[bval];
#line 2743
      __cil_tmp22 = srb->msgin_buf[3];
#line 2743
      __cil_tmp23 = (int )__cil_tmp22;
#line 2743
      if (__cil_tmp23 > __cil_tmp21) {

      } else {
        {
#line 2743
        __cil_tmp24 = (int )clock_period[bval];
#line 2743
        __cil_tmp25 = dcb->min_nego_period;
#line 2743
        __cil_tmp26 = (int )__cil_tmp25;
#line 2743
        if (__cil_tmp26 > __cil_tmp24) {

        } else {
#line 2743
          goto while_break___0;
        }
        }
      }
      }
    } else {
#line 2743
      goto while_break___0;
    }
    }
#line 2746
    __cil_tmp27 = (int )bval;
#line 2746
    __cil_tmp28 = __cil_tmp27 + 1;
#line 2746
    bval = (u8 )__cil_tmp28;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: ;
  {
#line 2747
  __cil_tmp29 = (int )clock_period[bval];
#line 2747
  __cil_tmp30 = srb->msgin_buf[3];
#line 2747
  __cil_tmp31 = (int )__cil_tmp30;
#line 2747
  if (__cil_tmp31 < __cil_tmp29) {
    {
#line 2748
    __cil_tmp32 = (int )clock_period[bval];
#line 2748
    __cil_tmp33 = __cil_tmp32 << 2;
#line 2748
    printk("<6>dc395x: msgin_set_sync: Increase sync nego period to %ins\n", __cil_tmp33);
    }
  } else {

  }
  }
#line 2751
  srb->msgin_buf[3] = clock_period[bval];
#line 2752
  __cil_tmp34 = dcb->sync_period;
#line 2752
  __cil_tmp35 = (int )__cil_tmp34;
#line 2752
  __cil_tmp36 = __cil_tmp35 & 240;
#line 2752
  dcb->sync_period = (u8 )__cil_tmp36;
#line 2753
  __cil_tmp37 = (int )bval;
#line 2753
  __cil_tmp38 = 8 | __cil_tmp37;
#line 2753
  __cil_tmp39 = dcb->sync_period;
#line 2753
  __cil_tmp40 = (int )__cil_tmp39;
#line 2753
  __cil_tmp41 = __cil_tmp40 | __cil_tmp38;
#line 2753
  dcb->sync_period = (u8 )__cil_tmp41;
#line 2754
  dcb->min_nego_period = srb->msgin_buf[3];
  {
#line 2756
  __cil_tmp42 = dcb->sync_period;
#line 2756
  __cil_tmp43 = (int )__cil_tmp42;
#line 2756
  if (__cil_tmp43 & 16) {
#line 2757
    fact = 500;
  } else {
#line 2759
    fact = 250;
  }
  }
#line 2761
  if (fact == 500) {
#line 2761
    tmp___7 = "Wide16";
  } else {
#line 2761
    tmp___7 = "";
  }
  {
#line 2761
  __cil_tmp44 = dcb->target_id;
#line 2761
  __cil_tmp45 = (int )__cil_tmp44;
#line 2761
  __cil_tmp46 = dcb->min_nego_period;
#line 2761
  __cil_tmp47 = (int )__cil_tmp46;
#line 2761
  __cil_tmp48 = __cil_tmp47 << 2;
#line 2761
  __cil_tmp49 = dcb->sync_offset;
#line 2761
  __cil_tmp50 = (int )__cil_tmp49;
#line 2761
  __cil_tmp51 = dcb->min_nego_period;
#line 2761
  __cil_tmp52 = (int )__cil_tmp51;
#line 2761
  __cil_tmp53 = fact / __cil_tmp52;
#line 2761
  __cil_tmp54 = dcb->min_nego_period;
#line 2761
  __cil_tmp55 = (int )__cil_tmp54;
#line 2761
  __cil_tmp56 = dcb->min_nego_period;
#line 2761
  __cil_tmp57 = (int )__cil_tmp56;
#line 2761
  __cil_tmp58 = __cil_tmp57 / 2;
#line 2761
  __cil_tmp59 = dcb->min_nego_period;
#line 2761
  __cil_tmp60 = (int )__cil_tmp59;
#line 2761
  __cil_tmp61 = fact % __cil_tmp60;
#line 2761
  __cil_tmp62 = __cil_tmp61 * 10;
#line 2761
  __cil_tmp63 = __cil_tmp62 + __cil_tmp58;
#line 2761
  __cil_tmp64 = __cil_tmp63 / __cil_tmp55;
#line 2761
  printk("<6>dc395x: Target %02i: %s Sync: %ins Offset %i (%02i.%01i MB/s)\n", __cil_tmp45,
         tmp___7, __cil_tmp48, __cil_tmp50, __cil_tmp53, __cil_tmp64);
  }
  {
#line 2769
  __cil_tmp65 = srb->state;
#line 2769
  __cil_tmp66 = (int )__cil_tmp65;
#line 2769
  __cil_tmp67 = __cil_tmp66 & 8192;
#line 2769
  if (! __cil_tmp67) {
    {
#line 2771
    __cil_tmp68 = srb->msgin_buf[3];
#line 2771
    __cil_tmp69 = (int )__cil_tmp68;
#line 2771
    __cil_tmp70 = __cil_tmp69 << 2;
#line 2771
    __cil_tmp71 = srb->msgin_buf[4];
#line 2771
    __cil_tmp72 = (int )__cil_tmp71;
#line 2771
    printk("<7>dc395x: msgin_set_sync: answer w/%ins %i\n", __cil_tmp70, __cil_tmp72);
#line 2774
    __len = (size_t )5;
    }
#line 2774
    if (__len >= 64UL) {
      {
#line 2774
      __cil_tmp73 = & srb->msgout_buf[0];
#line 2774
      __cil_tmp74 = (void *)__cil_tmp73;
#line 2774
      __cil_tmp75 = & srb->msgin_buf[0];
#line 2774
      __cil_tmp76 = (void const   *)__cil_tmp75;
#line 2774
      __ret = __memcpy(__cil_tmp74, __cil_tmp76, __len);
      }
    } else {
      {
#line 2774
      __cil_tmp77 = & srb->msgout_buf[0];
#line 2774
      __cil_tmp78 = (void *)__cil_tmp77;
#line 2774
      __cil_tmp79 = & srb->msgin_buf[0];
#line 2774
      __cil_tmp80 = (void const   *)__cil_tmp79;
#line 2774
      __ret = __builtin_memcpy(__cil_tmp78, __cil_tmp80, __len);
      }
    }
    {
#line 2775
    srb->msg_count = (u8 )5;
#line 2776
    __cil_tmp81 = acb->io_port_base;
#line 2776
    __cil_tmp82 = __cil_tmp81 + 128UL;
#line 2776
    __cil_tmp83 = (int )__cil_tmp82;
#line 2776
    outw((unsigned short)512, __cil_tmp83);
#line 2776
    __cil_tmp84 = srb->state;
#line 2776
    __cil_tmp85 = (int )__cil_tmp84;
#line 2776
    __cil_tmp86 = __cil_tmp85 | 4;
#line 2776
    srb->state = (u16 )__cil_tmp86;
#line 2777
    __cil_tmp87 = dcb->sync_mode;
#line 2777
    __cil_tmp88 = (int )__cil_tmp87;
#line 2777
    __cil_tmp89 = __cil_tmp88 | 2;
#line 2777
    dcb->sync_mode = (u8 )__cil_tmp89;
    }
  } else {
    {
#line 2779
    __cil_tmp90 = dcb->sync_mode;
#line 2779
    __cil_tmp91 = (int )__cil_tmp90;
#line 2779
    if (__cil_tmp91 & 4) {
      {
#line 2779
      __cil_tmp92 = dcb->sync_mode;
#line 2779
      __cil_tmp93 = (int )__cil_tmp92;
#line 2779
      __cil_tmp94 = __cil_tmp93 & 8;
#line 2779
      if (! __cil_tmp94) {
        {
#line 2781
        build_wdtr(acb, dcb, srb);
#line 2782
        __cil_tmp95 = acb->io_port_base;
#line 2782
        __cil_tmp96 = __cil_tmp95 + 128UL;
#line 2782
        __cil_tmp97 = (int )__cil_tmp96;
#line 2782
        outw((unsigned short)512, __cil_tmp97);
#line 2782
        __cil_tmp98 = srb->state;
#line 2782
        __cil_tmp99 = (int )__cil_tmp98;
#line 2782
        __cil_tmp100 = __cil_tmp99 | 4;
#line 2782
        srb->state = (u16 )__cil_tmp100;
        }
        {
#line 2783
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 2783
          goto while_break___1;
        }
        while_break___4: /* CIL Label */ ;
        }

        while_break___1: ;
      } else {

      }
      }
    } else {

    }
    }
  }
  }
  {
#line 2786
  __cil_tmp101 = srb->state;
#line 2786
  __cil_tmp102 = (int )__cil_tmp101;
#line 2786
  __cil_tmp103 = __cil_tmp102 & -8193;
#line 2786
  srb->state = (u16 )__cil_tmp103;
#line 2787
  __cil_tmp104 = dcb->sync_mode;
#line 2787
  __cil_tmp105 = (int )__cil_tmp104;
#line 2787
  __cil_tmp106 = __cil_tmp105 | 3;
#line 2787
  dcb->sync_mode = (u8 )__cil_tmp106;
#line 2789
  reprogram_regs(acb, dcb);
  }
#line 2790
  return;
}
}
#line 2793 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
__inline static void msgin_set_nowide(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ struct DeviceCtlBlk *dcb ;
  u8 __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  u8 __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  u8 __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  u16 __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  u8 __cil_tmp16 ;
  int __cil_tmp17 ;
  u8 __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  u16 __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
#line 2796
  dcb = srb->dcb;
  {
#line 2797
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2797
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2799
  __cil_tmp4 = dcb->sync_period;
#line 2799
  __cil_tmp5 = (int )__cil_tmp4;
#line 2799
  __cil_tmp6 = __cil_tmp5 & -17;
#line 2799
  dcb->sync_period = (u8 )__cil_tmp6;
#line 2800
  __cil_tmp7 = dcb->sync_mode;
#line 2800
  __cil_tmp8 = (int )__cil_tmp7;
#line 2800
  __cil_tmp9 = __cil_tmp8 & -5;
#line 2800
  dcb->sync_mode = (u8 )__cil_tmp9;
#line 2801
  __cil_tmp10 = dcb->sync_mode;
#line 2801
  __cil_tmp11 = (int )__cil_tmp10;
#line 2801
  __cil_tmp12 = __cil_tmp11 | 8;
#line 2801
  dcb->sync_mode = (u8 )__cil_tmp12;
#line 2802
  __cil_tmp13 = srb->state;
#line 2802
  __cil_tmp14 = (int )__cil_tmp13;
#line 2802
  __cil_tmp15 = __cil_tmp14 & -16385;
#line 2802
  srb->state = (u16 )__cil_tmp15;
#line 2803
  reprogram_regs(acb, dcb);
  }
  {
#line 2804
  __cil_tmp16 = dcb->sync_mode;
#line 2804
  __cil_tmp17 = (int )__cil_tmp16;
#line 2804
  if (__cil_tmp17 & 1) {
    {
#line 2804
    __cil_tmp18 = dcb->sync_mode;
#line 2804
    __cil_tmp19 = (int )__cil_tmp18;
#line 2804
    __cil_tmp20 = __cil_tmp19 & 2;
#line 2804
    if (! __cil_tmp20) {
      {
#line 2806
      build_sdtr(acb, dcb, srb);
#line 2807
      __cil_tmp21 = acb->io_port_base;
#line 2807
      __cil_tmp22 = __cil_tmp21 + 128UL;
#line 2807
      __cil_tmp23 = (int )__cil_tmp22;
#line 2807
      outw((unsigned short)512, __cil_tmp23);
#line 2807
      __cil_tmp24 = srb->state;
#line 2807
      __cil_tmp25 = (int )__cil_tmp24;
#line 2807
      __cil_tmp26 = __cil_tmp25 | 4;
#line 2807
      srb->state = (u16 )__cil_tmp26;
      }
      {
#line 2808
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2808
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {

    }
    }
  } else {

  }
  }
#line 2810
  return;
}
}
#line 2812 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void msgin_set_wide(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ struct DeviceCtlBlk *dcb ;
  u8 wide ;
  int tmp___7 ;
  size_t __len ;
  void *__ret ;
  u8 __cil_tmp8 ;
  int __cil_tmp9 ;
  u8 __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  u8 __cil_tmp13 ;
  int __cil_tmp14 ;
  u16 __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  u8 __cil_tmp18 ;
  int __cil_tmp19 ;
  u8 *__cil_tmp20 ;
  void *__cil_tmp21 ;
  u8 *__cil_tmp22 ;
  void const   *__cil_tmp23 ;
  u8 *__cil_tmp24 ;
  void *__cil_tmp25 ;
  u8 *__cil_tmp26 ;
  void const   *__cil_tmp27 ;
  u16 __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int __cil_tmp33 ;
  u16 __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  u8 __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  u8 __cil_tmp40 ;
  int __cil_tmp41 ;
  u8 __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  u8 __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  u16 __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  u8 __cil_tmp51 ;
  int __cil_tmp52 ;
  u8 __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  int __cil_tmp58 ;
  u16 __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;

  {
#line 2814
  dcb = srb->dcb;
  {
#line 2815
  __cil_tmp8 = dcb->dev_mode;
#line 2815
  __cil_tmp9 = (int )__cil_tmp8;
#line 2815
  if (__cil_tmp9 & 32) {
    {
#line 2815
    __cil_tmp10 = acb->config;
#line 2815
    __cil_tmp11 = (int )__cil_tmp10;
#line 2815
    if (__cil_tmp11 & 32) {
#line 2815
      tmp___7 = 1;
    } else {
#line 2815
      tmp___7 = 0;
    }
    }
  } else {
#line 2815
    tmp___7 = 0;
  }
  }
#line 2815
  wide = (u8 )tmp___7;
  {
#line 2817
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2817
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 2819
  __cil_tmp12 = (int )wide;
#line 2819
  __cil_tmp13 = srb->msgin_buf[3];
#line 2819
  __cil_tmp14 = (int )__cil_tmp13;
#line 2819
  if (__cil_tmp14 > __cil_tmp12) {
#line 2820
    srb->msgin_buf[3] = wide;
  } else {

  }
  }
  {
#line 2822
  __cil_tmp15 = srb->state;
#line 2822
  __cil_tmp16 = (int )__cil_tmp15;
#line 2822
  __cil_tmp17 = __cil_tmp16 & 16384;
#line 2822
  if (! __cil_tmp17) {
    {
#line 2823
    __cil_tmp18 = dcb->target_id;
#line 2823
    __cil_tmp19 = (int )__cil_tmp18;
#line 2823
    printk("<7>dc395x: msgin_set_wide: Wide nego initiated <%02i>\n", __cil_tmp19);
#line 2826
    __len = (size_t )4;
    }
#line 2826
    if (__len >= 64UL) {
      {
#line 2826
      __cil_tmp20 = & srb->msgout_buf[0];
#line 2826
      __cil_tmp21 = (void *)__cil_tmp20;
#line 2826
      __cil_tmp22 = & srb->msgin_buf[0];
#line 2826
      __cil_tmp23 = (void const   *)__cil_tmp22;
#line 2826
      __ret = __memcpy(__cil_tmp21, __cil_tmp23, __len);
      }
    } else {
      {
#line 2826
      __cil_tmp24 = & srb->msgout_buf[0];
#line 2826
      __cil_tmp25 = (void *)__cil_tmp24;
#line 2826
      __cil_tmp26 = & srb->msgin_buf[0];
#line 2826
      __cil_tmp27 = (void const   *)__cil_tmp26;
#line 2826
      __ret = __builtin_memcpy(__cil_tmp25, __cil_tmp27, __len);
      }
    }
    {
#line 2827
    srb->msg_count = (u8 )4;
#line 2828
    __cil_tmp28 = srb->state;
#line 2828
    __cil_tmp29 = (int )__cil_tmp28;
#line 2828
    __cil_tmp30 = __cil_tmp29 | 16384;
#line 2828
    srb->state = (u16 )__cil_tmp30;
#line 2829
    __cil_tmp31 = acb->io_port_base;
#line 2829
    __cil_tmp32 = __cil_tmp31 + 128UL;
#line 2829
    __cil_tmp33 = (int )__cil_tmp32;
#line 2829
    outw((unsigned short)512, __cil_tmp33);
#line 2829
    __cil_tmp34 = srb->state;
#line 2829
    __cil_tmp35 = (int )__cil_tmp34;
#line 2829
    __cil_tmp36 = __cil_tmp35 | 4;
#line 2829
    srb->state = (u16 )__cil_tmp36;
    }
  } else {

  }
  }
#line 2832
  __cil_tmp37 = dcb->sync_mode;
#line 2832
  __cil_tmp38 = (int )__cil_tmp37;
#line 2832
  __cil_tmp39 = __cil_tmp38 | 12;
#line 2832
  dcb->sync_mode = (u8 )__cil_tmp39;
  {
#line 2833
  __cil_tmp40 = srb->msgin_buf[3];
#line 2833
  __cil_tmp41 = (int )__cil_tmp40;
#line 2833
  if (__cil_tmp41 > 0) {
#line 2834
    __cil_tmp42 = dcb->sync_period;
#line 2834
    __cil_tmp43 = (int )__cil_tmp42;
#line 2834
    __cil_tmp44 = __cil_tmp43 | 16;
#line 2834
    dcb->sync_period = (u8 )__cil_tmp44;
  } else {
#line 2836
    __cil_tmp45 = dcb->sync_period;
#line 2836
    __cil_tmp46 = (int )__cil_tmp45;
#line 2836
    __cil_tmp47 = __cil_tmp46 & -17;
#line 2836
    dcb->sync_period = (u8 )__cil_tmp47;
  }
  }
#line 2837
  __cil_tmp48 = srb->state;
#line 2837
  __cil_tmp49 = (int )__cil_tmp48;
#line 2837
  __cil_tmp50 = __cil_tmp49 & -16385;
#line 2837
  srb->state = (u16 )__cil_tmp50;
  {
#line 2839
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2839
    goto while_break___0;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 2842
  reprogram_regs(acb, dcb);
  }
  {
#line 2843
  __cil_tmp51 = dcb->sync_mode;
#line 2843
  __cil_tmp52 = (int )__cil_tmp51;
#line 2843
  if (__cil_tmp52 & 1) {
    {
#line 2843
    __cil_tmp53 = dcb->sync_mode;
#line 2843
    __cil_tmp54 = (int )__cil_tmp53;
#line 2843
    __cil_tmp55 = __cil_tmp54 & 2;
#line 2843
    if (! __cil_tmp55) {
      {
#line 2845
      build_sdtr(acb, dcb, srb);
#line 2846
      __cil_tmp56 = acb->io_port_base;
#line 2846
      __cil_tmp57 = __cil_tmp56 + 128UL;
#line 2846
      __cil_tmp58 = (int )__cil_tmp57;
#line 2846
      outw((unsigned short)512, __cil_tmp58);
#line 2846
      __cil_tmp59 = srb->state;
#line 2846
      __cil_tmp60 = (int )__cil_tmp59;
#line 2846
      __cil_tmp61 = __cil_tmp60 | 4;
#line 2846
      srb->state = (u16 )__cil_tmp61;
      }
      {
#line 2847
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2847
        goto while_break___1;
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___1: ;
    } else {

    }
    }
  } else {

  }
  }
#line 2849
  return;
}
}
#line 2864 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void msgin_phase0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ struct DeviceCtlBlk *dcb ;
  u8 tmp___7 ;
  unsigned char tmp___8 ;
  u8 tmp___9 ;
  u8 __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  u8 *__cil_tmp14 ;
  u8 __cil_tmp15 ;
  u32 __cil_tmp16 ;
  u8 __cil_tmp17 ;
  int __cil_tmp18 ;
  u8 __cil_tmp19 ;
  int __cil_tmp20 ;
  u8 __cil_tmp21 ;
  int __cil_tmp22 ;
  u8 __cil_tmp23 ;
  int __cil_tmp24 ;
  u8 __cil_tmp25 ;
  int __cil_tmp26 ;
  u8 __cil_tmp27 ;
  int __cil_tmp28 ;
  u8 __cil_tmp29 ;
  int __cil_tmp30 ;
  u8 __cil_tmp31 ;
  int __cil_tmp32 ;
  u8 __cil_tmp33 ;
  int __cil_tmp34 ;
  u8 __cil_tmp35 ;
  int __cil_tmp36 ;
  u8 __cil_tmp37 ;
  int __cil_tmp38 ;
  u8 __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  int __cil_tmp42 ;
  u16 __cil_tmp43 ;
  int __cil_tmp44 ;
  u16 __cil_tmp45 ;
  int __cil_tmp46 ;
  u8 __cil_tmp47 ;
  int __cil_tmp48 ;
  u8 __cil_tmp49 ;
  int __cil_tmp50 ;
  u8 __cil_tmp51 ;
  int __cil_tmp52 ;
  u8 __cil_tmp53 ;
  int __cil_tmp54 ;
  u8 __cil_tmp55 ;
  int __cil_tmp56 ;
  u8 __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  u8 __cil_tmp60 ;
  int __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  int __cil_tmp64 ;
  u16 __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  u16 __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  u16 __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  unsigned long __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  int __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  int __cil_tmp79 ;

  {
#line 2867
  dcb = acb->active_dcb;
  {
#line 2868
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2868
    goto while_break;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2870
  tmp___7 = acb->msg_len;
#line 2870
  __cil_tmp8 = acb->msg_len;
#line 2870
  __cil_tmp9 = (int )__cil_tmp8;
#line 2870
  __cil_tmp10 = __cil_tmp9 + 1;
#line 2870
  acb->msg_len = (u8 )__cil_tmp10;
#line 2870
  __cil_tmp11 = acb->io_port_base;
#line 2870
  __cil_tmp12 = __cil_tmp11 + 152UL;
#line 2870
  __cil_tmp13 = (int )__cil_tmp12;
#line 2870
  tmp___8 = inb(__cil_tmp13);
#line 2870
  srb->msgin_buf[tmp___7] = tmp___8;
#line 2871
  __cil_tmp14 = & srb->msgin_buf[0];
#line 2871
  __cil_tmp15 = acb->msg_len;
#line 2871
  __cil_tmp16 = (u32 )__cil_tmp15;
#line 2871
  tmp___9 = msgin_completed(__cil_tmp14, __cil_tmp16);
  }
#line 2871
  if (tmp___9) {
    {
#line 2874
    __cil_tmp17 = srb->msgin_buf[0];
#line 2874
    __cil_tmp18 = (int )__cil_tmp17;
#line 2874
    if (__cil_tmp18 == 4) {
#line 2874
      goto case_4;
    } else {
      {
#line 2878
      __cil_tmp19 = srb->msgin_buf[0];
#line 2878
      __cil_tmp20 = (int )__cil_tmp19;
#line 2878
      if (__cil_tmp20 == 32) {
#line 2878
        goto case_32;
      } else {
        {
#line 2879
        __cil_tmp21 = srb->msgin_buf[0];
#line 2879
        __cil_tmp22 = (int )__cil_tmp21;
#line 2879
        if (__cil_tmp22 == 33) {
#line 2879
          goto case_32;
        } else {
          {
#line 2880
          __cil_tmp23 = srb->msgin_buf[0];
#line 2880
          __cil_tmp24 = (int )__cil_tmp23;
#line 2880
          if (__cil_tmp24 == 34) {
#line 2880
            goto case_32;
          } else {
            {
#line 2886
            __cil_tmp25 = srb->msgin_buf[0];
#line 2886
            __cil_tmp26 = (int )__cil_tmp25;
#line 2886
            if (__cil_tmp26 == 7) {
#line 2886
              goto case_7;
            } else {
              {
#line 2903
              __cil_tmp27 = srb->msgin_buf[0];
#line 2903
              __cil_tmp28 = (int )__cil_tmp27;
#line 2903
              if (__cil_tmp28 == 1) {
#line 2903
                goto case_1;
              } else {
                {
#line 2920
                __cil_tmp29 = srb->msgin_buf[0];
#line 2920
                __cil_tmp30 = (int )__cil_tmp29;
#line 2920
                if (__cil_tmp30 == 35) {
#line 2920
                  goto case_35;
                } else {
                  {
#line 2925
                  __cil_tmp31 = srb->msgin_buf[0];
#line 2925
                  __cil_tmp32 = (int )__cil_tmp31;
#line 2925
                  if (__cil_tmp32 == 0) {
#line 2925
                    goto case_0;
                  } else {
                    {
#line 2929
                    __cil_tmp33 = srb->msgin_buf[0];
#line 2929
                    __cil_tmp34 = (int )__cil_tmp33;
#line 2929
                    if (__cil_tmp34 == 2) {
#line 2929
                      goto case_2;
                    } else {
                      {
#line 2939
                      __cil_tmp35 = srb->msgin_buf[0];
#line 2939
                      __cil_tmp36 = (int )__cil_tmp35;
#line 2939
                      if (__cil_tmp36 == 3) {
#line 2939
                        goto case_3;
                      } else {
                        {
#line 2943
                        __cil_tmp37 = srb->msgin_buf[0];
#line 2943
                        __cil_tmp38 = (int )__cil_tmp37;
#line 2943
                        if (__cil_tmp38 == 6) {
#line 2943
                          goto case_6;
                        } else {
#line 2952
                          goto switch_default;
#line 2873
                          if (0) {
                            case_4: 
#line 2875
                            srb->state = (u16 )128;
#line 2876
                            goto switch_break;
                            case_32: 
                            {
#line 2881
                            __cil_tmp39 = srb->msgin_buf[1];
#line 2881
                            srb = msgin_qtag(acb, dcb, __cil_tmp39);
                            }
#line 2884
                            goto switch_break;
                            case_7: 
                            {
#line 2887
                            __cil_tmp40 = acb->io_port_base;
#line 2887
                            __cil_tmp41 = __cil_tmp40 + 128UL;
#line 2887
                            __cil_tmp42 = (int )__cil_tmp41;
#line 2887
                            outw((unsigned short)1026, __cil_tmp42);
                            }
                            {
#line 2890
                            __cil_tmp43 = srb->state;
#line 2890
                            __cil_tmp44 = (int )__cil_tmp43;
#line 2890
                            if (__cil_tmp44 & 8192) {
                              {
#line 2891
                              msgin_set_async(acb, srb);
                              }
#line 2892
                              goto switch_break;
                            } else {

                            }
                            }
                            {
#line 2895
                            __cil_tmp45 = srb->state;
#line 2895
                            __cil_tmp46 = (int )__cil_tmp45;
#line 2895
                            if (__cil_tmp46 & 16384) {
                              {
#line 2896
                              msgin_set_nowide(acb, srb);
                              }
#line 2897
                              goto switch_break;
                            } else {

                            }
                            }
                            {
#line 2899
                            enable_msgout_abort(acb, srb);
                            }
#line 2901
                            goto switch_break;
                            case_1: 
                            {
#line 2905
                            __cil_tmp47 = srb->msgin_buf[1];
#line 2905
                            __cil_tmp48 = (int )__cil_tmp47;
#line 2905
                            if (__cil_tmp48 == 3) {
                              {
#line 2905
                              __cil_tmp49 = srb->msgin_buf[2];
#line 2905
                              __cil_tmp50 = (int )__cil_tmp49;
#line 2905
                              if (__cil_tmp50 == 1) {
                                {
#line 2907
                                msgin_set_sync(acb, srb);
                                }
#line 2908
                                goto switch_break;
                              } else {

                              }
                              }
                            } else {

                            }
                            }
                            {
#line 2911
                            __cil_tmp51 = srb->msgin_buf[1];
#line 2911
                            __cil_tmp52 = (int )__cil_tmp51;
#line 2911
                            if (__cil_tmp52 == 2) {
                              {
#line 2911
                              __cil_tmp53 = srb->msgin_buf[2];
#line 2911
                              __cil_tmp54 = (int )__cil_tmp53;
#line 2911
                              if (__cil_tmp54 == 3) {
                                {
#line 2911
                                __cil_tmp55 = srb->msgin_buf[3];
#line 2911
                                __cil_tmp56 = (int )__cil_tmp55;
#line 2911
                                if (__cil_tmp56 <= 2) {
                                  {
#line 2914
                                  msgin_set_wide(acb, srb);
                                  }
#line 2915
                                  goto switch_break;
                                } else {

                                }
                                }
                              } else {

                              }
                              }
                            } else {

                            }
                            }
                            {
#line 2917
                            msgin_reject(acb, srb);
                            }
#line 2918
                            goto switch_break;
                            case_35: 
                            {
#line 2922
                            while (1) {
                              while_continue___0: /* CIL Label */ ;

#line 2922
                              goto while_break___0;
                            }
                            while_break___6: /* CIL Label */ ;
                            }

                            while_break___0: ;
#line 2923
                            goto switch_break;
                            case_0: 
#line 2927
                            goto switch_break;
                            case_2: 
                            {
#line 2934
                            while (1) {
                              while_continue___1: /* CIL Label */ ;

#line 2934
                              goto while_break___1;
                            }
                            while_break___7: /* CIL Label */ ;
                            }

                            while_break___1: ;
#line 2937
                            goto switch_break;
                            case_3: 
                            {
#line 2940
                            while (1) {
                              while_continue___2: /* CIL Label */ ;

#line 2940
                              goto while_break___2;
                            }
                            while_break___8: /* CIL Label */ ;
                            }

                            while_break___2: ;
#line 2941
                            goto switch_break;
                            case_6: 
                            {
#line 2944
                            while (1) {
                              while_continue___3: /* CIL Label */ ;

#line 2944
                              goto while_break___3;
                            }
                            while_break___9: /* CIL Label */ ;
                            }

                            while_break___3: 
                            {
#line 2948
                            __cil_tmp57 = dcb->flag;
#line 2948
                            __cil_tmp58 = (int )__cil_tmp57;
#line 2948
                            __cil_tmp59 = __cil_tmp58 | 1;
#line 2948
                            dcb->flag = (u8 )__cil_tmp59;
#line 2949
                            enable_msgout_abort(acb, srb);
                            }
#line 2950
                            goto switch_break;
                            switch_default: 
                            {
#line 2954
                            __cil_tmp60 = srb->msgin_buf[0];
#line 2954
                            __cil_tmp61 = (int )__cil_tmp60;
#line 2954
                            if (__cil_tmp61 & 128) {
                              {
#line 2955
                              while (1) {
                                while_continue___4: /* CIL Label */ ;

#line 2955
                                goto while_break___4;
                              }
                              while_break___10: /* CIL Label */ ;
                              }

                              while_break___4: 
                              {
#line 2956
                              srb->msg_count = (u8 )1;
#line 2957
                              srb->msgout_buf[0] = dcb->identify_msg;
#line 2958
                              __cil_tmp62 = acb->io_port_base;
#line 2958
                              __cil_tmp63 = __cil_tmp62 + 128UL;
#line 2958
                              __cil_tmp64 = (int )__cil_tmp63;
#line 2958
                              outw((unsigned short)512, __cil_tmp64);
#line 2958
                              __cil_tmp65 = srb->state;
#line 2958
                              __cil_tmp66 = (int )__cil_tmp65;
#line 2958
                              __cil_tmp67 = __cil_tmp66 | 4;
#line 2958
                              srb->state = (u16 )__cil_tmp67;
#line 2959
                              __cil_tmp68 = srb->state;
#line 2959
                              __cil_tmp69 = (int )__cil_tmp68;
#line 2959
                              __cil_tmp70 = __cil_tmp69 | 4;
#line 2959
                              srb->state = (u16 )__cil_tmp70;
                              }
                            } else {

                            }
                            }
                            {
#line 2962
                            msgin_reject(acb, srb);
                            }
                          } else {
                            switch_break: ;
                          }
                        }
                        }
                      }
                      }
                    }
                    }
                  }
                  }
                }
                }
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
#line 2966
    __cil_tmp71 = srb->state;
#line 2966
    __cil_tmp72 = (int )__cil_tmp71;
#line 2966
    __cil_tmp73 = __cil_tmp72 & -9;
#line 2966
    srb->state = (u16 )__cil_tmp73;
#line 2967
    acb->msg_len = (u8 )0;
  } else {

  }
  {
#line 2969
  *pscsi_status = (u16 )5;
#line 2970
  __cil_tmp74 = acb->io_port_base;
#line 2970
  __cil_tmp75 = __cil_tmp74 + 128UL;
#line 2970
  __cil_tmp76 = (int )__cil_tmp75;
#line 2970
  outw((unsigned short)2, __cil_tmp76);
#line 2971
  __cil_tmp77 = acb->io_port_base;
#line 2971
  __cil_tmp78 = __cil_tmp77 + 144UL;
#line 2971
  __cil_tmp79 = (int )__cil_tmp78;
#line 2971
  outb((unsigned char)216, __cil_tmp79);
  }
#line 2972
  return;
}
}
#line 2975 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void msgin_phase1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ char *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  u16 __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  u16 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  u16 __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;

  {
  {
#line 2978
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2978
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2979
  __cil_tmp4 = (char *)"msgin_phase1";
#line 2979
  clear_fifo(acb, __cil_tmp4);
#line 2980
  __cil_tmp5 = acb->io_port_base;
#line 2980
  __cil_tmp6 = __cil_tmp5 + 136UL;
#line 2980
  __cil_tmp7 = (int )__cil_tmp6;
#line 2980
  outl(1U, __cil_tmp7);
  }
  {
#line 2981
  __cil_tmp8 = srb->state;
#line 2981
  __cil_tmp9 = (int )__cil_tmp8;
#line 2981
  __cil_tmp10 = __cil_tmp9 & 8;
#line 2981
  if (! __cil_tmp10) {
#line 2982
    __cil_tmp11 = srb->state;
#line 2982
    __cil_tmp12 = (int )__cil_tmp11;
#line 2982
    __cil_tmp13 = __cil_tmp12 & -129;
#line 2982
    srb->state = (u16 )__cil_tmp13;
#line 2983
    __cil_tmp14 = srb->state;
#line 2983
    __cil_tmp15 = (int )__cil_tmp14;
#line 2983
    __cil_tmp16 = __cil_tmp15 | 8;
#line 2983
    srb->state = (u16 )__cil_tmp16;
  } else {

  }
  }
  {
#line 2985
  __cil_tmp17 = acb->io_port_base;
#line 2985
  __cil_tmp18 = __cil_tmp17 + 128UL;
#line 2985
  __cil_tmp19 = (int )__cil_tmp18;
#line 2985
  outw((unsigned short)2, __cil_tmp19);
#line 2987
  __cil_tmp20 = acb->io_port_base;
#line 2987
  __cil_tmp21 = __cil_tmp20 + 144UL;
#line 2987
  __cil_tmp22 = (int )__cil_tmp21;
#line 2987
  outb((unsigned char)194, __cil_tmp22);
  }
#line 2988
  return;
}
}
#line 2991 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void nop0(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ 

  {
#line 2994
  return;
}
}
#line 2997 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void nop1(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb , u16 *pscsi_status ) 
{ 

  {
#line 3000
  return;
}
}
#line 3003 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void set_xfer_rate(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb ) 
{ struct DeviceCtlBlk *i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u8 __cil_tmp6 ;
  int __cil_tmp7 ;
  u8 __cil_tmp8 ;
  struct list_head *__cil_tmp9 ;
  struct DeviceCtlBlk *__cil_tmp10 ;
  struct list_head *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  u8 __cil_tmp19 ;
  int __cil_tmp20 ;
  u8 __cil_tmp21 ;
  int __cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  struct DeviceCtlBlk *__cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 3008
  __cil_tmp6 = dcb->identify_msg;
#line 3008
  __cil_tmp7 = (int )__cil_tmp6;
#line 3008
  if (__cil_tmp7 & 7) {
#line 3009
    return;
  } else {

  }
  }
#line 3011
  if (acb->scan_devices) {
#line 3012
    __cil_tmp8 = dcb->sync_offset;
#line 3012
    current_sync_offset = (u16 )__cil_tmp8;
#line 3013
    return;
  } else {

  }
#line 3016
  __cil_tmp9 = acb->dcb_list.next;
#line 3016
  __mptr = (struct list_head  const  *)__cil_tmp9;
#line 3016
  __cil_tmp10 = (struct DeviceCtlBlk *)0;
#line 3016
  __cil_tmp11 = & __cil_tmp10->list;
#line 3016
  __cil_tmp12 = (unsigned int )__cil_tmp11;
#line 3016
  __cil_tmp13 = (char *)__mptr;
#line 3016
  __cil_tmp14 = __cil_tmp13 - __cil_tmp12;
#line 3016
  i = (struct DeviceCtlBlk *)__cil_tmp14;
  {
#line 3016
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 3016
    __cil_tmp15 = & acb->dcb_list;
#line 3016
    __cil_tmp16 = (unsigned long )__cil_tmp15;
#line 3016
    __cil_tmp17 = & i->list;
#line 3016
    __cil_tmp18 = (unsigned long )__cil_tmp17;
#line 3016
    if (__cil_tmp18 != __cil_tmp16) {

    } else {
#line 3016
      goto while_break;
    }
    }
    {
#line 3017
    __cil_tmp19 = dcb->target_id;
#line 3017
    __cil_tmp20 = (int )__cil_tmp19;
#line 3017
    __cil_tmp21 = i->target_id;
#line 3017
    __cil_tmp22 = (int )__cil_tmp21;
#line 3017
    if (__cil_tmp22 == __cil_tmp20) {
#line 3018
      i->sync_period = dcb->sync_period;
#line 3019
      i->sync_offset = dcb->sync_offset;
#line 3020
      i->sync_mode = dcb->sync_mode;
#line 3021
      i->min_nego_period = dcb->min_nego_period;
    } else {

    }
    }
#line 3016
    __cil_tmp23 = i->list.next;
#line 3016
    __mptr___0 = (struct list_head  const  *)__cil_tmp23;
#line 3016
    __cil_tmp24 = (struct DeviceCtlBlk *)0;
#line 3016
    __cil_tmp25 = & __cil_tmp24->list;
#line 3016
    __cil_tmp26 = (unsigned int )__cil_tmp25;
#line 3016
    __cil_tmp27 = (char *)__mptr___0;
#line 3016
    __cil_tmp28 = __cil_tmp27 - __cil_tmp26;
#line 3016
    i = (struct DeviceCtlBlk *)__cil_tmp28;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 3023
  return;
}
}
#line 3026 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void disconnect(struct AdapterCtlBlk *acb ) 
{ struct DeviceCtlBlk *dcb ;
  struct ScsiReqBlk *srb ;
  u8 tmp___7 ;
  u8 bval ;
  unsigned char tmp___8 ;
  struct Scsi_Host *__cil_tmp7 ;
  u8 __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long volatile   __cil_tmp11 ;
  unsigned long volatile   __cil_tmp12 ;
  unsigned long volatile   __cil_tmp13 ;
  unsigned long volatile   __cil_tmp14 ;
  char *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  u16 __cil_tmp24 ;
  int __cil_tmp25 ;
  u8 __cil_tmp26 ;
  int __cil_tmp27 ;
  u8 __cil_tmp28 ;
  int __cil_tmp29 ;
  u16 __cil_tmp30 ;
  int __cil_tmp31 ;
  u8 __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  struct Scsi_Host *__cil_tmp35 ;
  unsigned long volatile   __cil_tmp36 ;
  unsigned long volatile   __cil_tmp37 ;
  unsigned long volatile   __cil_tmp38 ;
  unsigned long volatile   __cil_tmp39 ;
  u8 __cil_tmp40 ;
  struct scsi_cmnd *__cil_tmp41 ;
  u8 __cil_tmp42 ;
  u16 __cil_tmp43 ;
  int __cil_tmp44 ;
  u16 __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  u16 __cil_tmp48 ;
  int __cil_tmp49 ;
  u16 __cil_tmp50 ;
  int __cil_tmp51 ;
  struct scsi_cmnd *__cil_tmp52 ;
  u8 __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  u16 __cil_tmp57 ;
  int __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  u16 __cil_tmp63 ;
  int __cil_tmp64 ;
  void *__cil_tmp65 ;

  {
#line 3028
  dcb = acb->active_dcb;
#line 3031
  if (! dcb) {
    {
#line 3032
    printk("<3>dc395x: disconnect: No such device\n");
#line 3033
    __const_udelay(2147500UL);
#line 3035
    __cil_tmp7 = acb->scsi_host;
#line 3035
    __cil_tmp8 = acb->eeprom.delay_time;
#line 3035
    __cil_tmp9 = (int )__cil_tmp8;
#line 3035
    __cil_tmp10 = 250 * __cil_tmp9;
#line 3035
    __cil_tmp11 = (unsigned long volatile   )__cil_tmp10;
#line 3035
    __cil_tmp12 = (unsigned long volatile   )125;
#line 3035
    __cil_tmp13 = jiffies + __cil_tmp12;
#line 3035
    __cil_tmp14 = __cil_tmp13 + __cil_tmp11;
#line 3035
    __cil_tmp7->last_reset = (unsigned long )__cil_tmp14;
#line 3038
    __cil_tmp15 = (char *)"disconnectEx";
#line 3038
    clear_fifo(acb, __cil_tmp15);
#line 3039
    __cil_tmp16 = acb->io_port_base;
#line 3039
    __cil_tmp17 = __cil_tmp16 + 128UL;
#line 3039
    __cil_tmp18 = (int )__cil_tmp17;
#line 3039
    outw((unsigned short)1, __cil_tmp18);
    }
#line 3040
    return;
  } else {

  }
#line 3042
  srb = dcb->active_srb;
#line 3043
  __cil_tmp19 = (void *)0;
#line 3043
  acb->active_dcb = (struct DeviceCtlBlk *)__cil_tmp19;
  {
#line 3044
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3044
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: 
  {
#line 3046
  srb->scsi_phase = (u8 )5;
#line 3047
  __cil_tmp20 = (char *)"disconnect";
#line 3047
  clear_fifo(acb, __cil_tmp20);
#line 3048
  __cil_tmp21 = acb->io_port_base;
#line 3048
  __cil_tmp22 = __cil_tmp21 + 128UL;
#line 3048
  __cil_tmp23 = (int )__cil_tmp22;
#line 3048
  outw((unsigned short)1, __cil_tmp23);
  }
  {
#line 3049
  __cil_tmp24 = srb->state;
#line 3049
  __cil_tmp25 = (int )__cil_tmp24;
#line 3049
  if (__cil_tmp25 & 32768) {
    {
#line 3050
    __cil_tmp26 = dcb->target_id;
#line 3050
    __cil_tmp27 = (int )__cil_tmp26;
#line 3050
    __cil_tmp28 = dcb->target_lun;
#line 3050
    __cil_tmp29 = (int )__cil_tmp28;
#line 3050
    printk("<3>dc395x: disconnect: Unexpected reselection <%02i-%i>\n", __cil_tmp27,
           __cil_tmp29);
#line 3053
    srb->state = (u16 )0;
#line 3054
    waiting_process_next(acb);
    }
  } else {
    {
#line 3055
    __cil_tmp30 = srb->state;
#line 3055
    __cil_tmp31 = (int )__cil_tmp30;
#line 3055
    if (__cil_tmp31 & 4096) {
      {
#line 3056
      __cil_tmp32 = dcb->flag;
#line 3056
      __cil_tmp33 = (int )__cil_tmp32;
#line 3056
      __cil_tmp34 = __cil_tmp33 & -2;
#line 3056
      dcb->flag = (u8 )__cil_tmp34;
#line 3057
      __cil_tmp35 = acb->scsi_host;
#line 3057
      __cil_tmp36 = (unsigned long volatile   )1;
#line 3057
      __cil_tmp37 = (unsigned long volatile   )125;
#line 3057
      __cil_tmp38 = jiffies + __cil_tmp37;
#line 3057
      __cil_tmp39 = __cil_tmp38 + __cil_tmp36;
#line 3057
      __cil_tmp35->last_reset = (unsigned long )__cil_tmp39;
#line 3058
      printk("<3>dc395x: disconnect: SRB_ABORT_SENT\n");
#line 3059
      __cil_tmp40 = (u8 )5;
#line 3059
      __cil_tmp41 = srb->cmd;
#line 3059
      __cil_tmp42 = (u8 )1;
#line 3059
      doing_srb_done(acb, __cil_tmp40, __cil_tmp41, __cil_tmp42);
#line 3060
      waiting_process_next(acb);
      }
    } else {
      {
#line 3062
      __cil_tmp43 = srb->state;
#line 3062
      __cil_tmp44 = (int )__cil_tmp43;
#line 3062
      if (__cil_tmp44 & 68) {
#line 3062
        goto _L___0;
      } else {
        {
#line 3062
        __cil_tmp45 = srb->state;
#line 3062
        __cil_tmp46 = (int )__cil_tmp45;
#line 3062
        __cil_tmp47 = __cil_tmp46 & 2176;
#line 3062
        if (! __cil_tmp47) {
          _L___0: 
          {
#line 3070
          __cil_tmp48 = srb->state;
#line 3070
          __cil_tmp49 = (int )__cil_tmp48;
#line 3070
          if (__cil_tmp49 != 64) {
            {
#line 3070
            __cil_tmp50 = srb->state;
#line 3070
            __cil_tmp51 = (int )__cil_tmp50;
#line 3070
            if (__cil_tmp51 != 4) {
              {
#line 3072
              srb->state = (u16 )2;
#line 3073
              __cil_tmp52 = srb->cmd;
#line 3073
              printk("<7>dc395x: disconnect: (0x%p) Unexpected\n", __cil_tmp52);
#line 3076
              srb->target_status = (u8 )255;
              }
#line 3077
              goto disc1;
            } else {
#line 3070
              goto _L;
            }
            }
          } else {
            _L: 
            {
#line 3080
            while (1) {
              while_continue___0: /* CIL Label */ ;

#line 3080
              goto while_break___0;
            }
            while_break___4: /* CIL Label */ ;
            }

            while_break___0: 
#line 3083
            tmp___7 = srb->retry_count;
#line 3083
            __cil_tmp53 = srb->retry_count;
#line 3083
            __cil_tmp54 = (int )__cil_tmp53;
#line 3083
            __cil_tmp55 = __cil_tmp54 + 1;
#line 3083
            srb->retry_count = (u8 )__cil_tmp55;
            {
#line 3083
            __cil_tmp56 = (int )tmp___7;
#line 3083
            if (__cil_tmp56 > 3) {
#line 3085
              srb->target_status = (u8 )255;
#line 3087
              goto disc1;
            } else
#line 3083
            if (acb->scan_devices) {
#line 3085
              srb->target_status = (u8 )255;
#line 3087
              goto disc1;
            } else {

            }
            }
            {
#line 3089
            free_tag(dcb, srb);
#line 3090
            srb_going_to_waiting_move(dcb, srb);
            }
            {
#line 3091
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 3091
              goto while_break___1;
            }
            while_break___5: /* CIL Label */ ;
            }

            while_break___1: 
            {
#line 3094
            waiting_set_timer(acb, 12UL);
            }
          }
          }
        } else {
          {
#line 3096
          __cil_tmp57 = srb->state;
#line 3096
          __cil_tmp58 = (int )__cil_tmp57;
#line 3096
          if (__cil_tmp58 & 128) {
            {
#line 3097
            __cil_tmp59 = acb->io_port_base;
#line 3097
            __cil_tmp60 = __cil_tmp59 + 131UL;
#line 3097
            __cil_tmp61 = (int )__cil_tmp60;
#line 3097
            tmp___8 = inb(__cil_tmp61);
#line 3097
            bval = tmp___8;
            }
            {
#line 3101
            __cil_tmp62 = (int )bval;
#line 3101
            if (__cil_tmp62 & 64) {
              {
#line 3102
              while (1) {
                while_continue___2: /* CIL Label */ ;

#line 3102
                goto while_break___2;
              }
              while_break___6: /* CIL Label */ ;
              }

              while_break___2: ;
            } else {
              {
#line 3107
              waiting_process_next(acb);
              }
            }
            }
          } else {
            {
#line 3108
            __cil_tmp63 = srb->state;
#line 3108
            __cil_tmp64 = (int )__cil_tmp63;
#line 3108
            if (__cil_tmp64 & 2048) {
              disc1: 
              {
#line 3113
              free_tag(dcb, srb);
#line 3114
              __cil_tmp65 = (void *)0;
#line 3114
              dcb->active_srb = (struct ScsiReqBlk *)__cil_tmp65;
#line 3115
              srb->state = (u16 )0;
#line 3116
              srb_done(acb, dcb, srb);
              }
            } else {

            }
            }
          }
          }
        }
        }
      }
      }
    }
    }
  }
  }
#line 3119
  return;
}
}
#line 3122 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void reselect(struct AdapterCtlBlk *acb ) 
{ struct DeviceCtlBlk *dcb ;
  struct ScsiReqBlk *srb ;
  u16 rsel_tar_lun_id ;
  u8 id ;
  u8 lun ;
  u8 arblostflag ;
  unsigned short tmp___7 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  u8 __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  u8 __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  u8 __cil_tmp35 ;
  int __cil_tmp36 ;
  u8 __cil_tmp37 ;
  int __cil_tmp38 ;
  u8 __cil_tmp39 ;
  int __cil_tmp40 ;
  u8 __cil_tmp41 ;
  int __cil_tmp42 ;
  u8 __cil_tmp43 ;
  int __cil_tmp44 ;
  u16 __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  u8 __cil_tmp48 ;
  int __cil_tmp49 ;
  u8 __cil_tmp50 ;
  int __cil_tmp51 ;
  u8 __cil_tmp52 ;
  int __cil_tmp53 ;
  struct Scsi_Host *__cil_tmp54 ;
  int __cil_tmp55 ;
  unsigned char __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int __cil_tmp59 ;
  u8 __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  int __cil_tmp63 ;
  u8 __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  int __cil_tmp67 ;
  u8 __cil_tmp68 ;
  unsigned long __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  int __cil_tmp71 ;
  unsigned long __cil_tmp72 ;
  unsigned long __cil_tmp73 ;
  int __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  int __cil_tmp77 ;

  {
#line 3124
  dcb = acb->active_dcb;
#line 3125
  __cil_tmp9 = (void *)0;
#line 3125
  srb = (struct ScsiReqBlk *)__cil_tmp9;
#line 3128
  arblostflag = (u8 )0;
  {
#line 3129
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3129
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
  {
#line 3131
  __cil_tmp10 = (char *)"reselect";
#line 3131
  clear_fifo(acb, __cil_tmp10);
#line 3134
  __cil_tmp11 = acb->io_port_base;
#line 3134
  __cil_tmp12 = __cil_tmp11 + 134UL;
#line 3134
  __cil_tmp13 = (int )__cil_tmp12;
#line 3134
  tmp___7 = inw(__cil_tmp13);
#line 3134
  rsel_tar_lun_id = tmp___7;
  }
#line 3135
  if (dcb) {
#line 3136
    srb = dcb->active_srb;
#line 3137
    if (! srb) {
      {
#line 3138
      printk("<7>dc395x: reselect: Arb lost Resel won, but active_srb == NULL\n");
#line 3140
      __cil_tmp14 = acb->io_port_base;
#line 3140
      __cil_tmp15 = __cil_tmp14 + 128UL;
#line 3140
      __cil_tmp16 = (int )__cil_tmp15;
#line 3140
      outw((unsigned short)2, __cil_tmp16);
      }
#line 3141
      return;
    } else {

    }
    {
#line 3144
    __cil_tmp17 = acb->scan_devices;
#line 3144
    if (! __cil_tmp17) {
      {
#line 3145
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 3145
        goto while_break___0;
      }
      while_break___3: /* CIL Label */ ;
      }

      while_break___0: 
      {
#line 3150
      arblostflag = (u8 )1;
#line 3153
      srb->state = (u16 )2;
#line 3154
      free_tag(dcb, srb);
#line 3155
      srb_going_to_waiting_move(dcb, srb);
#line 3156
      waiting_set_timer(acb, 12UL);
      }
    } else {

    }
    }
  } else {

  }
  {
#line 3162
  __cil_tmp18 = 128 << 8;
#line 3162
  __cil_tmp19 = (int )rsel_tar_lun_id;
#line 3162
  __cil_tmp20 = __cil_tmp19 & __cil_tmp18;
#line 3162
  if (! __cil_tmp20) {
    {
#line 3163
    __cil_tmp21 = (int )rsel_tar_lun_id;
#line 3163
    printk("<7>dc395x: reselect: Expects identify msg. Got %i!\n", __cil_tmp21);
    }
  } else {

  }
  }
  {
#line 3165
  __cil_tmp22 = (int )rsel_tar_lun_id;
#line 3165
  __cil_tmp23 = __cil_tmp22 & 255;
#line 3165
  id = (u8 )__cil_tmp23;
#line 3166
  __cil_tmp24 = (int )rsel_tar_lun_id;
#line 3166
  __cil_tmp25 = __cil_tmp24 >> 8;
#line 3166
  __cil_tmp26 = __cil_tmp25 & 7;
#line 3166
  lun = (u8 )__cil_tmp26;
#line 3167
  dcb = find_dcb(acb, id, lun);
  }
#line 3168
  if (! dcb) {
    {
#line 3169
    __cil_tmp27 = (int )id;
#line 3169
    __cil_tmp28 = (int )lun;
#line 3169
    printk("<3>dc395x: reselect: From non existent device <%02i-%i>\n", __cil_tmp27,
           __cil_tmp28);
#line 3171
    __cil_tmp29 = acb->io_port_base;
#line 3171
    __cil_tmp30 = __cil_tmp29 + 128UL;
#line 3171
    __cil_tmp31 = (int )__cil_tmp30;
#line 3171
    outw((unsigned short)2, __cil_tmp31);
    }
#line 3172
    return;
  } else {

  }
#line 3174
  acb->active_dcb = dcb;
  {
#line 3176
  __cil_tmp32 = dcb->dev_mode;
#line 3176
  __cil_tmp33 = (int )__cil_tmp32;
#line 3176
  __cil_tmp34 = __cil_tmp33 & 4;
#line 3176
  if (! __cil_tmp34) {
    {
#line 3177
    __cil_tmp35 = dcb->target_id;
#line 3177
    __cil_tmp36 = (int )__cil_tmp35;
#line 3177
    __cil_tmp37 = dcb->target_lun;
#line 3177
    __cil_tmp38 = (int )__cil_tmp37;
#line 3177
    printk("<7>dc395x: reselect: in spite of forbidden disconnection? <%02i-%i>\n",
           __cil_tmp36, __cil_tmp38);
    }
  } else {

  }
  }
  {
#line 3181
  __cil_tmp39 = dcb->sync_mode;
#line 3181
  __cil_tmp40 = (int )__cil_tmp39;
#line 3181
  if (__cil_tmp40 & 32) {
#line 3182
    srb = acb->tmp_srb;
#line 3183
    dcb->active_srb = srb;
  } else {
#line 3186
    srb = dcb->active_srb;
#line 3187
    if (! srb) {
      {
#line 3191
      __cil_tmp41 = dcb->target_id;
#line 3191
      __cil_tmp42 = (int )__cil_tmp41;
#line 3191
      __cil_tmp43 = dcb->target_lun;
#line 3191
      __cil_tmp44 = (int )__cil_tmp43;
#line 3191
      printk("<7>dc395x: reselect: w/o disconnected cmds <%02i-%i>\n", __cil_tmp42,
             __cil_tmp44);
#line 3194
      srb = acb->tmp_srb;
#line 3195
      srb->state = (u16 )32768;
#line 3196
      dcb->active_srb = srb;
#line 3197
      enable_msgout_abort(acb, srb);
      }
    } else {
      {
#line 3187
      __cil_tmp45 = srb->state;
#line 3187
      __cil_tmp46 = (int )__cil_tmp45;
#line 3187
      __cil_tmp47 = __cil_tmp46 & 128;
#line 3187
      if (! __cil_tmp47) {
        {
#line 3191
        __cil_tmp48 = dcb->target_id;
#line 3191
        __cil_tmp49 = (int )__cil_tmp48;
#line 3191
        __cil_tmp50 = dcb->target_lun;
#line 3191
        __cil_tmp51 = (int )__cil_tmp50;
#line 3191
        printk("<7>dc395x: reselect: w/o disconnected cmds <%02i-%i>\n", __cil_tmp49,
               __cil_tmp51);
#line 3194
        srb = acb->tmp_srb;
#line 3195
        srb->state = (u16 )32768;
#line 3196
        dcb->active_srb = srb;
#line 3197
        enable_msgout_abort(acb, srb);
        }
      } else {
        {
#line 3199
        __cil_tmp52 = dcb->flag;
#line 3199
        __cil_tmp53 = (int )__cil_tmp52;
#line 3199
        if (__cil_tmp53 & 1) {
          {
#line 3201
          enable_msgout_abort(acb, srb);
          }
        } else {
#line 3203
          srb->state = (u16 )256;
        }
        }
      }
      }
    }
  }
  }
#line 3207
  srb->scsi_phase = (u8 )5;
  {
#line 3210
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 3210
    goto while_break___1;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___1: 
  {
#line 3211
  __cil_tmp54 = acb->scsi_host;
#line 3211
  __cil_tmp55 = __cil_tmp54->this_id;
#line 3211
  __cil_tmp56 = (unsigned char )__cil_tmp55;
#line 3211
  __cil_tmp57 = acb->io_port_base;
#line 3211
  __cil_tmp58 = __cil_tmp57 + 135UL;
#line 3211
  __cil_tmp59 = (int )__cil_tmp58;
#line 3211
  outb(__cil_tmp56, __cil_tmp59);
#line 3212
  __cil_tmp60 = dcb->target_id;
#line 3212
  __cil_tmp61 = acb->io_port_base;
#line 3212
  __cil_tmp62 = __cil_tmp61 + 134UL;
#line 3212
  __cil_tmp63 = (int )__cil_tmp62;
#line 3212
  outb(__cil_tmp60, __cil_tmp63);
#line 3213
  __cil_tmp64 = dcb->sync_offset;
#line 3213
  __cil_tmp65 = acb->io_port_base;
#line 3213
  __cil_tmp66 = __cil_tmp65 + 132UL;
#line 3213
  __cil_tmp67 = (int )__cil_tmp66;
#line 3213
  outb(__cil_tmp64, __cil_tmp67);
#line 3214
  __cil_tmp68 = dcb->sync_period;
#line 3214
  __cil_tmp69 = acb->io_port_base;
#line 3214
  __cil_tmp70 = __cil_tmp69 + 133UL;
#line 3214
  __cil_tmp71 = (int )__cil_tmp70;
#line 3214
  outb(__cil_tmp68, __cil_tmp71);
#line 3215
  __cil_tmp72 = acb->io_port_base;
#line 3215
  __cil_tmp73 = __cil_tmp72 + 128UL;
#line 3215
  __cil_tmp74 = (int )__cil_tmp73;
#line 3215
  outw((unsigned short)2, __cil_tmp74);
#line 3217
  __cil_tmp75 = acb->io_port_base;
#line 3217
  __cil_tmp76 = __cil_tmp75 + 144UL;
#line 3217
  __cil_tmp77 = (int )__cil_tmp76;
#line 3217
  outb((unsigned char)216, __cil_tmp77);
  }
#line 3218
  return;
}
}
#line 3221 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
__inline static u8 tagq_blacklist(char *name ) 
{ 

  {
#line 3230
  return ((u8 )0);
}
}
#line 3237 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void disc_tagq_set(struct DeviceCtlBlk *dcb , struct ScsiInqData *ptr ) 
{ u8 tmp___7 ;
  u8 __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  u8 __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  u8 __cil_tmp10 ;
  int __cil_tmp11 ;
  u8 __cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  u16 __cil_tmp16 ;
  int __cil_tmp17 ;
  struct AdapterCtlBlk *__cil_tmp18 ;
  u8 __cil_tmp19 ;
  u8 __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
  {
#line 3240
  __cil_tmp4 = ptr->Vers;
#line 3240
  __cil_tmp5 = (int )__cil_tmp4;
#line 3240
  __cil_tmp6 = __cil_tmp5 & 7;
#line 3240
  if (__cil_tmp6 >= 2) {
#line 3240
    goto _L;
  } else {
    {
#line 3240
    __cil_tmp7 = ptr->RDF;
#line 3240
    __cil_tmp8 = (int )__cil_tmp7;
#line 3240
    __cil_tmp9 = __cil_tmp8 & 15;
#line 3240
    if (__cil_tmp9 == 2) {
      _L: 
      {
#line 3241
      __cil_tmp10 = ptr->Flags;
#line 3241
      __cil_tmp11 = (int )__cil_tmp10;
#line 3241
      if (__cil_tmp11 & 2) {
        {
#line 3241
        __cil_tmp12 = dcb->dev_mode;
#line 3241
        __cil_tmp13 = (int )__cil_tmp12;
#line 3241
        if (__cil_tmp13 & 16) {
          {
#line 3241
          __cil_tmp14 = (char *)ptr;
#line 3241
          __cil_tmp15 = __cil_tmp14 + 8;
#line 3241
          tmp___7 = tagq_blacklist(__cil_tmp15);
          }
#line 3241
          if (tmp___7) {
#line 3253
            dcb->max_command = (u16 )1;
          } else {
            {
#line 3247
            __cil_tmp16 = dcb->max_command;
#line 3247
            __cil_tmp17 = (int )__cil_tmp16;
#line 3247
            if (__cil_tmp17 == 1) {
#line 3248
              __cil_tmp18 = dcb->acb;
#line 3248
              __cil_tmp19 = __cil_tmp18->tag_max_num;
#line 3248
              dcb->max_command = (u16 )__cil_tmp19;
            } else {

            }
            }
#line 3250
            __cil_tmp20 = dcb->sync_mode;
#line 3250
            __cil_tmp21 = (int )__cil_tmp20;
#line 3250
            __cil_tmp22 = __cil_tmp21 | 32;
#line 3250
            dcb->sync_mode = (u8 )__cil_tmp22;
          }
        } else {
#line 3253
          dcb->max_command = (u16 )1;
        }
        }
      } else {
#line 3253
        dcb->max_command = (u16 )1;
      }
      }
    } else {

    }
    }
  }
  }
#line 3255
  return;
}
}
#line 3258 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void add_dev(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiInqData *ptr ) 
{ u8 bval1 ;
  u8 __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 3261
  __cil_tmp5 = ptr->DevType;
#line 3261
  __cil_tmp6 = (int )__cil_tmp5;
#line 3261
  __cil_tmp7 = __cil_tmp6 & 31;
#line 3261
  bval1 = (u8 )__cil_tmp7;
#line 3262
  dcb->dev_type = bval1;
#line 3264
  disc_tagq_set(dcb, ptr);
  }
#line 3265
  return;
}
}
#line 3269 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void pci_unmap_srb(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ struct scsi_cmnd *cmd ;
  enum dma_data_direction dir ;
  unsigned int tmp___7 ;
  unsigned int __cil_tmp6 ;
  struct pci_dev *__cil_tmp7 ;
  dma_addr_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
  {
#line 3271
  cmd = srb->cmd;
#line 3272
  dir = cmd->sc_data_direction;
#line 3274
  tmp___7 = scsi_sg_count(cmd);
  }
#line 3274
  if (tmp___7) {
    {
#line 3274
    __cil_tmp6 = (unsigned int )dir;
#line 3274
    if (__cil_tmp6 != 3U) {
      {
#line 3276
      while (1) {
        while_continue: /* CIL Label */ ;

#line 3276
        goto while_break;
      }
      while_break___1: /* CIL Label */ ;
      }

      while_break: 
      {
#line 3278
      __cil_tmp7 = acb->dev;
#line 3278
      __cil_tmp8 = srb->sg_bus_addr;
#line 3278
      __cil_tmp9 = 8UL * 64UL;
#line 3278
      pci_unmap_single(__cil_tmp7, __cil_tmp8, __cil_tmp9, 1);
      }
      {
#line 3281
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 3281
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: 
      {
#line 3284
      scsi_dma_unmap(cmd);
      }
    } else {

    }
    }
  } else {

  }
#line 3286
  return;
}
}
#line 3290 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void pci_unmap_srb_sense(struct AdapterCtlBlk *acb , struct ScsiReqBlk *srb ) 
{ u8 __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  struct pci_dev *__cil_tmp6 ;
  struct SGentry *__cil_tmp7 ;
  struct SGentry *__cil_tmp8 ;
  u32 __cil_tmp9 ;
  dma_addr_t __cil_tmp10 ;
  struct SGentry *__cil_tmp11 ;
  struct SGentry *__cil_tmp12 ;
  u32 __cil_tmp13 ;
  size_t __cil_tmp14 ;
  struct SGentry *__cil_tmp15 ;
  struct SGentry *__cil_tmp16 ;
  struct SGentry *__cil_tmp17 ;
  struct SGentry *__cil_tmp18 ;
  struct SGentry *__cil_tmp19 ;
  struct SGentry *__cil_tmp20 ;
  struct SGentry *__cil_tmp21 ;
  struct SGentry *__cil_tmp22 ;

  {
  {
#line 3293
  __cil_tmp3 = srb->flag;
#line 3293
  __cil_tmp4 = (int )__cil_tmp3;
#line 3293
  __cil_tmp5 = __cil_tmp4 & 1;
#line 3293
  if (! __cil_tmp5) {
#line 3294
    return;
  } else {

  }
  }
  {
#line 3296
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3296
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 3298
  __cil_tmp6 = acb->dev;
#line 3298
  __cil_tmp7 = srb->segment_x;
#line 3298
  __cil_tmp8 = __cil_tmp7 + 0;
#line 3298
  __cil_tmp9 = __cil_tmp8->address;
#line 3298
  __cil_tmp10 = (dma_addr_t )__cil_tmp9;
#line 3298
  __cil_tmp11 = srb->segment_x;
#line 3298
  __cil_tmp12 = __cil_tmp11 + 0;
#line 3298
  __cil_tmp13 = __cil_tmp12->length;
#line 3298
  __cil_tmp14 = (size_t )__cil_tmp13;
#line 3298
  pci_unmap_single(__cil_tmp6, __cil_tmp10, __cil_tmp14, 2);
#line 3301
  srb->total_xfer_length = srb->xferred;
#line 3302
  __cil_tmp15 = srb->segment_x;
#line 3302
  __cil_tmp16 = __cil_tmp15 + 0;
#line 3302
  __cil_tmp17 = srb->segment_x;
#line 3302
  __cil_tmp18 = __cil_tmp17 + 63;
#line 3302
  __cil_tmp16->address = __cil_tmp18->address;
#line 3304
  __cil_tmp19 = srb->segment_x;
#line 3304
  __cil_tmp20 = __cil_tmp19 + 0;
#line 3304
  __cil_tmp21 = srb->segment_x;
#line 3304
  __cil_tmp22 = __cil_tmp21 + 63;
#line 3304
  __cil_tmp20->length = __cil_tmp22->length;
  }
#line 3306
  return;
}
}
#line 3313 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void srb_done(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ u8 tempcnt ;
  u8 status ;
  struct scsi_cmnd *cmd ;
  enum dma_data_direction dir ;
  int ckc_only ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  struct scatterlist *tmp___9 ;
  unsigned int tmp___10 ;
  unsigned char *base ;
  struct ScsiInqData *ptr ;
  unsigned long flags ;
  struct scatterlist *sg ;
  struct scatterlist *tmp___11 ;
  size_t offset ;
  size_t len ;
  unsigned int tmp___12 ;
  void *tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___15 ;
  u8 __cil_tmp24 ;
  int __cil_tmp25 ;
  u8 __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  unsigned char __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned char *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  unsigned char __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  unsigned char *__cil_tmp41 ;
  unsigned char __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  unsigned char __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  unsigned char __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  unsigned char *__cil_tmp55 ;
  unsigned char *__cil_tmp56 ;
  unsigned char __cil_tmp57 ;
  int __cil_tmp58 ;
  u8 __cil_tmp59 ;
  int __cil_tmp60 ;
  u8 __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  u8 __cil_tmp64 ;
  int __cil_tmp65 ;
  unsigned char *__cil_tmp66 ;
  unsigned char *__cil_tmp67 ;
  unsigned char __cil_tmp68 ;
  int __cil_tmp69 ;
  u8 __cil_tmp70 ;
  int __cil_tmp71 ;
  u8 __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  u8 __cil_tmp75 ;
  int __cil_tmp76 ;
  unsigned char *__cil_tmp77 ;
  unsigned char *__cil_tmp78 ;
  unsigned char __cil_tmp79 ;
  int __cil_tmp80 ;
  u8 __cil_tmp81 ;
  int __cil_tmp82 ;
  u8 __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  u8 __cil_tmp86 ;
  int __cil_tmp87 ;
  unsigned char *__cil_tmp88 ;
  unsigned char *__cil_tmp89 ;
  unsigned char __cil_tmp90 ;
  int __cil_tmp91 ;
  u8 __cil_tmp92 ;
  int __cil_tmp93 ;
  u8 __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  u8 __cil_tmp97 ;
  int __cil_tmp98 ;
  unsigned char *__cil_tmp99 ;
  unsigned char *__cil_tmp100 ;
  unsigned char __cil_tmp101 ;
  int __cil_tmp102 ;
  u8 __cil_tmp103 ;
  int __cil_tmp104 ;
  u8 __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  u8 __cil_tmp108 ;
  int __cil_tmp109 ;
  unsigned char *__cil_tmp110 ;
  unsigned char *__cil_tmp111 ;
  unsigned char __cil_tmp112 ;
  int __cil_tmp113 ;
  unsigned char *__cil_tmp114 ;
  unsigned char *__cil_tmp115 ;
  unsigned char __cil_tmp116 ;
  int __cil_tmp117 ;
  unsigned char *__cil_tmp118 ;
  unsigned char *__cil_tmp119 ;
  unsigned char __cil_tmp120 ;
  int __cil_tmp121 ;
  unsigned char *__cil_tmp122 ;
  unsigned char *__cil_tmp123 ;
  unsigned char __cil_tmp124 ;
  int __cil_tmp125 ;
  unsigned char *__cil_tmp126 ;
  unsigned char *__cil_tmp127 ;
  unsigned int *__cil_tmp128 ;
  unsigned int __cil_tmp129 ;
  unsigned char *__cil_tmp130 ;
  unsigned char *__cil_tmp131 ;
  unsigned int *__cil_tmp132 ;
  unsigned int __cil_tmp133 ;
  unsigned char *__cil_tmp134 ;
  unsigned char *__cil_tmp135 ;
  unsigned char __cil_tmp136 ;
  int __cil_tmp137 ;
  unsigned char *__cil_tmp138 ;
  unsigned char *__cil_tmp139 ;
  unsigned int *__cil_tmp140 ;
  unsigned int __cil_tmp141 ;
  int __cil_tmp142 ;
  int __cil_tmp143 ;
  unsigned int __cil_tmp144 ;
  size_t __cil_tmp145 ;
  size_t __cil_tmp146 ;
  int __cil_tmp147 ;
  u8 __cil_tmp148 ;
  int __cil_tmp149 ;
  int __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  int __cil_tmp153 ;
  u8 __cil_tmp154 ;
  int __cil_tmp155 ;
  int __cil_tmp156 ;
  int __cil_tmp157 ;
  int __cil_tmp158 ;
  int __cil_tmp159 ;
  u8 __cil_tmp160 ;
  int __cil_tmp161 ;
  int __cil_tmp162 ;
  int __cil_tmp163 ;
  int __cil_tmp164 ;
  int __cil_tmp165 ;
  int __cil_tmp166 ;
  int __cil_tmp167 ;
  int __cil_tmp168 ;
  int __cil_tmp169 ;
  int __cil_tmp170 ;
  struct list_head *__cil_tmp171 ;
  u8 __cil_tmp172 ;
  int __cil_tmp173 ;
  u8 __cil_tmp174 ;
  int __cil_tmp175 ;
  int __cil_tmp176 ;
  int __cil_tmp177 ;
  int __cil_tmp178 ;
  int __cil_tmp179 ;
  int __cil_tmp180 ;
  int __cil_tmp181 ;
  int __cil_tmp182 ;
  int __cil_tmp183 ;
  int __cil_tmp184 ;
  u8 __cil_tmp185 ;
  int __cil_tmp186 ;
  int __cil_tmp187 ;
  int __cil_tmp188 ;
  int __cil_tmp189 ;
  int __cil_tmp190 ;
  int __cil_tmp191 ;
  int __cil_tmp192 ;
  int __cil_tmp193 ;
  int __cil_tmp194 ;
  u8 __cil_tmp195 ;
  int __cil_tmp196 ;
  int __cil_tmp197 ;
  int __cil_tmp198 ;
  u8 __cil_tmp199 ;
  int __cil_tmp200 ;
  int __cil_tmp201 ;
  int __cil_tmp202 ;
  int __cil_tmp203 ;
  int __cil_tmp204 ;
  u8 __cil_tmp205 ;
  int __cil_tmp206 ;
  int __cil_tmp207 ;
  int __cil_tmp208 ;
  int __cil_tmp209 ;
  unsigned int __cil_tmp210 ;
  struct pci_dev *__cil_tmp211 ;
  int __cil_tmp212 ;
  int __cil_tmp213 ;
  unsigned char *__cil_tmp214 ;
  unsigned char *__cil_tmp215 ;
  unsigned char __cil_tmp216 ;
  int __cil_tmp217 ;
  void *__cil_tmp218 ;
  int __cil_tmp219 ;
  unsigned char *__cil_tmp220 ;
  int __cil_tmp221 ;
  int __cil_tmp222 ;
  unsigned char *__cil_tmp223 ;
  unsigned char *__cil_tmp224 ;
  unsigned char __cil_tmp225 ;
  int __cil_tmp226 ;
  unsigned int __cil_tmp227 ;
  u8 __cil_tmp228 ;
  int __cil_tmp229 ;
  int __cil_tmp230 ;
  int __cil_tmp231 ;
  int __cil_tmp232 ;
  int __cil_tmp233 ;
  int __cil_tmp234 ;
  u8 __cil_tmp235 ;
  void *__cil_tmp236 ;
  size_t __cil_tmp237 ;
  int __cil_tmp238 ;
  size_t __cil_tmp239 ;
  struct ScsiReqBlk *__cil_tmp240 ;
  unsigned long __cil_tmp241 ;
  unsigned long __cil_tmp242 ;
  void (*__cil_tmp243)(struct scsi_cmnd * ) ;

  {
#line 3317
  cmd = srb->cmd;
#line 3318
  dir = cmd->sc_data_direction;
#line 3319
  ckc_only = 1;
  {
#line 3321
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3321
    goto while_break;
  }
  while_break___9: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 3323
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 3323
    goto while_break___0;
  }
  while_break___10: /* CIL Label */ ;
  }

  while_break___0: 
#line 3326
  status = srb->target_status;
  {
#line 3327
  __cil_tmp24 = srb->flag;
#line 3327
  __cil_tmp25 = (int )__cil_tmp24;
#line 3327
  if (__cil_tmp25 & 1) {
    {
#line 3328
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 3328
      goto while_break___1;
    }
    while_break___11: /* CIL Label */ ;
    }

    while_break___1: 
    {
#line 3329
    pci_unmap_srb_sense(acb, srb);
#line 3333
    __cil_tmp26 = srb->flag;
#line 3333
    __cil_tmp27 = (int )__cil_tmp26;
#line 3333
    __cil_tmp28 = __cil_tmp27 & -2;
#line 3333
    srb->flag = (u8 )__cil_tmp28;
#line 3334
    srb->adapter_status = (u8 )0;
#line 3335
    __cil_tmp29 = 1 << 1;
#line 3335
    srb->target_status = (u8 )__cil_tmp29;
    }
#line 3336
    if (0) {
      {
#line 3338
      __cil_tmp30 = cmd->sense_buffer;
#line 3338
      __cil_tmp31 = __cil_tmp30 + 2;
#line 3338
      __cil_tmp32 = *__cil_tmp31;
#line 3338
      __cil_tmp33 = (int )__cil_tmp32;
#line 3338
      __cil_tmp34 = __cil_tmp33 & 15;
#line 3338
      if (__cil_tmp34 == 2) {
#line 3338
        goto case_2;
      } else {
        {
#line 3344
        __cil_tmp35 = cmd->sense_buffer;
#line 3344
        __cil_tmp36 = __cil_tmp35 + 2;
#line 3344
        __cil_tmp37 = *__cil_tmp36;
#line 3344
        __cil_tmp38 = (int )__cil_tmp37;
#line 3344
        __cil_tmp39 = __cil_tmp38 & 15;
#line 3344
        if (__cil_tmp39 == 6) {
#line 3344
          goto case_6;
        } else {
          {
#line 3350
          __cil_tmp40 = cmd->sense_buffer;
#line 3350
          __cil_tmp41 = __cil_tmp40 + 2;
#line 3350
          __cil_tmp42 = *__cil_tmp41;
#line 3350
          __cil_tmp43 = (int )__cil_tmp42;
#line 3350
          __cil_tmp44 = __cil_tmp43 & 15;
#line 3350
          if (__cil_tmp44 == 5) {
#line 3350
            goto case_5;
          } else {
            {
#line 3356
            __cil_tmp45 = cmd->sense_buffer;
#line 3356
            __cil_tmp46 = __cil_tmp45 + 2;
#line 3356
            __cil_tmp47 = *__cil_tmp46;
#line 3356
            __cil_tmp48 = (int )__cil_tmp47;
#line 3356
            __cil_tmp49 = __cil_tmp48 & 15;
#line 3356
            if (__cil_tmp49 == 3) {
#line 3356
              goto case_3;
            } else {
              {
#line 3362
              __cil_tmp50 = cmd->sense_buffer;
#line 3362
              __cil_tmp51 = __cil_tmp50 + 2;
#line 3362
              __cil_tmp52 = *__cil_tmp51;
#line 3362
              __cil_tmp53 = (int )__cil_tmp52;
#line 3362
              __cil_tmp54 = __cil_tmp53 & 15;
#line 3362
              if (__cil_tmp54 == 4) {
#line 3362
                goto case_4;
              } else
#line 3337
              if (0) {
                case_2: 
                {
#line 3339
                __cil_tmp55 = cmd->cmnd;
#line 3339
                __cil_tmp56 = __cil_tmp55 + 0;
#line 3339
                __cil_tmp57 = *__cil_tmp56;
#line 3339
                __cil_tmp58 = (int )__cil_tmp57;
#line 3339
                __cil_tmp59 = dcb->target_id;
#line 3339
                __cil_tmp60 = (int )__cil_tmp59;
#line 3339
                __cil_tmp61 = dcb->target_lun;
#line 3339
                __cil_tmp62 = (int )__cil_tmp61;
#line 3339
                __cil_tmp63 = (int )status;
#line 3339
                __cil_tmp64 = acb->scan_devices;
#line 3339
                __cil_tmp65 = (int )__cil_tmp64;
#line 3339
                printk("<7>dc395x: ReqSense: NOT_READY cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",
                       __cil_tmp58, __cil_tmp60, __cil_tmp62, __cil_tmp63, __cil_tmp65);
                }
#line 3343
                goto switch_break;
                case_6: 
                {
#line 3345
                __cil_tmp66 = cmd->cmnd;
#line 3345
                __cil_tmp67 = __cil_tmp66 + 0;
#line 3345
                __cil_tmp68 = *__cil_tmp67;
#line 3345
                __cil_tmp69 = (int )__cil_tmp68;
#line 3345
                __cil_tmp70 = dcb->target_id;
#line 3345
                __cil_tmp71 = (int )__cil_tmp70;
#line 3345
                __cil_tmp72 = dcb->target_lun;
#line 3345
                __cil_tmp73 = (int )__cil_tmp72;
#line 3345
                __cil_tmp74 = (int )status;
#line 3345
                __cil_tmp75 = acb->scan_devices;
#line 3345
                __cil_tmp76 = (int )__cil_tmp75;
#line 3345
                printk("<7>dc395x: ReqSense: UNIT_ATTENTION cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",
                       __cil_tmp69, __cil_tmp71, __cil_tmp73, __cil_tmp74, __cil_tmp76);
                }
#line 3349
                goto switch_break;
                case_5: 
                {
#line 3351
                __cil_tmp77 = cmd->cmnd;
#line 3351
                __cil_tmp78 = __cil_tmp77 + 0;
#line 3351
                __cil_tmp79 = *__cil_tmp78;
#line 3351
                __cil_tmp80 = (int )__cil_tmp79;
#line 3351
                __cil_tmp81 = dcb->target_id;
#line 3351
                __cil_tmp82 = (int )__cil_tmp81;
#line 3351
                __cil_tmp83 = dcb->target_lun;
#line 3351
                __cil_tmp84 = (int )__cil_tmp83;
#line 3351
                __cil_tmp85 = (int )status;
#line 3351
                __cil_tmp86 = acb->scan_devices;
#line 3351
                __cil_tmp87 = (int )__cil_tmp86;
#line 3351
                printk("<7>dc395x: ReqSense: ILLEGAL_REQUEST cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",
                       __cil_tmp80, __cil_tmp82, __cil_tmp84, __cil_tmp85, __cil_tmp87);
                }
#line 3355
                goto switch_break;
                case_3: 
                {
#line 3357
                __cil_tmp88 = cmd->cmnd;
#line 3357
                __cil_tmp89 = __cil_tmp88 + 0;
#line 3357
                __cil_tmp90 = *__cil_tmp89;
#line 3357
                __cil_tmp91 = (int )__cil_tmp90;
#line 3357
                __cil_tmp92 = dcb->target_id;
#line 3357
                __cil_tmp93 = (int )__cil_tmp92;
#line 3357
                __cil_tmp94 = dcb->target_lun;
#line 3357
                __cil_tmp95 = (int )__cil_tmp94;
#line 3357
                __cil_tmp96 = (int )status;
#line 3357
                __cil_tmp97 = acb->scan_devices;
#line 3357
                __cil_tmp98 = (int )__cil_tmp97;
#line 3357
                printk("<7>dc395x: ReqSense: MEDIUM_ERROR cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",
                       __cil_tmp91, __cil_tmp93, __cil_tmp95, __cil_tmp96, __cil_tmp98);
                }
#line 3361
                goto switch_break;
                case_4: 
                {
#line 3363
                __cil_tmp99 = cmd->cmnd;
#line 3363
                __cil_tmp100 = __cil_tmp99 + 0;
#line 3363
                __cil_tmp101 = *__cil_tmp100;
#line 3363
                __cil_tmp102 = (int )__cil_tmp101;
#line 3363
                __cil_tmp103 = dcb->target_id;
#line 3363
                __cil_tmp104 = (int )__cil_tmp103;
#line 3363
                __cil_tmp105 = dcb->target_lun;
#line 3363
                __cil_tmp106 = (int )__cil_tmp105;
#line 3363
                __cil_tmp107 = (int )status;
#line 3363
                __cil_tmp108 = acb->scan_devices;
#line 3363
                __cil_tmp109 = (int )__cil_tmp108;
#line 3363
                printk("<7>dc395x: ReqSense: HARDWARE_ERROR cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",
                       __cil_tmp102, __cil_tmp104, __cil_tmp106, __cil_tmp107, __cil_tmp109);
                }
#line 3367
                goto switch_break;
              } else {
                switch_break: ;
              }
              }
            }
            }
          }
          }
        }
        }
      }
      }
      {
#line 3369
      __cil_tmp110 = cmd->sense_buffer;
#line 3369
      __cil_tmp111 = __cil_tmp110 + 7;
#line 3369
      __cil_tmp112 = *__cil_tmp111;
#line 3369
      __cil_tmp113 = (int )__cil_tmp112;
#line 3369
      if (__cil_tmp113 >= 6) {
        {
#line 3370
        __cil_tmp114 = cmd->sense_buffer;
#line 3370
        __cil_tmp115 = __cil_tmp114 + 2;
#line 3370
        __cil_tmp116 = *__cil_tmp115;
#line 3370
        __cil_tmp117 = (int )__cil_tmp116;
#line 3370
        __cil_tmp118 = cmd->sense_buffer;
#line 3370
        __cil_tmp119 = __cil_tmp118 + 12;
#line 3370
        __cil_tmp120 = *__cil_tmp119;
#line 3370
        __cil_tmp121 = (int )__cil_tmp120;
#line 3370
        __cil_tmp122 = cmd->sense_buffer;
#line 3370
        __cil_tmp123 = __cil_tmp122 + 13;
#line 3370
        __cil_tmp124 = *__cil_tmp123;
#line 3370
        __cil_tmp125 = (int )__cil_tmp124;
#line 3370
        __cil_tmp126 = cmd->sense_buffer;
#line 3370
        __cil_tmp127 = __cil_tmp126 + 3;
#line 3370
        __cil_tmp128 = (unsigned int *)__cil_tmp127;
#line 3370
        __cil_tmp129 = *__cil_tmp128;
#line 3370
        __cil_tmp130 = cmd->sense_buffer;
#line 3370
        __cil_tmp131 = __cil_tmp130 + 8;
#line 3370
        __cil_tmp132 = (unsigned int *)__cil_tmp131;
#line 3370
        __cil_tmp133 = *__cil_tmp132;
#line 3370
        printk("sense=0x%02x ASC=0x%02x ASCQ=0x%02x (0x%08x 0x%08x)\n", __cil_tmp117,
               __cil_tmp121, __cil_tmp125, __cil_tmp129, __cil_tmp133);
        }
      } else {
        {
#line 3377
        __cil_tmp134 = cmd->sense_buffer;
#line 3377
        __cil_tmp135 = __cil_tmp134 + 2;
#line 3377
        __cil_tmp136 = *__cil_tmp135;
#line 3377
        __cil_tmp137 = (int )__cil_tmp136;
#line 3377
        __cil_tmp138 = cmd->sense_buffer;
#line 3377
        __cil_tmp139 = __cil_tmp138 + 3;
#line 3377
        __cil_tmp140 = (unsigned int *)__cil_tmp139;
#line 3377
        __cil_tmp141 = *__cil_tmp140;
#line 3377
        printk("sense=0x%02x No ASC/ASCQ (0x%08x)\n", __cil_tmp137, __cil_tmp141);
        }
      }
      }
    } else {

    }
    {
#line 3382
    __cil_tmp142 = 1 << 1;
#line 3382
    __cil_tmp143 = (int )status;
#line 3382
    if (__cil_tmp143 == __cil_tmp142) {
#line 3383
      cmd->result = 4 << 16;
#line 3384
      goto ckc_e;
    } else {

    }
    }
    {
#line 3386
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 3386
      goto while_break___2;
    }
    while_break___12: /* CIL Label */ ;
    }

    while_break___2: ;
#line 3388
    if (srb->total_xfer_length) {
      {
#line 3388
      __cil_tmp144 = cmd->underflow;
#line 3388
      __cil_tmp145 = (size_t )__cil_tmp144;
#line 3388
      __cil_tmp146 = srb->total_xfer_length;
#line 3388
      if (__cil_tmp146 >= __cil_tmp145) {
#line 3390
        __cil_tmp147 = 1 << 1;
#line 3390
        __cil_tmp148 = srb->end_message;
#line 3390
        __cil_tmp149 = (int )__cil_tmp148;
#line 3390
        __cil_tmp150 = __cil_tmp149 << 8;
#line 3390
        __cil_tmp151 = 8 << 24;
#line 3390
        __cil_tmp152 = __cil_tmp151 | __cil_tmp150;
#line 3390
        cmd->result = __cil_tmp152 | __cil_tmp147;
      } else {
#line 3395
        __cil_tmp153 = 1 << 1;
#line 3395
        __cil_tmp154 = srb->end_message;
#line 3395
        __cil_tmp155 = (int )__cil_tmp154;
#line 3395
        __cil_tmp156 = __cil_tmp155 << 8;
#line 3395
        __cil_tmp157 = 8 << 24;
#line 3395
        __cil_tmp158 = __cil_tmp157 | __cil_tmp156;
#line 3395
        cmd->result = __cil_tmp158 | __cil_tmp153;
      }
      }
    } else {
#line 3395
      __cil_tmp159 = 1 << 1;
#line 3395
      __cil_tmp160 = srb->end_message;
#line 3395
      __cil_tmp161 = (int )__cil_tmp160;
#line 3395
      __cil_tmp162 = __cil_tmp161 << 8;
#line 3395
      __cil_tmp163 = 8 << 24;
#line 3395
      __cil_tmp164 = __cil_tmp163 | __cil_tmp162;
#line 3395
      cmd->result = __cil_tmp164 | __cil_tmp159;
    }
#line 3399
    goto ckc_e;
  } else {

  }
  }
#line 3403
  if (status) {
    {
#line 3407
    __cil_tmp165 = (int )status;
#line 3407
    __cil_tmp166 = __cil_tmp165 >> 1;
#line 3407
    __cil_tmp167 = __cil_tmp166 & 127;
#line 3407
    if (__cil_tmp167 == 1) {
      {
#line 3408
      request_sense(acb, dcb, srb);
      }
#line 3409
      return;
    } else {
      {
#line 3410
      __cil_tmp168 = (int )status;
#line 3410
      __cil_tmp169 = __cil_tmp168 >> 1;
#line 3410
      __cil_tmp170 = __cil_tmp169 & 127;
#line 3410
      if (__cil_tmp170 == 20) {
        {
#line 3411
        __cil_tmp171 = & dcb->srb_going_list;
#line 3411
        tmp___7 = list_size(__cil_tmp171);
#line 3411
        tempcnt = (u8 )tmp___7;
#line 3412
        __cil_tmp172 = dcb->target_id;
#line 3412
        __cil_tmp173 = (int )__cil_tmp172;
#line 3412
        __cil_tmp174 = dcb->target_lun;
#line 3412
        __cil_tmp175 = (int )__cil_tmp174;
#line 3412
        __cil_tmp176 = (int )tempcnt;
#line 3412
        printk("<6>dc395x: QUEUE_FULL for dev <%02i-%i> with %i cmnds\n", __cil_tmp173,
               __cil_tmp175, __cil_tmp176);
        }
        {
#line 3414
        __cil_tmp177 = (int )tempcnt;
#line 3414
        if (__cil_tmp177 > 1) {
#line 3415
          __cil_tmp178 = (int )tempcnt;
#line 3415
          __cil_tmp179 = __cil_tmp178 - 1;
#line 3415
          tempcnt = (u8 )__cil_tmp179;
        } else {

        }
        }
        {
#line 3416
        dcb->max_command = (u16 )tempcnt;
#line 3417
        free_tag(dcb, srb);
#line 3418
        srb_going_to_waiting_move(dcb, srb);
#line 3419
        waiting_set_timer(acb, 12UL);
#line 3420
        srb->adapter_status = (u8 )0;
#line 3421
        srb->target_status = (u8 )0;
        }
#line 3422
        return;
      } else {
        {
#line 3423
        __cil_tmp180 = (int )status;
#line 3423
        if (__cil_tmp180 == 255) {
#line 3424
          srb->adapter_status = (u8 )17;
#line 3425
          srb->target_status = (u8 )0;
#line 3426
          cmd->result = 1 << 16;
        } else {
#line 3428
          srb->adapter_status = (u8 )0;
#line 3429
          __cil_tmp181 = cmd->result;
#line 3429
          cmd->result = __cil_tmp181 & -16711681;
#line 3429
          __cil_tmp182 = 7 << 16;
#line 3429
          __cil_tmp183 = cmd->result;
#line 3429
          cmd->result = __cil_tmp183 | __cil_tmp182;
#line 3430
          __cil_tmp184 = cmd->result;
#line 3430
          cmd->result = __cil_tmp184 & -65281;
#line 3430
          __cil_tmp185 = srb->end_message;
#line 3430
          __cil_tmp186 = (int )__cil_tmp185;
#line 3430
          __cil_tmp187 = __cil_tmp186 << 8;
#line 3430
          __cil_tmp188 = cmd->result;
#line 3430
          cmd->result = __cil_tmp188 | __cil_tmp187;
#line 3431
          __cil_tmp189 = cmd->result;
#line 3431
          cmd->result = __cil_tmp189 & -256;
#line 3431
          __cil_tmp190 = (int )status;
#line 3431
          __cil_tmp191 = cmd->result;
#line 3431
          cmd->result = __cil_tmp191 | __cil_tmp190;
        }
        }
      }
      }
    }
    }
  } else {
#line 3438
    status = srb->adapter_status;
    {
#line 3439
    __cil_tmp192 = (int )status;
#line 3439
    if (__cil_tmp192 & 18) {
#line 3440
      srb->target_status = (u8 )0;
#line 3441
      __cil_tmp193 = cmd->result;
#line 3441
      cmd->result = __cil_tmp193 & -16711681;
#line 3441
      cmd->result = cmd->result;
#line 3442
      __cil_tmp194 = cmd->result;
#line 3442
      cmd->result = __cil_tmp194 & -65281;
#line 3442
      __cil_tmp195 = srb->end_message;
#line 3442
      __cil_tmp196 = (int )__cil_tmp195;
#line 3442
      __cil_tmp197 = __cil_tmp196 << 8;
#line 3442
      __cil_tmp198 = cmd->result;
#line 3442
      cmd->result = __cil_tmp198 | __cil_tmp197;
    } else {
      {
#line 3443
      __cil_tmp199 = srb->status;
#line 3443
      __cil_tmp200 = (int )__cil_tmp199;
#line 3443
      if (__cil_tmp200 & 16) {
#line 3444
        __cil_tmp201 = cmd->result;
#line 3444
        cmd->result = __cil_tmp201 & -16711681;
#line 3444
        __cil_tmp202 = 6 << 16;
#line 3444
        __cil_tmp203 = cmd->result;
#line 3444
        cmd->result = __cil_tmp203 | __cil_tmp202;
#line 3445
        __cil_tmp204 = cmd->result;
#line 3445
        cmd->result = __cil_tmp204 & -65281;
#line 3445
        __cil_tmp205 = srb->end_message;
#line 3445
        __cil_tmp206 = (int )__cil_tmp205;
#line 3445
        __cil_tmp207 = __cil_tmp206 << 8;
#line 3445
        __cil_tmp208 = cmd->result;
#line 3445
        cmd->result = __cil_tmp208 | __cil_tmp207;
      } else {
#line 3448
        srb->adapter_status = (u8 )0;
#line 3449
        srb->target_status = (u8 )0;
#line 3450
        __cil_tmp209 = cmd->result;
#line 3450
        cmd->result = __cil_tmp209 & -16711681;
#line 3450
        cmd->result = cmd->result;
      }
      }
    }
    }
  }
  {
#line 3454
  __cil_tmp210 = (unsigned int )dir;
#line 3454
  if (__cil_tmp210 != 3U) {
    {
#line 3454
    tmp___10 = scsi_sg_count(cmd);
    }
#line 3454
    if (tmp___10) {
      {
#line 3455
      tmp___8 = scsi_sg_count(cmd);
#line 3455
      tmp___9 = scsi_sglist(cmd);
#line 3455
      __cil_tmp211 = acb->dev;
#line 3455
      __cil_tmp212 = (int )tmp___8;
#line 3455
      __cil_tmp213 = (int )dir;
#line 3455
      pci_dma_sync_sg_for_cpu(__cil_tmp211, tmp___9, __cil_tmp212, __cil_tmp213);
      }
    } else {

    }
  } else {

  }
  }
#line 3458
  ckc_only = 0;
  ckc_e: 
  {
#line 3462
  __cil_tmp214 = cmd->cmnd;
#line 3462
  __cil_tmp215 = __cil_tmp214 + 0;
#line 3462
  __cil_tmp216 = *__cil_tmp215;
#line 3462
  __cil_tmp217 = (int )__cil_tmp216;
#line 3462
  if (__cil_tmp217 == 18) {
    {
#line 3463
    __cil_tmp218 = (void *)0;
#line 3463
    base = (unsigned char *)__cil_tmp218;
#line 3465
    flags = 0UL;
#line 3466
    tmp___11 = scsi_sglist(cmd);
#line 3466
    sg = tmp___11;
#line 3467
    offset = (size_t )0;
#line 3467
    len = 36UL;
    }
    {
#line 3469
    while (1) {
      while_continue___3: /* CIL Label */ ;

      {
#line 3469
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 3469
        flags = arch_local_irq_save();
        }
#line 3469
        goto while_break___4;
      }
      while_break___14: /* CIL Label */ ;
      }

      while_break___4: 
      {
#line 3469
      trace_hardirqs_off();
      }
#line 3469
      goto while_break___3;
    }
    while_break___13: /* CIL Label */ ;
    }

    while_break___3: 
    {
#line 3470
    tmp___12 = scsi_sg_count(cmd);
#line 3470
    __cil_tmp219 = (int )tmp___12;
#line 3470
    tmp___13 = scsi_kmap_atomic_sg(sg, __cil_tmp219, & offset, & len);
#line 3470
    base = (unsigned char *)tmp___13;
#line 3471
    __cil_tmp220 = base + offset;
#line 3471
    ptr = (struct ScsiInqData *)__cil_tmp220;
    }
#line 3473
    if (! ckc_only) {
      {
#line 3473
      __cil_tmp221 = cmd->result;
#line 3473
      __cil_tmp222 = __cil_tmp221 & 16711680;
#line 3473
      if (__cil_tmp222 == 0) {
        {
#line 3473
        __cil_tmp223 = cmd->cmnd;
#line 3473
        __cil_tmp224 = __cil_tmp223 + 2;
#line 3473
        __cil_tmp225 = *__cil_tmp224;
#line 3473
        __cil_tmp226 = (int )__cil_tmp225;
#line 3473
        if (__cil_tmp226 == 0) {
          {
#line 3473
          tmp___14 = scsi_bufflen(cmd);
          }
#line 3473
          if (tmp___14 >= 8U) {
            {
#line 3473
            __cil_tmp227 = (unsigned int )dir;
#line 3473
            if (__cil_tmp227 != 3U) {
#line 3473
              if (ptr) {
                {
#line 3473
                __cil_tmp228 = ptr->Vers;
#line 3473
                __cil_tmp229 = (int )__cil_tmp228;
#line 3473
                __cil_tmp230 = __cil_tmp229 & 7;
#line 3473
                if (__cil_tmp230 >= 2) {
#line 3476
                  dcb->inquiry7 = ptr->Flags;
                } else {

                }
                }
              } else {

              }
            } else {

            }
            }
          } else {

          }
        } else {

        }
        }
      } else {

      }
      }
    } else {

    }
    {
#line 3480
    __cil_tmp231 = cmd->result;
#line 3480
    if (__cil_tmp231 == 0) {
#line 3480
      goto _L;
    } else {
      {
#line 3480
      __cil_tmp232 = cmd->result;
#line 3480
      __cil_tmp233 = __cil_tmp232 >> 1;
#line 3480
      __cil_tmp234 = __cil_tmp233 & 127;
#line 3480
      if (__cil_tmp234 & 1) {
        _L: 
        {
#line 3483
        __cil_tmp235 = dcb->init_tcq_flag;
#line 3483
        if (! __cil_tmp235) {
          {
#line 3484
          add_dev(acb, dcb, ptr);
#line 3485
          dcb->init_tcq_flag = (u8 )1;
          }
        } else {

        }
        }
      } else {

      }
      }
    }
    }
    {
#line 3489
    __cil_tmp236 = (void *)base;
#line 3489
    scsi_kunmap_atomic_sg(__cil_tmp236);
    }
    {
#line 3490
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 3490
      tmp___15 = arch_irqs_disabled_flags(flags);
      }
#line 3490
      if (tmp___15) {
        {
#line 3490
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 3490
          arch_local_irq_restore(flags);
          }
#line 3490
          goto while_break___6;
        }
        while_break___16: /* CIL Label */ ;
        }

        while_break___6: 
        {
#line 3490
        trace_hardirqs_off();
        }
      } else {
        {
#line 3490
        trace_hardirqs_on();
        }
        {
#line 3490
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 3490
          arch_local_irq_restore(flags);
          }
#line 3490
          goto while_break___7;
        }
        while_break___17: /* CIL Label */ ;
        }

        while_break___7: ;
      }
#line 3490
      goto while_break___5;
    }
    while_break___15: /* CIL Label */ ;
    }

    while_break___5: ;
  } else {

  }
  }
  {
#line 3494
  __cil_tmp237 = srb->total_xfer_length;
#line 3494
  __cil_tmp238 = (int )__cil_tmp237;
#line 3494
  scsi_set_resid(cmd, __cil_tmp238);
#line 3496
  __cil_tmp239 = srb->total_xfer_length;
#line 3496
  cmd->SCp.this_residual = (int )__cil_tmp239;
#line 3497
  cmd->SCp.buffers_residual = 0;
#line 3506
  srb_going_remove(dcb, srb);
  }
  {
#line 3508
  __cil_tmp240 = acb->tmp_srb;
#line 3508
  __cil_tmp241 = (unsigned long )__cil_tmp240;
#line 3508
  __cil_tmp242 = (unsigned long )srb;
#line 3508
  if (__cil_tmp242 == __cil_tmp241) {
    {
#line 3509
    printk("<3>dc395x: srb_done: ERROR! Completed cmd with tmp_srb\n");
    }
  } else {
    {
#line 3511
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 3511
      goto while_break___8;
    }
    while_break___18: /* CIL Label */ ;
    }

    while_break___8: 
    {
#line 3513
    srb_free_insert(acb, srb);
    }
  }
  }
  {
#line 3515
  pci_unmap_srb(acb, srb);
#line 3517
  __cil_tmp243 = cmd->scsi_done;
#line 3517
  (*__cil_tmp243)(cmd);
#line 3518
  waiting_process_next(acb);
  }
#line 3519
  return;
}
}
#line 3523 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void doing_srb_done(struct AdapterCtlBlk *acb , u8 did_flag , struct scsi_cmnd *cmd ,
                           u8 force ) 
{ struct DeviceCtlBlk *dcb ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct ScsiReqBlk *srb ;
  struct ScsiReqBlk *tmp___7 ;
  struct scsi_cmnd *p ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  enum dma_data_direction dir ;
  int result ;
  int tmp___8 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  int result___0 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  struct list_head *__cil_tmp23 ;
  struct DeviceCtlBlk *__cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  struct list_head *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  struct list_head *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  struct list_head *__cil_tmp33 ;
  struct ScsiReqBlk *__cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  struct list_head *__cil_tmp39 ;
  struct ScsiReqBlk *__cil_tmp40 ;
  struct list_head *__cil_tmp41 ;
  unsigned int __cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  struct list_head *__cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int __cil_tmp49 ;
  struct scsi_device *__cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  struct scsi_device *__cil_tmp52 ;
  unsigned int __cil_tmp53 ;
  void (*__cil_tmp54)(struct scsi_cmnd * ) ;
  struct list_head *__cil_tmp55 ;
  struct ScsiReqBlk *__cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  struct list_head *__cil_tmp61 ;
  struct list_head  const  *__cil_tmp62 ;
  u8 __cil_tmp63 ;
  int __cil_tmp64 ;
  u8 __cil_tmp65 ;
  int __cil_tmp66 ;
  u8 __cil_tmp67 ;
  int __cil_tmp68 ;
  u8 __cil_tmp69 ;
  int __cil_tmp70 ;
  u32 __cil_tmp71 ;
  struct list_head *__cil_tmp72 ;
  struct ScsiReqBlk *__cil_tmp73 ;
  struct list_head *__cil_tmp74 ;
  unsigned int __cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  struct list_head *__cil_tmp78 ;
  struct ScsiReqBlk *__cil_tmp79 ;
  struct list_head *__cil_tmp80 ;
  unsigned int __cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  struct list_head *__cil_tmp84 ;
  unsigned long __cil_tmp85 ;
  struct list_head *__cil_tmp86 ;
  unsigned long __cil_tmp87 ;
  int __cil_tmp88 ;
  struct scsi_device *__cil_tmp89 ;
  unsigned int __cil_tmp90 ;
  struct scsi_device *__cil_tmp91 ;
  unsigned int __cil_tmp92 ;
  void (*__cil_tmp93)(struct scsi_cmnd * ) ;
  struct list_head *__cil_tmp94 ;
  struct ScsiReqBlk *__cil_tmp95 ;
  struct list_head *__cil_tmp96 ;
  unsigned int __cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  struct list_head *__cil_tmp100 ;
  struct list_head  const  *__cil_tmp101 ;
  struct list_head *__cil_tmp102 ;
  u8 __cil_tmp103 ;
  int __cil_tmp104 ;
  u8 __cil_tmp105 ;
  int __cil_tmp106 ;
  u8 __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  struct list_head *__cil_tmp110 ;
  struct DeviceCtlBlk *__cil_tmp111 ;
  struct list_head *__cil_tmp112 ;
  unsigned int __cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;

  {
  {
#line 3527
  printk("<6>dc395x: doing_srb_done: pids ");
#line 3529
  __cil_tmp23 = acb->dcb_list.next;
#line 3529
  __mptr = (struct list_head  const  *)__cil_tmp23;
#line 3529
  __cil_tmp24 = (struct DeviceCtlBlk *)0;
#line 3529
  __cil_tmp25 = & __cil_tmp24->list;
#line 3529
  __cil_tmp26 = (unsigned int )__cil_tmp25;
#line 3529
  __cil_tmp27 = (char *)__mptr;
#line 3529
  __cil_tmp28 = __cil_tmp27 - __cil_tmp26;
#line 3529
  dcb = (struct DeviceCtlBlk *)__cil_tmp28;
  }
  {
#line 3529
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 3529
    __cil_tmp29 = & acb->dcb_list;
#line 3529
    __cil_tmp30 = (unsigned long )__cil_tmp29;
#line 3529
    __cil_tmp31 = & dcb->list;
#line 3529
    __cil_tmp32 = (unsigned long )__cil_tmp31;
#line 3529
    if (__cil_tmp32 != __cil_tmp30) {

    } else {
#line 3529
      goto while_break;
    }
    }
#line 3534
    __cil_tmp33 = dcb->srb_going_list.next;
#line 3534
    __mptr___1 = (struct list_head  const  *)__cil_tmp33;
#line 3534
    __cil_tmp34 = (struct ScsiReqBlk *)0;
#line 3534
    __cil_tmp35 = & __cil_tmp34->list;
#line 3534
    __cil_tmp36 = (unsigned int )__cil_tmp35;
#line 3534
    __cil_tmp37 = (char *)__mptr___1;
#line 3534
    __cil_tmp38 = __cil_tmp37 - __cil_tmp36;
#line 3534
    srb = (struct ScsiReqBlk *)__cil_tmp38;
#line 3534
    __cil_tmp39 = srb->list.next;
#line 3534
    __mptr___2 = (struct list_head  const  *)__cil_tmp39;
#line 3534
    __cil_tmp40 = (struct ScsiReqBlk *)0;
#line 3534
    __cil_tmp41 = & __cil_tmp40->list;
#line 3534
    __cil_tmp42 = (unsigned int )__cil_tmp41;
#line 3534
    __cil_tmp43 = (char *)__mptr___2;
#line 3534
    __cil_tmp44 = __cil_tmp43 - __cil_tmp42;
#line 3534
    tmp___7 = (struct ScsiReqBlk *)__cil_tmp44;
    {
#line 3534
    while (1) {
      while_continue___0: /* CIL Label */ ;

      {
#line 3534
      __cil_tmp45 = & dcb->srb_going_list;
#line 3534
      __cil_tmp46 = (unsigned long )__cil_tmp45;
#line 3534
      __cil_tmp47 = & srb->list;
#line 3534
      __cil_tmp48 = (unsigned long )__cil_tmp47;
#line 3534
      if (__cil_tmp48 != __cil_tmp46) {

      } else {
#line 3534
        goto while_break___0;
      }
      }
      {
#line 3538
      p = srb->cmd;
#line 3539
      dir = p->sc_data_direction;
#line 3540
      __cil_tmp49 = (int )did_flag;
#line 3540
      result = __cil_tmp49 << 16;
#line 3541
      __cil_tmp50 = p->device;
#line 3541
      __cil_tmp51 = __cil_tmp50->id;
#line 3541
      __cil_tmp52 = p->device;
#line 3541
      __cil_tmp53 = __cil_tmp52->lun;
#line 3541
      printk("G:%p(%02i-%i) ", p, __cil_tmp51, __cil_tmp53);
#line 3543
      srb_going_remove(dcb, srb);
#line 3544
      free_tag(dcb, srb);
#line 3545
      srb_free_insert(acb, srb);
#line 3546
      p->result = result;
#line 3547
      pci_unmap_srb_sense(acb, srb);
#line 3548
      pci_unmap_srb(acb, srb);
      }
#line 3549
      if (force) {
        {
#line 3552
        __cil_tmp54 = p->scsi_done;
#line 3552
        (*__cil_tmp54)(p);
        }
      } else {

      }
#line 3534
      srb = tmp___7;
#line 3534
      __cil_tmp55 = tmp___7->list.next;
#line 3534
      __mptr___3 = (struct list_head  const  *)__cil_tmp55;
#line 3534
      __cil_tmp56 = (struct ScsiReqBlk *)0;
#line 3534
      __cil_tmp57 = & __cil_tmp56->list;
#line 3534
      __cil_tmp58 = (unsigned int )__cil_tmp57;
#line 3534
      __cil_tmp59 = (char *)__mptr___3;
#line 3534
      __cil_tmp60 = __cil_tmp59 - __cil_tmp58;
#line 3534
      tmp___7 = (struct ScsiReqBlk *)__cil_tmp60;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 3555
    __cil_tmp61 = & dcb->srb_going_list;
#line 3555
    __cil_tmp62 = (struct list_head  const  *)__cil_tmp61;
#line 3555
    tmp___8 = list_empty(__cil_tmp62);
    }
#line 3555
    if (tmp___8) {

    } else {
      {
#line 3556
      __cil_tmp63 = dcb->target_id;
#line 3556
      __cil_tmp64 = (int )__cil_tmp63;
#line 3556
      __cil_tmp65 = dcb->target_lun;
#line 3556
      __cil_tmp66 = (int )__cil_tmp65;
#line 3556
      printk("<7>dc395x: How could the ML send cmnds to the Going queue? <%02i-%i>\n",
             __cil_tmp64, __cil_tmp66);
      }
    }
#line 3559
    if (dcb->tag_mask) {
      {
#line 3560
      __cil_tmp67 = dcb->target_id;
#line 3560
      __cil_tmp68 = (int )__cil_tmp67;
#line 3560
      __cil_tmp69 = dcb->target_lun;
#line 3560
      __cil_tmp70 = (int )__cil_tmp69;
#line 3560
      __cil_tmp71 = dcb->tag_mask;
#line 3560
      printk("<7>dc395x: tag_mask for <%02i-%i> should be empty, is %08x!\n", __cil_tmp68,
             __cil_tmp70, __cil_tmp71);
      }
    } else {

    }
#line 3566
    __cil_tmp72 = dcb->srb_waiting_list.next;
#line 3566
    __mptr___4 = (struct list_head  const  *)__cil_tmp72;
#line 3566
    __cil_tmp73 = (struct ScsiReqBlk *)0;
#line 3566
    __cil_tmp74 = & __cil_tmp73->list;
#line 3566
    __cil_tmp75 = (unsigned int )__cil_tmp74;
#line 3566
    __cil_tmp76 = (char *)__mptr___4;
#line 3566
    __cil_tmp77 = __cil_tmp76 - __cil_tmp75;
#line 3566
    srb = (struct ScsiReqBlk *)__cil_tmp77;
#line 3566
    __cil_tmp78 = srb->list.next;
#line 3566
    __mptr___5 = (struct list_head  const  *)__cil_tmp78;
#line 3566
    __cil_tmp79 = (struct ScsiReqBlk *)0;
#line 3566
    __cil_tmp80 = & __cil_tmp79->list;
#line 3566
    __cil_tmp81 = (unsigned int )__cil_tmp80;
#line 3566
    __cil_tmp82 = (char *)__mptr___5;
#line 3566
    __cil_tmp83 = __cil_tmp82 - __cil_tmp81;
#line 3566
    tmp___7 = (struct ScsiReqBlk *)__cil_tmp83;
    {
#line 3566
    while (1) {
      while_continue___1: /* CIL Label */ ;

      {
#line 3566
      __cil_tmp84 = & dcb->srb_waiting_list;
#line 3566
      __cil_tmp85 = (unsigned long )__cil_tmp84;
#line 3566
      __cil_tmp86 = & srb->list;
#line 3566
      __cil_tmp87 = (unsigned long )__cil_tmp86;
#line 3566
      if (__cil_tmp87 != __cil_tmp85) {

      } else {
#line 3566
        goto while_break___1;
      }
      }
      {
#line 3568
      p = srb->cmd;
#line 3570
      __cil_tmp88 = (int )did_flag;
#line 3570
      result___0 = __cil_tmp88 << 16;
#line 3571
      __cil_tmp89 = p->device;
#line 3571
      __cil_tmp90 = __cil_tmp89->id;
#line 3571
      __cil_tmp91 = p->device;
#line 3571
      __cil_tmp92 = __cil_tmp91->lun;
#line 3571
      printk("W:%p<%02i-%i>", p, __cil_tmp90, __cil_tmp92);
#line 3573
      srb_waiting_remove(dcb, srb);
#line 3574
      srb_free_insert(acb, srb);
#line 3575
      p->result = result___0;
#line 3576
      pci_unmap_srb_sense(acb, srb);
#line 3577
      pci_unmap_srb(acb, srb);
      }
#line 3578
      if (force) {
        {
#line 3581
        __cil_tmp93 = cmd->scsi_done;
#line 3581
        (*__cil_tmp93)(cmd);
        }
      } else {

      }
#line 3566
      srb = tmp___7;
#line 3566
      __cil_tmp94 = tmp___7->list.next;
#line 3566
      __mptr___6 = (struct list_head  const  *)__cil_tmp94;
#line 3566
      __cil_tmp95 = (struct ScsiReqBlk *)0;
#line 3566
      __cil_tmp96 = & __cil_tmp95->list;
#line 3566
      __cil_tmp97 = (unsigned int )__cil_tmp96;
#line 3566
      __cil_tmp98 = (char *)__mptr___6;
#line 3566
      __cil_tmp99 = __cil_tmp98 - __cil_tmp97;
#line 3566
      tmp___7 = (struct ScsiReqBlk *)__cil_tmp99;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
    {
#line 3584
    __cil_tmp100 = & dcb->srb_waiting_list;
#line 3584
    __cil_tmp101 = (struct list_head  const  *)__cil_tmp100;
#line 3584
    tmp___10 = list_empty(__cil_tmp101);
    }
#line 3584
    if (tmp___10) {

    } else {
      {
#line 3585
      __cil_tmp102 = & dcb->srb_waiting_list;
#line 3585
      tmp___9 = list_size(__cil_tmp102);
#line 3585
      __cil_tmp103 = dcb->target_id;
#line 3585
      __cil_tmp104 = (int )__cil_tmp103;
#line 3585
      __cil_tmp105 = dcb->target_lun;
#line 3585
      __cil_tmp106 = (int )__cil_tmp105;
#line 3585
      printk("<7>dc395x: ML queued %i cmnds again to <%02i-%i>\n", tmp___9, __cil_tmp104,
             __cil_tmp106);
      }
    }
#line 3588
    __cil_tmp107 = dcb->flag;
#line 3588
    __cil_tmp108 = (int )__cil_tmp107;
#line 3588
    __cil_tmp109 = __cil_tmp108 & -2;
#line 3588
    dcb->flag = (u8 )__cil_tmp109;
#line 3529
    __cil_tmp110 = dcb->list.next;
#line 3529
    __mptr___0 = (struct list_head  const  *)__cil_tmp110;
#line 3529
    __cil_tmp111 = (struct DeviceCtlBlk *)0;
#line 3529
    __cil_tmp112 = & __cil_tmp111->list;
#line 3529
    __cil_tmp113 = (unsigned int )__cil_tmp112;
#line 3529
    __cil_tmp114 = (char *)__mptr___0;
#line 3529
    __cil_tmp115 = __cil_tmp114 - __cil_tmp113;
#line 3529
    dcb = (struct DeviceCtlBlk *)__cil_tmp115;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
  {
#line 3590
  printk("\n");
  }
#line 3591
  return;
}
}
#line 3594 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void reset_scsi_bus(struct AdapterCtlBlk *acb ) 
{ unsigned char tmp___7 ;
  u8 __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 3596
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3596
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 3597
  __cil_tmp3 = acb->acb_flag;
#line 3597
  __cil_tmp4 = (int )__cil_tmp3;
#line 3597
  __cil_tmp5 = __cil_tmp4 | 1;
#line 3597
  acb->acb_flag = (u8 )__cil_tmp5;
#line 3598
  __cil_tmp6 = acb->io_port_base;
#line 3598
  __cil_tmp7 = __cil_tmp6 + 128UL;
#line 3598
  __cil_tmp8 = (int )__cil_tmp7;
#line 3598
  outw((unsigned short)8, __cil_tmp8);
  }
  {
#line 3600
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3600
    __cil_tmp9 = acb->io_port_base;
#line 3600
    __cil_tmp10 = __cil_tmp9 + 132UL;
#line 3600
    __cil_tmp11 = (int )__cil_tmp10;
#line 3600
    tmp___7 = inb(__cil_tmp11);
    }
    {
#line 3600
    __cil_tmp12 = (int )tmp___7;
#line 3600
    if (__cil_tmp12 & 4) {
#line 3600
      goto while_break___0;
    } else {

    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 3602
  return;
}
}
#line 3605 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void set_basic_config(struct AdapterCtlBlk *acb ) 
{ u8 bval ;
  u16 wval ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;
  u8 __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  u8 __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  struct Scsi_Host *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  int __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 3609
  __cil_tmp6 = acb->sel_timeout;
#line 3609
  __cil_tmp7 = acb->io_port_base;
#line 3609
  __cil_tmp8 = __cil_tmp7 + 145UL;
#line 3609
  __cil_tmp9 = (int )__cil_tmp8;
#line 3609
  outb(__cil_tmp6, __cil_tmp9);
  }
  {
#line 3610
  __cil_tmp10 = acb->config;
#line 3610
  __cil_tmp11 = (int )__cil_tmp10;
#line 3610
  if (__cil_tmp11 & 8) {
#line 3611
    bval = (u8 )113;
  } else {
#line 3613
    bval = (u8 )97;
  }
  }
  {
#line 3615
  __cil_tmp12 = acb->io_port_base;
#line 3615
  __cil_tmp13 = __cil_tmp12 + 141UL;
#line 3615
  __cil_tmp14 = (int )__cil_tmp13;
#line 3615
  outb(bval, __cil_tmp14);
#line 3618
  __cil_tmp15 = acb->io_port_base;
#line 3618
  __cil_tmp16 = __cil_tmp15 + 142UL;
#line 3618
  __cil_tmp17 = (int )__cil_tmp16;
#line 3618
  outb((unsigned char)3, __cil_tmp17);
#line 3620
  __cil_tmp18 = acb->scsi_host;
#line 3620
  __cil_tmp19 = __cil_tmp18->this_id;
#line 3620
  __cil_tmp20 = (unsigned char )__cil_tmp19;
#line 3620
  __cil_tmp21 = acb->io_port_base;
#line 3620
  __cil_tmp22 = __cil_tmp21 + 135UL;
#line 3620
  __cil_tmp23 = (int )__cil_tmp22;
#line 3620
  outb(__cil_tmp20, __cil_tmp23);
#line 3622
  __cil_tmp24 = acb->io_port_base;
#line 3622
  __cil_tmp25 = __cil_tmp24 + 132UL;
#line 3622
  __cil_tmp26 = (int )__cil_tmp25;
#line 3622
  outb((unsigned char)0, __cil_tmp26);
#line 3624
  __cil_tmp27 = acb->io_port_base;
#line 3624
  __cil_tmp28 = __cil_tmp27 + 212UL;
#line 3624
  __cil_tmp29 = (int )__cil_tmp28;
#line 3624
  tmp___7 = inw(__cil_tmp29);
#line 3624
  __cil_tmp30 = (int )tmp___7;
#line 3624
  __cil_tmp31 = __cil_tmp30 & 127;
#line 3624
  wval = (u16 )__cil_tmp31;
#line 3625
  __cil_tmp32 = acb->io_port_base;
#line 3625
  __cil_tmp33 = __cil_tmp32 + 212UL;
#line 3625
  __cil_tmp34 = (int )__cil_tmp33;
#line 3625
  outw(wval, __cil_tmp34);
#line 3627
  __cil_tmp35 = acb->io_port_base;
#line 3627
  __cil_tmp36 = __cil_tmp35 + 166UL;
#line 3627
  __cil_tmp37 = (int )__cil_tmp36;
#line 3627
  tmp___8 = inw(__cil_tmp37);
#line 3627
  __cil_tmp38 = (int )tmp___8;
#line 3627
  __cil_tmp39 = __cil_tmp38 & -769;
#line 3627
  wval = (u16 )__cil_tmp39;
#line 3628
  __cil_tmp40 = (int )wval;
#line 3628
  __cil_tmp41 = __cil_tmp40 | 33280;
#line 3628
  wval = (u16 )__cil_tmp41;
#line 3630
  __cil_tmp42 = acb->io_port_base;
#line 3630
  __cil_tmp43 = __cil_tmp42 + 166UL;
#line 3630
  __cil_tmp44 = (int )__cil_tmp43;
#line 3630
  outw(wval, __cil_tmp44);
#line 3632
  __cil_tmp45 = acb->io_port_base;
#line 3632
  __cil_tmp46 = __cil_tmp45 + 132UL;
#line 3632
  __cil_tmp47 = (int )__cil_tmp46;
#line 3632
  inb(__cil_tmp47);
#line 3634
  __cil_tmp48 = acb->io_port_base;
#line 3634
  __cil_tmp49 = __cil_tmp48 + 140UL;
#line 3634
  __cil_tmp50 = (int )__cil_tmp49;
#line 3634
  outb((unsigned char)127, __cil_tmp50);
#line 3635
  __cil_tmp51 = acb->io_port_base;
#line 3635
  __cil_tmp52 = __cil_tmp51 + 164UL;
#line 3635
  __cil_tmp53 = (int )__cil_tmp52;
#line 3635
  outb((unsigned char)9, __cil_tmp53);
  }
#line 3638
  return;
}
}
#line 3641 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void scsi_reset_detect(struct AdapterCtlBlk *acb ) 
{ int tmp___7 ;
  struct timer_list *__cil_tmp3 ;
  struct timer_list  const  *__cil_tmp4 ;
  struct timer_list *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  struct Scsi_Host *__cil_tmp12 ;
  u8 __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long volatile   __cil_tmp16 ;
  unsigned long volatile   __cil_tmp17 ;
  unsigned long volatile   __cil_tmp18 ;
  unsigned long volatile   __cil_tmp19 ;
  char *__cil_tmp20 ;
  u8 __cil_tmp21 ;
  int __cil_tmp22 ;
  u8 __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  u8 __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  u8 __cil_tmp29 ;
  void *__cil_tmp30 ;
  struct scsi_cmnd *__cil_tmp31 ;
  u8 __cil_tmp32 ;
  void *__cil_tmp33 ;

  {
  {
#line 3643
  printk("<6>dc395x: scsi_reset_detect: acb=%p\n", acb);
#line 3645
  __cil_tmp3 = & acb->waiting_timer;
#line 3645
  __cil_tmp4 = (struct timer_list  const  *)__cil_tmp3;
#line 3645
  tmp___7 = timer_pending(__cil_tmp4);
  }
#line 3645
  if (tmp___7) {
    {
#line 3646
    __cil_tmp5 = & acb->waiting_timer;
#line 3646
    del_timer(__cil_tmp5);
    }
  } else {

  }
  {
#line 3648
  __cil_tmp6 = acb->io_port_base;
#line 3648
  __cil_tmp7 = __cil_tmp6 + 128UL;
#line 3648
  __cil_tmp8 = (int )__cil_tmp7;
#line 3648
  outb((unsigned char)16, __cil_tmp8);
#line 3649
  __cil_tmp9 = acb->io_port_base;
#line 3649
  __cil_tmp10 = __cil_tmp9 + 161UL;
#line 3649
  __cil_tmp11 = (int )__cil_tmp10;
#line 3649
  outb((unsigned char)16, __cil_tmp11);
#line 3651
  __const_udelay(2147500UL);
#line 3653
  __cil_tmp12 = acb->scsi_host;
#line 3653
  __cil_tmp13 = acb->eeprom.delay_time;
#line 3653
  __cil_tmp14 = (int )__cil_tmp13;
#line 3653
  __cil_tmp15 = 250 * __cil_tmp14;
#line 3653
  __cil_tmp16 = (unsigned long volatile   )__cil_tmp15;
#line 3653
  __cil_tmp17 = (unsigned long volatile   )625;
#line 3653
  __cil_tmp18 = jiffies + __cil_tmp17;
#line 3653
  __cil_tmp19 = __cil_tmp18 + __cil_tmp16;
#line 3653
  __cil_tmp12->last_reset = (unsigned long )__cil_tmp19;
#line 3657
  __cil_tmp20 = (char *)"scsi_reset_detect";
#line 3657
  clear_fifo(acb, __cil_tmp20);
#line 3658
  set_basic_config(acb);
  }
  {
#line 3662
  __cil_tmp21 = acb->acb_flag;
#line 3662
  __cil_tmp22 = (int )__cil_tmp21;
#line 3662
  if (__cil_tmp22 & 1) {
#line 3663
    __cil_tmp23 = acb->acb_flag;
#line 3663
    __cil_tmp24 = (int )__cil_tmp23;
#line 3663
    __cil_tmp25 = __cil_tmp24 | 4;
#line 3663
    acb->acb_flag = (u8 )__cil_tmp25;
  } else {
    {
#line 3665
    __cil_tmp26 = acb->acb_flag;
#line 3665
    __cil_tmp27 = (int )__cil_tmp26;
#line 3665
    __cil_tmp28 = __cil_tmp27 | 2;
#line 3665
    acb->acb_flag = (u8 )__cil_tmp28;
#line 3666
    reset_dev_param(acb);
#line 3667
    __cil_tmp29 = (u8 )8;
#line 3667
    __cil_tmp30 = (void *)0;
#line 3667
    __cil_tmp31 = (struct scsi_cmnd *)__cil_tmp30;
#line 3667
    __cil_tmp32 = (u8 )1;
#line 3667
    doing_srb_done(acb, __cil_tmp29, __cil_tmp31, __cil_tmp32);
#line 3669
    __cil_tmp33 = (void *)0;
#line 3669
    acb->active_dcb = (struct DeviceCtlBlk *)__cil_tmp33;
#line 3670
    acb->acb_flag = (u8 )0;
#line 3671
    waiting_process_next(acb);
    }
  }
  }
#line 3673
  return;
}
}
#line 3676 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void request_sense(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb , struct ScsiReqBlk *srb ) 
{ struct scsi_cmnd *cmd ;
  dma_addr_t tmp___7 ;
  u8 tmp___8 ;
  u8 __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned char *__cil_tmp10 ;
  void *__cil_tmp11 ;
  size_t __cil_tmp12 ;
  struct SGentry *__cil_tmp13 ;
  struct SGentry *__cil_tmp14 ;
  struct SGentry *__cil_tmp15 ;
  struct SGentry *__cil_tmp16 ;
  struct SGentry *__cil_tmp17 ;
  struct SGentry *__cil_tmp18 ;
  struct SGentry *__cil_tmp19 ;
  struct SGentry *__cil_tmp20 ;
  struct SGentry *__cil_tmp21 ;
  struct SGentry *__cil_tmp22 ;
  struct pci_dev *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  size_t __cil_tmp26 ;
  struct SGentry *__cil_tmp27 ;
  struct SGentry *__cil_tmp28 ;
  struct scsi_cmnd *__cil_tmp29 ;
  u8 __cil_tmp30 ;
  int __cil_tmp31 ;
  u8 __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 3679
  cmd = srb->cmd;
  {
#line 3680
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3680
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 3683
  __cil_tmp7 = srb->flag;
#line 3683
  __cil_tmp8 = (int )__cil_tmp7;
#line 3683
  __cil_tmp9 = __cil_tmp8 | 1;
#line 3683
  srb->flag = (u8 )__cil_tmp9;
#line 3684
  srb->adapter_status = (u8 )0;
#line 3685
  srb->target_status = (u8 )0;
#line 3688
  __cil_tmp10 = cmd->sense_buffer;
#line 3688
  __cil_tmp11 = (void *)__cil_tmp10;
#line 3688
  __cil_tmp12 = (size_t )96;
#line 3688
  memset(__cil_tmp11, 0, __cil_tmp12);
#line 3691
  __cil_tmp13 = srb->segment_x;
#line 3691
  __cil_tmp14 = __cil_tmp13 + 63;
#line 3691
  __cil_tmp15 = srb->segment_x;
#line 3691
  __cil_tmp16 = __cil_tmp15 + 0;
#line 3691
  __cil_tmp14->address = __cil_tmp16->address;
#line 3693
  __cil_tmp17 = srb->segment_x;
#line 3693
  __cil_tmp18 = __cil_tmp17 + 63;
#line 3693
  __cil_tmp19 = srb->segment_x;
#line 3693
  __cil_tmp20 = __cil_tmp19 + 0;
#line 3693
  __cil_tmp18->length = __cil_tmp20->length;
#line 3695
  srb->xferred = srb->total_xfer_length;
#line 3697
  srb->total_xfer_length = (size_t )96;
#line 3698
  __cil_tmp21 = srb->segment_x;
#line 3698
  __cil_tmp22 = __cil_tmp21 + 0;
#line 3698
  __cil_tmp22->length = (u32 )96;
#line 3700
  __cil_tmp23 = acb->dev;
#line 3700
  __cil_tmp24 = cmd->sense_buffer;
#line 3700
  __cil_tmp25 = (void *)__cil_tmp24;
#line 3700
  __cil_tmp26 = (size_t )96;
#line 3700
  tmp___7 = pci_map_single(__cil_tmp23, __cil_tmp25, __cil_tmp26, 2);
#line 3700
  __cil_tmp27 = srb->segment_x;
#line 3700
  __cil_tmp28 = __cil_tmp27 + 0;
#line 3700
  __cil_tmp28->address = (u32 )tmp___7;
  }
  {
#line 3703
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 3703
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 3706
  srb->sg_count = (u8 )1;
#line 3707
  srb->sg_index = (u8 )0;
#line 3709
  tmp___8 = start_scsi(acb, dcb, srb);
  }
#line 3709
  if (tmp___8) {
    {
#line 3710
    __cil_tmp29 = srb->cmd;
#line 3710
    __cil_tmp30 = dcb->target_id;
#line 3710
    __cil_tmp31 = (int )__cil_tmp30;
#line 3710
    __cil_tmp32 = dcb->target_lun;
#line 3710
    __cil_tmp33 = (int )__cil_tmp32;
#line 3710
    printk("<7>dc395x: request_sense: (0x%p) failed <%02i-%i>\n", __cil_tmp29, __cil_tmp31,
           __cil_tmp33);
#line 3713
    srb_going_to_waiting_move(dcb, srb);
#line 3714
    waiting_set_timer(acb, 2UL);
    }
  } else {

  }
#line 3716
  return;
}
}
#line 3732 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct DeviceCtlBlk *device_alloc(struct AdapterCtlBlk *acb , u8 target , u8 lun ) 
{ struct NvRamType *eeprom ;
  u8 period_index ;
  struct DeviceCtlBlk *dcb ;
  void *tmp___7 ;
  int tmp___8 ;
  struct DeviceCtlBlk *p ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u8 __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  struct list_head *__cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  void *__cil_tmp19 ;
  u8 __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  u8 __cil_tmp26 ;
  int __cil_tmp27 ;
  u8 __cil_tmp28 ;
  int __cil_tmp29 ;
  u8 __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  u8 __cil_tmp33 ;
  int __cil_tmp34 ;
  u8 __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  u8 __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  u8 __cil_tmp41 ;
  int __cil_tmp42 ;
  struct list_head *__cil_tmp43 ;
  struct DeviceCtlBlk *__cil_tmp44 ;
  struct list_head *__cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  struct list_head *__cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  struct list_head *__cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  u8 __cil_tmp53 ;
  int __cil_tmp54 ;
  u8 __cil_tmp55 ;
  int __cil_tmp56 ;
  struct list_head *__cil_tmp57 ;
  struct DeviceCtlBlk *__cil_tmp58 ;
  struct list_head *__cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 3735
  eeprom = & acb->eeprom;
#line 3736
  __cil_tmp12 = eeprom->target[target].period;
#line 3736
  __cil_tmp13 = (int )__cil_tmp12;
#line 3736
  __cil_tmp14 = __cil_tmp13 & 7;
#line 3736
  period_index = (u8 )__cil_tmp14;
#line 3739
  tmp___7 = kmalloc(88UL, 32U);
#line 3739
  dcb = (struct DeviceCtlBlk *)tmp___7;
  }
  {
#line 3740
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3740
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
#line 3741
  if (! dcb) {
    {
#line 3742
    __cil_tmp15 = (void *)0;
#line 3742
    return ((struct DeviceCtlBlk *)__cil_tmp15);
    }
  } else {

  }
  {
#line 3743
  __cil_tmp16 = (void *)0;
#line 3743
  dcb->acb = (struct AdapterCtlBlk *)__cil_tmp16;
#line 3744
  __cil_tmp17 = & dcb->srb_going_list;
#line 3744
  INIT_LIST_HEAD(__cil_tmp17);
#line 3745
  __cil_tmp18 = & dcb->srb_waiting_list;
#line 3745
  INIT_LIST_HEAD(__cil_tmp18);
#line 3746
  __cil_tmp19 = (void *)0;
#line 3746
  dcb->active_srb = (struct ScsiReqBlk *)__cil_tmp19;
#line 3747
  dcb->tag_mask = (u32 )0;
#line 3748
  dcb->max_command = (u16 )1;
#line 3749
  dcb->target_id = target;
#line 3750
  dcb->target_lun = lun;
  }
  {
#line 3752
  __cil_tmp20 = dcb->dev_mode;
#line 3752
  __cil_tmp21 = (int )__cil_tmp20;
#line 3752
  if (__cil_tmp21 & 4) {
#line 3752
    tmp___8 = 64;
  } else {
#line 3752
    tmp___8 = 0;
  }
  }
#line 3752
  __cil_tmp22 = (int )lun;
#line 3752
  __cil_tmp23 = __cil_tmp22 & 7;
#line 3752
  __cil_tmp24 = 128 | tmp___8;
#line 3752
  __cil_tmp25 = __cil_tmp24 | __cil_tmp23;
#line 3752
  dcb->identify_msg = (u8 )__cil_tmp25;
#line 3757
  dcb->dev_mode = eeprom->target[target].cfg0;
#line 3758
  dcb->inquiry7 = (u8 )0;
#line 3759
  dcb->sync_mode = (u8 )0;
#line 3760
  dcb->min_nego_period = clock_period[period_index];
#line 3761
  dcb->sync_period = (u8 )0;
#line 3762
  dcb->sync_offset = (u8 )0;
#line 3763
  dcb->flag = (u8 )0;
  {
#line 3766
  __cil_tmp26 = dcb->dev_mode;
#line 3766
  __cil_tmp27 = (int )__cil_tmp26;
#line 3766
  if (__cil_tmp27 & 32) {
    {
#line 3766
    __cil_tmp28 = acb->config;
#line 3766
    __cil_tmp29 = (int )__cil_tmp28;
#line 3766
    if (__cil_tmp29 & 32) {
#line 3768
      __cil_tmp30 = dcb->sync_mode;
#line 3768
      __cil_tmp31 = (int )__cil_tmp30;
#line 3768
      __cil_tmp32 = __cil_tmp31 | 4;
#line 3768
      dcb->sync_mode = (u8 )__cil_tmp32;
    } else {

    }
    }
  } else {

  }
  }
  {
#line 3771
  __cil_tmp33 = dcb->dev_mode;
#line 3771
  __cil_tmp34 = (int )__cil_tmp33;
#line 3771
  if (__cil_tmp34 & 2) {
#line 3772
    if (! lun) {
#line 3773
      __cil_tmp35 = dcb->sync_mode;
#line 3773
      __cil_tmp36 = (int )__cil_tmp35;
#line 3773
      __cil_tmp37 = __cil_tmp36 | 1;
#line 3773
      dcb->sync_mode = (u8 )__cil_tmp37;
    } else
#line 3772
    if (current_sync_offset) {
#line 3773
      __cil_tmp38 = dcb->sync_mode;
#line 3773
      __cil_tmp39 = (int )__cil_tmp38;
#line 3773
      __cil_tmp40 = __cil_tmp39 | 1;
#line 3773
      dcb->sync_mode = (u8 )__cil_tmp40;
    } else {

    }
  } else {

  }
  }
  {
#line 3775
  __cil_tmp41 = dcb->target_lun;
#line 3775
  __cil_tmp42 = (int )__cil_tmp41;
#line 3775
  if (__cil_tmp42 != 0) {
#line 3778
    __cil_tmp43 = acb->dcb_list.next;
#line 3778
    __mptr = (struct list_head  const  *)__cil_tmp43;
#line 3778
    __cil_tmp44 = (struct DeviceCtlBlk *)0;
#line 3778
    __cil_tmp45 = & __cil_tmp44->list;
#line 3778
    __cil_tmp46 = (unsigned int )__cil_tmp45;
#line 3778
    __cil_tmp47 = (char *)__mptr;
#line 3778
    __cil_tmp48 = __cil_tmp47 - __cil_tmp46;
#line 3778
    p = (struct DeviceCtlBlk *)__cil_tmp48;
    {
#line 3778
    while (1) {
      while_continue___0: /* CIL Label */ ;

      {
#line 3778
      __cil_tmp49 = & acb->dcb_list;
#line 3778
      __cil_tmp50 = (unsigned long )__cil_tmp49;
#line 3778
      __cil_tmp51 = & p->list;
#line 3778
      __cil_tmp52 = (unsigned long )__cil_tmp51;
#line 3778
      if (__cil_tmp52 != __cil_tmp50) {

      } else {
#line 3778
        goto while_break___0;
      }
      }
      {
#line 3779
      __cil_tmp53 = dcb->target_id;
#line 3779
      __cil_tmp54 = (int )__cil_tmp53;
#line 3779
      __cil_tmp55 = p->target_id;
#line 3779
      __cil_tmp56 = (int )__cil_tmp55;
#line 3779
      if (__cil_tmp56 == __cil_tmp54) {
#line 3780
        goto while_break___0;
      } else {

      }
      }
#line 3778
      __cil_tmp57 = p->list.next;
#line 3778
      __mptr___0 = (struct list_head  const  *)__cil_tmp57;
#line 3778
      __cil_tmp58 = (struct DeviceCtlBlk *)0;
#line 3778
      __cil_tmp59 = & __cil_tmp58->list;
#line 3778
      __cil_tmp60 = (unsigned int )__cil_tmp59;
#line 3778
      __cil_tmp61 = (char *)__mptr___0;
#line 3778
      __cil_tmp62 = __cil_tmp61 - __cil_tmp60;
#line 3778
      p = (struct DeviceCtlBlk *)__cil_tmp62;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: ;
    {
#line 3781
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 3781
      goto while_break___1;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
#line 3785
    dcb->sync_mode = p->sync_mode;
#line 3786
    dcb->sync_period = p->sync_period;
#line 3787
    dcb->min_nego_period = p->min_nego_period;
#line 3788
    dcb->sync_offset = p->sync_offset;
#line 3789
    dcb->inquiry7 = p->inquiry7;
  } else {

  }
  }
#line 3791
  return (dcb);
}
}
#line 3801 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_add_device(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb ) 
{ int tmp___7 ;
  struct list_head *__cil_tmp4 ;
  struct list_head  const  *__cil_tmp5 ;
  struct list_head *__cil_tmp6 ;
  struct list_head *__cil_tmp7 ;
  u8 __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  u8 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 3805
  dcb->acb = acb;
#line 3808
  __cil_tmp4 = & acb->dcb_list;
#line 3808
  __cil_tmp5 = (struct list_head  const  *)__cil_tmp4;
#line 3808
  tmp___7 = list_empty(__cil_tmp5);
  }
#line 3808
  if (tmp___7) {
#line 3809
    acb->dcb_run_robin = dcb;
  } else {

  }
  {
#line 3812
  __cil_tmp6 = & dcb->list;
#line 3812
  __cil_tmp7 = & acb->dcb_list;
#line 3812
  list_add_tail(__cil_tmp6, __cil_tmp7);
#line 3815
  __cil_tmp8 = dcb->target_lun;
#line 3815
  __cil_tmp9 = (int )__cil_tmp8;
#line 3815
  __cil_tmp10 = 1 << __cil_tmp9;
#line 3815
  __cil_tmp11 = acb->dcb_map[dcb->target_id];
#line 3815
  __cil_tmp12 = (int )__cil_tmp11;
#line 3815
  __cil_tmp13 = __cil_tmp12 | __cil_tmp10;
#line 3815
  acb->dcb_map[dcb->target_id] = (u8 )__cil_tmp13;
#line 3816
  acb->children[dcb->target_id][dcb->target_lun] = dcb;
  }
#line 3817
  return;
}
}
#line 3829 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_remove_device(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb ) 
{ struct DeviceCtlBlk *i ;
  struct DeviceCtlBlk *tmp___7 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  unsigned long __cil_tmp8 ;
  struct DeviceCtlBlk *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  struct DeviceCtlBlk *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  struct list_head *__cil_tmp16 ;
  struct DeviceCtlBlk *__cil_tmp17 ;
  struct list_head *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  struct list_head *__cil_tmp22 ;
  struct DeviceCtlBlk *__cil_tmp23 ;
  struct list_head *__cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  struct list_head *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  struct list_head *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  struct list_head *__cil_tmp34 ;
  struct list_head *__cil_tmp35 ;
  struct DeviceCtlBlk *__cil_tmp36 ;
  struct list_head *__cil_tmp37 ;
  unsigned int __cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  u8 __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  u8 __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;

  {
  {
#line 3834
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3834
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 3838
  __cil_tmp8 = (unsigned long )dcb;
#line 3838
  __cil_tmp9 = acb->active_dcb;
#line 3838
  __cil_tmp10 = (unsigned long )__cil_tmp9;
#line 3838
  if (__cil_tmp10 == __cil_tmp8) {
#line 3839
    __cil_tmp11 = (void *)0;
#line 3839
    acb->active_dcb = (struct DeviceCtlBlk *)__cil_tmp11;
  } else {

  }
  }
  {
#line 3840
  __cil_tmp12 = (unsigned long )dcb;
#line 3840
  __cil_tmp13 = acb->dcb_run_robin;
#line 3840
  __cil_tmp14 = (unsigned long )__cil_tmp13;
#line 3840
  if (__cil_tmp14 == __cil_tmp12) {
    {
#line 3841
    __cil_tmp15 = & acb->dcb_list;
#line 3841
    acb->dcb_run_robin = dcb_get_next(__cil_tmp15, dcb);
    }
  } else {

  }
  }
#line 3844
  __cil_tmp16 = acb->dcb_list.next;
#line 3844
  __mptr = (struct list_head  const  *)__cil_tmp16;
#line 3844
  __cil_tmp17 = (struct DeviceCtlBlk *)0;
#line 3844
  __cil_tmp18 = & __cil_tmp17->list;
#line 3844
  __cil_tmp19 = (unsigned int )__cil_tmp18;
#line 3844
  __cil_tmp20 = (char *)__mptr;
#line 3844
  __cil_tmp21 = __cil_tmp20 - __cil_tmp19;
#line 3844
  i = (struct DeviceCtlBlk *)__cil_tmp21;
#line 3844
  __cil_tmp22 = i->list.next;
#line 3844
  __mptr___0 = (struct list_head  const  *)__cil_tmp22;
#line 3844
  __cil_tmp23 = (struct DeviceCtlBlk *)0;
#line 3844
  __cil_tmp24 = & __cil_tmp23->list;
#line 3844
  __cil_tmp25 = (unsigned int )__cil_tmp24;
#line 3844
  __cil_tmp26 = (char *)__mptr___0;
#line 3844
  __cil_tmp27 = __cil_tmp26 - __cil_tmp25;
#line 3844
  tmp___7 = (struct DeviceCtlBlk *)__cil_tmp27;
  {
#line 3844
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 3844
    __cil_tmp28 = & acb->dcb_list;
#line 3844
    __cil_tmp29 = (unsigned long )__cil_tmp28;
#line 3844
    __cil_tmp30 = & i->list;
#line 3844
    __cil_tmp31 = (unsigned long )__cil_tmp30;
#line 3844
    if (__cil_tmp31 != __cil_tmp29) {

    } else {
#line 3844
      goto while_break___0;
    }
    }
    {
#line 3845
    __cil_tmp32 = (unsigned long )i;
#line 3845
    __cil_tmp33 = (unsigned long )dcb;
#line 3845
    if (__cil_tmp33 == __cil_tmp32) {
      {
#line 3846
      __cil_tmp34 = & i->list;
#line 3846
      list_del(__cil_tmp34);
      }
#line 3847
      goto while_break___0;
    } else {

    }
    }
#line 3844
    i = tmp___7;
#line 3844
    __cil_tmp35 = tmp___7->list.next;
#line 3844
    __mptr___1 = (struct list_head  const  *)__cil_tmp35;
#line 3844
    __cil_tmp36 = (struct DeviceCtlBlk *)0;
#line 3844
    __cil_tmp37 = & __cil_tmp36->list;
#line 3844
    __cil_tmp38 = (unsigned int )__cil_tmp37;
#line 3844
    __cil_tmp39 = (char *)__mptr___1;
#line 3844
    __cil_tmp40 = __cil_tmp39 - __cil_tmp38;
#line 3844
    tmp___7 = (struct DeviceCtlBlk *)__cil_tmp40;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
#line 3851
  __cil_tmp41 = dcb->target_lun;
#line 3851
  __cil_tmp42 = (int )__cil_tmp41;
#line 3851
  __cil_tmp43 = 1 << __cil_tmp42;
#line 3851
  __cil_tmp44 = ~ __cil_tmp43;
#line 3851
  __cil_tmp45 = acb->dcb_map[dcb->target_id];
#line 3851
  __cil_tmp46 = (int )__cil_tmp45;
#line 3851
  __cil_tmp47 = __cil_tmp46 & __cil_tmp44;
#line 3851
  acb->dcb_map[dcb->target_id] = (u8 )__cil_tmp47;
#line 3852
  __cil_tmp48 = (void *)0;
#line 3852
  acb->children[dcb->target_id][dcb->target_lun] = (struct DeviceCtlBlk *)__cil_tmp48;
#line 3853
  __cil_tmp49 = (void *)0;
#line 3853
  dcb->acb = (struct AdapterCtlBlk *)__cil_tmp49;
#line 3854
  return;
}
}
#line 3864 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_remove_and_free_device(struct AdapterCtlBlk *acb , struct DeviceCtlBlk *dcb ) 
{ unsigned int tmp___7 ;
  struct list_head *__cil_tmp4 ;
  void const   *__cil_tmp5 ;

  {
  {
#line 3867
  __cil_tmp4 = & dcb->srb_going_list;
#line 3867
  tmp___7 = list_size(__cil_tmp4);
  }
#line 3867
  if (tmp___7 > 1U) {
    {
#line 3868
    while (1) {
      while_continue: /* CIL Label */ ;

#line 3868
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
#line 3872
    return;
  } else {

  }
  {
#line 3874
  adapter_remove_device(acb, dcb);
#line 3875
  __cil_tmp5 = (void const   *)dcb;
#line 3875
  kfree(__cil_tmp5);
  }
#line 3876
  return;
}
}
#line 3885 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_remove_and_free_all_devices(struct AdapterCtlBlk *acb ) 
{ struct DeviceCtlBlk *dcb ;
  struct DeviceCtlBlk *tmp___7 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head *__cil_tmp7 ;
  struct DeviceCtlBlk *__cil_tmp8 ;
  struct list_head *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  struct list_head *__cil_tmp13 ;
  struct DeviceCtlBlk *__cil_tmp14 ;
  struct list_head *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  struct list_head *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  struct list_head *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  struct list_head *__cil_tmp23 ;
  struct DeviceCtlBlk *__cil_tmp24 ;
  struct list_head *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 3889
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3889
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 3892
  __cil_tmp7 = acb->dcb_list.next;
#line 3892
  __mptr = (struct list_head  const  *)__cil_tmp7;
#line 3892
  __cil_tmp8 = (struct DeviceCtlBlk *)0;
#line 3892
  __cil_tmp9 = & __cil_tmp8->list;
#line 3892
  __cil_tmp10 = (unsigned int )__cil_tmp9;
#line 3892
  __cil_tmp11 = (char *)__mptr;
#line 3892
  __cil_tmp12 = __cil_tmp11 - __cil_tmp10;
#line 3892
  dcb = (struct DeviceCtlBlk *)__cil_tmp12;
#line 3892
  __cil_tmp13 = dcb->list.next;
#line 3892
  __mptr___0 = (struct list_head  const  *)__cil_tmp13;
#line 3892
  __cil_tmp14 = (struct DeviceCtlBlk *)0;
#line 3892
  __cil_tmp15 = & __cil_tmp14->list;
#line 3892
  __cil_tmp16 = (unsigned int )__cil_tmp15;
#line 3892
  __cil_tmp17 = (char *)__mptr___0;
#line 3892
  __cil_tmp18 = __cil_tmp17 - __cil_tmp16;
#line 3892
  tmp___7 = (struct DeviceCtlBlk *)__cil_tmp18;
  {
#line 3892
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 3892
    __cil_tmp19 = & acb->dcb_list;
#line 3892
    __cil_tmp20 = (unsigned long )__cil_tmp19;
#line 3892
    __cil_tmp21 = & dcb->list;
#line 3892
    __cil_tmp22 = (unsigned long )__cil_tmp21;
#line 3892
    if (__cil_tmp22 != __cil_tmp20) {

    } else {
#line 3892
      goto while_break___0;
    }
    }
    {
#line 3893
    adapter_remove_and_free_device(acb, dcb);
#line 3892
    dcb = tmp___7;
#line 3892
    __cil_tmp23 = tmp___7->list.next;
#line 3892
    __mptr___1 = (struct list_head  const  *)__cil_tmp23;
#line 3892
    __cil_tmp24 = (struct DeviceCtlBlk *)0;
#line 3892
    __cil_tmp25 = & __cil_tmp24->list;
#line 3892
    __cil_tmp26 = (unsigned int )__cil_tmp25;
#line 3892
    __cil_tmp27 = (char *)__mptr___1;
#line 3892
    __cil_tmp28 = __cil_tmp27 - __cil_tmp26;
#line 3892
    tmp___7 = (struct DeviceCtlBlk *)__cil_tmp28;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 3894
  return;
}
}
#line 3904 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_slave_alloc(struct scsi_device *scsi_device ) 
{ struct AdapterCtlBlk *acb ;
  struct DeviceCtlBlk *dcb ;
  struct Scsi_Host *__cil_tmp4 ;
  unsigned long *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  u8 __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  u8 __cil_tmp9 ;

  {
  {
#line 3906
  __cil_tmp4 = scsi_device->host;
#line 3906
  __cil_tmp5 = & __cil_tmp4->hostdata[0];
#line 3906
  acb = (struct AdapterCtlBlk *)__cil_tmp5;
#line 3909
  __cil_tmp6 = scsi_device->id;
#line 3909
  __cil_tmp7 = (u8 )__cil_tmp6;
#line 3909
  __cil_tmp8 = scsi_device->lun;
#line 3909
  __cil_tmp9 = (u8 )__cil_tmp8;
#line 3909
  dcb = device_alloc(acb, __cil_tmp7, __cil_tmp9);
  }
#line 3910
  if (! dcb) {
#line 3911
    return (-12);
  } else {

  }
  {
#line 3912
  adapter_add_device(acb, dcb);
  }
#line 3914
  return (0);
}
}
#line 3924 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void dc395x_slave_destroy(struct scsi_device *scsi_device ) 
{ struct AdapterCtlBlk *acb ;
  struct DeviceCtlBlk *dcb ;
  struct DeviceCtlBlk *tmp___7 ;
  struct Scsi_Host *__cil_tmp5 ;
  unsigned long *__cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  u8 __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  u8 __cil_tmp10 ;

  {
  {
#line 3926
  __cil_tmp5 = scsi_device->host;
#line 3926
  __cil_tmp6 = & __cil_tmp5->hostdata[0];
#line 3926
  acb = (struct AdapterCtlBlk *)__cil_tmp6;
#line 3927
  __cil_tmp7 = scsi_device->id;
#line 3927
  __cil_tmp8 = (u8 )__cil_tmp7;
#line 3927
  __cil_tmp9 = scsi_device->lun;
#line 3927
  __cil_tmp10 = (u8 )__cil_tmp9;
#line 3927
  tmp___7 = find_dcb(acb, __cil_tmp8, __cil_tmp10);
#line 3927
  dcb = tmp___7;
  }
#line 3928
  if (dcb) {
    {
#line 3929
    adapter_remove_and_free_device(acb, dcb);
    }
  } else {

  }
#line 3930
  return;
}
}
#line 3942
static void trms1040_wait_30us(unsigned long io_port )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 3942
static void trms1040_wait_30us(unsigned long io_port )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 3942 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void trms1040_wait_30us(unsigned long io_port ) 
{ unsigned char tmp___7 ;
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 3945
  __cil_tmp3 = io_port + 219UL;
#line 3945
  __cil_tmp4 = (int )__cil_tmp3;
#line 3945
  outb((unsigned char)5, __cil_tmp4);
  }
  {
#line 3946
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3946
    __cil_tmp5 = io_port + 213UL;
#line 3946
    __cil_tmp6 = (int )__cil_tmp5;
#line 3946
    tmp___7 = inb(__cil_tmp6);
    }
    {
#line 3946
    __cil_tmp7 = (int )tmp___7;
#line 3946
    if (__cil_tmp7 & 128) {
#line 3946
      goto while_break;
    } else {

    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 3948
  return;
}
}
#line 3959
static void trms1040_write_cmd(unsigned long io_port , u8 cmd , u8 addr )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 3959
static void trms1040_write_cmd(unsigned long io_port , u8 cmd , u8 addr )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 3959 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void trms1040_write_cmd(unsigned long io_port , u8 cmd , u8 addr ) 
{ int i ;
  u8 send_data ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned char __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;

  {
#line 3965
  i = 0;
  {
#line 3965
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3965
    if (i < 3) {

    } else {
#line 3965
      goto while_break;
    }
#line 3966
    send_data = (u8 )1;
    {
#line 3967
    __cil_tmp6 = (int )cmd;
#line 3967
    if (__cil_tmp6 & 4) {
#line 3968
      __cil_tmp7 = (int )send_data;
#line 3968
      __cil_tmp8 = __cil_tmp7 | 8;
#line 3968
      send_data = (u8 )__cil_tmp8;
    } else {

    }
    }
    {
#line 3970
    __cil_tmp9 = io_port + 214UL;
#line 3970
    __cil_tmp10 = (int )__cil_tmp9;
#line 3970
    outb(send_data, __cil_tmp10);
#line 3971
    trms1040_wait_30us(io_port);
#line 3972
    __cil_tmp11 = (int )send_data;
#line 3972
    __cil_tmp12 = __cil_tmp11 | 2;
#line 3972
    __cil_tmp13 = (unsigned char )__cil_tmp12;
#line 3972
    __cil_tmp14 = io_port + 214UL;
#line 3972
    __cil_tmp15 = (int )__cil_tmp14;
#line 3972
    outb(__cil_tmp13, __cil_tmp15);
#line 3974
    trms1040_wait_30us(io_port);
#line 3965
    i = i + 1;
#line 3965
    __cil_tmp16 = (int )cmd;
#line 3965
    __cil_tmp17 = __cil_tmp16 << 1;
#line 3965
    cmd = (u8 )__cil_tmp17;
    }
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 3978
  i = 0;
  {
#line 3978
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 3978
    if (i < 7) {

    } else {
#line 3978
      goto while_break___0;
    }
#line 3979
    send_data = (u8 )1;
    {
#line 3980
    __cil_tmp18 = (int )addr;
#line 3980
    if (__cil_tmp18 & 64) {
#line 3981
      __cil_tmp19 = (int )send_data;
#line 3981
      __cil_tmp20 = __cil_tmp19 | 8;
#line 3981
      send_data = (u8 )__cil_tmp20;
    } else {

    }
    }
    {
#line 3983
    __cil_tmp21 = io_port + 214UL;
#line 3983
    __cil_tmp22 = (int )__cil_tmp21;
#line 3983
    outb(send_data, __cil_tmp22);
#line 3984
    trms1040_wait_30us(io_port);
#line 3985
    __cil_tmp23 = (int )send_data;
#line 3985
    __cil_tmp24 = __cil_tmp23 | 2;
#line 3985
    __cil_tmp25 = (unsigned char )__cil_tmp24;
#line 3985
    __cil_tmp26 = io_port + 214UL;
#line 3985
    __cil_tmp27 = (int )__cil_tmp26;
#line 3985
    outb(__cil_tmp25, __cil_tmp27);
#line 3987
    trms1040_wait_30us(io_port);
#line 3978
    i = i + 1;
#line 3978
    __cil_tmp28 = (int )addr;
#line 3978
    __cil_tmp29 = __cil_tmp28 << 1;
#line 3978
    addr = (u8 )__cil_tmp29;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 3989
  __cil_tmp30 = io_port + 214UL;
#line 3989
  __cil_tmp31 = (int )__cil_tmp30;
#line 3989
  outb((unsigned char)1, __cil_tmp31);
#line 3990
  trms1040_wait_30us(io_port);
  }
#line 3991
  return;
}
}
#line 4004
static void trms1040_set_data(unsigned long io_port , u8 addr , u8 byte )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4004
static void trms1040_set_data(unsigned long io_port , u8 addr , u8 byte )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4004 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void trms1040_set_data(unsigned long io_port , u8 addr , u8 byte ) 
{ int i ;
  u8 send_data ;
  unsigned char tmp___7 ;
  u8 __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;

  {
  {
#line 4010
  __cil_tmp7 = (u8 )5;
#line 4010
  trms1040_write_cmd(io_port, __cil_tmp7, addr);
#line 4013
  i = 0;
  }
  {
#line 4013
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4013
    if (i < 8) {

    } else {
#line 4013
      goto while_break;
    }
#line 4014
    send_data = (u8 )1;
    {
#line 4015
    __cil_tmp8 = (int )byte;
#line 4015
    if (__cil_tmp8 & 128) {
#line 4016
      __cil_tmp9 = (int )send_data;
#line 4016
      __cil_tmp10 = __cil_tmp9 | 8;
#line 4016
      send_data = (u8 )__cil_tmp10;
    } else {

    }
    }
    {
#line 4018
    __cil_tmp11 = io_port + 214UL;
#line 4018
    __cil_tmp12 = (int )__cil_tmp11;
#line 4018
    outb(send_data, __cil_tmp12);
#line 4019
    trms1040_wait_30us(io_port);
#line 4020
    __cil_tmp13 = (int )send_data;
#line 4020
    __cil_tmp14 = __cil_tmp13 | 2;
#line 4020
    __cil_tmp15 = (unsigned char )__cil_tmp14;
#line 4020
    __cil_tmp16 = io_port + 214UL;
#line 4020
    __cil_tmp17 = (int )__cil_tmp16;
#line 4020
    outb(__cil_tmp15, __cil_tmp17);
#line 4021
    trms1040_wait_30us(io_port);
#line 4013
    i = i + 1;
#line 4013
    __cil_tmp18 = (int )byte;
#line 4013
    __cil_tmp19 = __cil_tmp18 << 1;
#line 4013
    byte = (u8 )__cil_tmp19;
    }
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4023
  __cil_tmp20 = io_port + 214UL;
#line 4023
  __cil_tmp21 = (int )__cil_tmp20;
#line 4023
  outb((unsigned char)1, __cil_tmp21);
#line 4024
  trms1040_wait_30us(io_port);
#line 4027
  __cil_tmp22 = io_port + 214UL;
#line 4027
  __cil_tmp23 = (int )__cil_tmp22;
#line 4027
  outb((unsigned char)0, __cil_tmp23);
#line 4028
  trms1040_wait_30us(io_port);
#line 4030
  __cil_tmp24 = io_port + 214UL;
#line 4030
  __cil_tmp25 = (int )__cil_tmp24;
#line 4030
  outb((unsigned char)1, __cil_tmp25);
#line 4031
  trms1040_wait_30us(io_port);
  }
  {
#line 4034
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 4035
    __cil_tmp26 = io_port + 214UL;
#line 4035
    __cil_tmp27 = (int )__cil_tmp26;
#line 4035
    outb((unsigned char)3, __cil_tmp27);
#line 4036
    trms1040_wait_30us(io_port);
#line 4038
    __cil_tmp28 = io_port + 214UL;
#line 4038
    __cil_tmp29 = (int )__cil_tmp28;
#line 4038
    outb((unsigned char)1, __cil_tmp29);
#line 4039
    trms1040_wait_30us(io_port);
#line 4041
    __cil_tmp30 = io_port + 214UL;
#line 4041
    __cil_tmp31 = (int )__cil_tmp30;
#line 4041
    tmp___7 = inb(__cil_tmp31);
    }
    {
#line 4041
    __cil_tmp32 = (int )tmp___7;
#line 4041
    if (__cil_tmp32 & 4) {
#line 4042
      goto while_break___0;
    } else {

    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 4046
  __cil_tmp33 = io_port + 214UL;
#line 4046
  __cil_tmp34 = (int )__cil_tmp33;
#line 4046
  outb((unsigned char)0, __cil_tmp34);
  }
#line 4047
  return;
}
}
#line 4058
static void trms1040_write_all(struct NvRamType *eeprom , unsigned long io_port )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4058
static void trms1040_write_all(struct NvRamType *eeprom , unsigned long io_port )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4058 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void trms1040_write_all(struct NvRamType *eeprom , unsigned long io_port ) 
{ u8 *b_eeprom ;
  u8 addr ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  u8 __cil_tmp14 ;
  u8 __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  u8 __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  u8 __cil_tmp22 ;
  u8 __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned char __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 4060
  b_eeprom = (u8 *)eeprom;
#line 4064
  __cil_tmp7 = io_port + 212UL;
#line 4064
  __cil_tmp8 = (int )__cil_tmp7;
#line 4064
  tmp___7 = inb(__cil_tmp8);
#line 4064
  __cil_tmp9 = (int )tmp___7;
#line 4064
  __cil_tmp10 = __cil_tmp9 | 16;
#line 4064
  __cil_tmp11 = (unsigned char )__cil_tmp10;
#line 4064
  __cil_tmp12 = io_port + 212UL;
#line 4064
  __cil_tmp13 = (int )__cil_tmp12;
#line 4064
  outb(__cil_tmp11, __cil_tmp13);
#line 4068
  __cil_tmp14 = (u8 )4;
#line 4068
  __cil_tmp15 = (u8 )255;
#line 4068
  trms1040_write_cmd(io_port, __cil_tmp14, __cil_tmp15);
#line 4069
  __cil_tmp16 = io_port + 214UL;
#line 4069
  __cil_tmp17 = (int )__cil_tmp16;
#line 4069
  outb((unsigned char)0, __cil_tmp17);
#line 4070
  trms1040_wait_30us(io_port);
#line 4073
  addr = (u8 )0;
  }
  {
#line 4073
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 4073
    __cil_tmp18 = (int )addr;
#line 4073
    if (__cil_tmp18 < 128) {

    } else {
#line 4073
      goto while_break;
    }
    }
    {
#line 4074
    __cil_tmp19 = *b_eeprom;
#line 4074
    trms1040_set_data(io_port, addr, __cil_tmp19);
#line 4073
    __cil_tmp20 = (int )addr;
#line 4073
    __cil_tmp21 = __cil_tmp20 + 1;
#line 4073
    addr = (u8 )__cil_tmp21;
#line 4073
    b_eeprom = b_eeprom + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4077
  __cil_tmp22 = (u8 )4;
#line 4077
  __cil_tmp23 = (u8 )0;
#line 4077
  trms1040_write_cmd(io_port, __cil_tmp22, __cil_tmp23);
#line 4078
  __cil_tmp24 = io_port + 214UL;
#line 4078
  __cil_tmp25 = (int )__cil_tmp24;
#line 4078
  outb((unsigned char)0, __cil_tmp25);
#line 4079
  trms1040_wait_30us(io_port);
#line 4082
  __cil_tmp26 = io_port + 212UL;
#line 4082
  __cil_tmp27 = (int )__cil_tmp26;
#line 4082
  tmp___8 = inb(__cil_tmp27);
#line 4082
  __cil_tmp28 = (int )tmp___8;
#line 4082
  __cil_tmp29 = __cil_tmp28 & -17;
#line 4082
  __cil_tmp30 = (unsigned char )__cil_tmp29;
#line 4082
  __cil_tmp31 = io_port + 212UL;
#line 4082
  __cil_tmp32 = (int )__cil_tmp31;
#line 4082
  outb(__cil_tmp30, __cil_tmp32);
  }
#line 4084
  return;
}
}
#line 4098
static u8 trms1040_get_data(unsigned long io_port , u8 addr )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4098
static u8 trms1040_get_data(unsigned long io_port , u8 addr )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4098 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static u8 trms1040_get_data(unsigned long io_port , u8 addr ) 
{ int i ;
  u8 read_byte ;
  u8 result ;
  u8 __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 4102
  result = (u8 )0;
#line 4105
  __cil_tmp6 = (u8 )6;
#line 4105
  trms1040_write_cmd(io_port, __cil_tmp6, addr);
#line 4108
  i = 0;
  }
  {
#line 4108
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4108
    if (i < 8) {

    } else {
#line 4108
      goto while_break;
    }
    {
#line 4109
    __cil_tmp7 = io_port + 214UL;
#line 4109
    __cil_tmp8 = (int )__cil_tmp7;
#line 4109
    outb((unsigned char)3, __cil_tmp8);
#line 4110
    trms1040_wait_30us(io_port);
#line 4111
    __cil_tmp9 = io_port + 214UL;
#line 4111
    __cil_tmp10 = (int )__cil_tmp9;
#line 4111
    outb((unsigned char)1, __cil_tmp10);
#line 4114
    __cil_tmp11 = io_port + 214UL;
#line 4114
    __cil_tmp12 = (int )__cil_tmp11;
#line 4114
    read_byte = inb(__cil_tmp12);
#line 4115
    __cil_tmp13 = (int )result;
#line 4115
    __cil_tmp14 = __cil_tmp13 << 1;
#line 4115
    result = (u8 )__cil_tmp14;
    }
    {
#line 4116
    __cil_tmp15 = (int )read_byte;
#line 4116
    if (__cil_tmp15 & 4) {
#line 4117
      __cil_tmp16 = (int )result;
#line 4117
      __cil_tmp17 = __cil_tmp16 | 1;
#line 4117
      result = (u8 )__cil_tmp17;
    } else {

    }
    }
    {
#line 4119
    trms1040_wait_30us(io_port);
#line 4108
    i = i + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4123
  __cil_tmp18 = io_port + 214UL;
#line 4123
  __cil_tmp19 = (int )__cil_tmp18;
#line 4123
  outb((unsigned char)0, __cil_tmp19);
  }
#line 4124
  return (result);
}
}
#line 4136
static void trms1040_read_all(struct NvRamType *eeprom , unsigned long io_port )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4136
static void trms1040_read_all(struct NvRamType *eeprom , unsigned long io_port )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4136 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void trms1040_read_all(struct NvRamType *eeprom , unsigned long io_port ) 
{ u8 *b_eeprom ;
  u8 addr ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  unsigned char __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;

  {
  {
#line 4138
  b_eeprom = (u8 *)eeprom;
#line 4142
  __cil_tmp7 = io_port + 212UL;
#line 4142
  __cil_tmp8 = (int )__cil_tmp7;
#line 4142
  tmp___7 = inb(__cil_tmp8);
#line 4142
  __cil_tmp9 = (int )tmp___7;
#line 4142
  __cil_tmp10 = __cil_tmp9 | 16;
#line 4142
  __cil_tmp11 = (unsigned char )__cil_tmp10;
#line 4142
  __cil_tmp12 = io_port + 212UL;
#line 4142
  __cil_tmp13 = (int )__cil_tmp12;
#line 4142
  outb(__cil_tmp11, __cil_tmp13);
#line 4146
  addr = (u8 )0;
  }
  {
#line 4146
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 4146
    __cil_tmp14 = (int )addr;
#line 4146
    if (__cil_tmp14 < 128) {

    } else {
#line 4146
      goto while_break;
    }
    }
    {
#line 4147
    *b_eeprom = trms1040_get_data(io_port, addr);
#line 4146
    __cil_tmp15 = (int )addr;
#line 4146
    __cil_tmp16 = __cil_tmp15 + 1;
#line 4146
    addr = (u8 )__cil_tmp16;
#line 4146
    b_eeprom = b_eeprom + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4150
  __cil_tmp17 = io_port + 212UL;
#line 4150
  __cil_tmp18 = (int )__cil_tmp17;
#line 4150
  tmp___8 = inb(__cil_tmp18);
#line 4150
  __cil_tmp19 = (int )tmp___8;
#line 4150
  __cil_tmp20 = __cil_tmp19 & -17;
#line 4150
  __cil_tmp21 = (unsigned char )__cil_tmp20;
#line 4150
  __cil_tmp22 = io_port + 212UL;
#line 4150
  __cil_tmp23 = (int )__cil_tmp22;
#line 4150
  outb(__cil_tmp21, __cil_tmp23);
  }
#line 4152
  return;
}
}
#line 4166
static void check_eeprom(struct NvRamType *eeprom , unsigned long io_port )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4166
static void check_eeprom(struct NvRamType *eeprom , unsigned long io_port )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4166 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void check_eeprom(struct NvRamType *eeprom , unsigned long io_port ) 
{ u16 *w_eeprom ;
  u16 w_addr ;
  u16 cksum ;
  u32 d_addr ;
  u32 *d_eeprom ;
  u32 *tmp___7 ;
  u32 *tmp___8 ;
  int __cil_tmp10 ;
  u16 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  struct NVRamTarget *__cil_tmp22 ;
  int __cil_tmp23 ;
  u16 __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;

  {
  {
#line 4168
  w_eeprom = (u16 *)eeprom;
#line 4174
  trms1040_read_all(eeprom, io_port);
#line 4176
  cksum = (u16 )0;
#line 4177
  w_addr = (u16 )0;
#line 4177
  w_eeprom = (u16 *)eeprom;
  }
  {
#line 4177
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 4177
    __cil_tmp10 = (int )w_addr;
#line 4177
    if (__cil_tmp10 < 64) {

    } else {
#line 4177
      goto while_break;
    }
    }
#line 4179
    __cil_tmp11 = *w_eeprom;
#line 4179
    __cil_tmp12 = (int )__cil_tmp11;
#line 4179
    __cil_tmp13 = (int )cksum;
#line 4179
    __cil_tmp14 = __cil_tmp13 + __cil_tmp12;
#line 4179
    cksum = (u16 )__cil_tmp14;
#line 4177
    __cil_tmp15 = (int )w_addr;
#line 4177
    __cil_tmp16 = __cil_tmp15 + 1;
#line 4177
    w_addr = (u16 )__cil_tmp16;
#line 4177
    w_eeprom = w_eeprom + 1;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 4180
  __cil_tmp17 = (int )cksum;
#line 4180
  if (__cil_tmp17 != 4660) {
    {
#line 4185
    printk("<4>dc395x: EEProm checksum error: using default values and options.\n");
#line 4187
    eeprom->sub_vendor_id[0] = (u8 )7649;
#line 4188
    __cil_tmp18 = 7649 >> 8;
#line 4188
    eeprom->sub_vendor_id[1] = (u8 )__cil_tmp18;
#line 4189
    eeprom->sub_sys_id[0] = (u8 )913;
#line 4190
    __cil_tmp19 = 913 >> 8;
#line 4190
    eeprom->sub_sys_id[1] = (u8 )__cil_tmp19;
#line 4192
    eeprom->sub_class = (u8 )0;
#line 4193
    eeprom->vendor_id[0] = (u8 )7649;
#line 4194
    __cil_tmp20 = 7649 >> 8;
#line 4194
    eeprom->vendor_id[1] = (u8 )__cil_tmp20;
#line 4195
    eeprom->device_id[0] = (u8 )913;
#line 4196
    __cil_tmp21 = 913 >> 8;
#line 4196
    eeprom->device_id[1] = (u8 )__cil_tmp21;
#line 4198
    eeprom->reserved = (u8 )0;
#line 4200
    d_addr = (u32 )0;
#line 4200
    __cil_tmp22 = & eeprom->target[0];
#line 4200
    d_eeprom = (u32 *)__cil_tmp22;
    }
    {
#line 4200
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 4200
      if (d_addr < 16U) {

      } else {
#line 4200
        goto while_break___0;
      }
#line 4202
      *d_eeprom = (u32 )119;
#line 4200
      d_addr = d_addr + 1U;
#line 4200
      d_eeprom = d_eeprom + 1;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___0: 
#line 4204
    tmp___7 = d_eeprom;
#line 4204
    d_eeprom = d_eeprom + 1;
#line 4204
    *tmp___7 = (u32 )67112711;
#line 4205
    tmp___8 = d_eeprom;
#line 4205
    d_eeprom = d_eeprom + 1;
#line 4205
    *tmp___8 = (u32 )21;
#line 4206
    d_addr = (u32 )0;
    {
#line 4206
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 4206
      if (d_addr < 12U) {

      } else {
#line 4206
        goto while_break___1;
      }
#line 4207
      *d_eeprom = (u32 )0;
#line 4206
      d_addr = d_addr + 1U;
#line 4206
      d_eeprom = d_eeprom + 1;
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break___1: 
    {
#line 4210
    set_safe_settings();
#line 4211
    fix_settings();
#line 4212
    eeprom_override(eeprom);
#line 4214
    eeprom->cksum = (u16 )0;
#line 4215
    w_addr = (u16 )0;
#line 4215
    cksum = (u16 )0;
#line 4215
    w_eeprom = (u16 *)eeprom;
    }
    {
#line 4215
    while (1) {
      while_continue___2: /* CIL Label */ ;

      {
#line 4215
      __cil_tmp23 = (int )w_addr;
#line 4215
      if (__cil_tmp23 < 63) {

      } else {
#line 4215
        goto while_break___2;
      }
      }
#line 4217
      __cil_tmp24 = *w_eeprom;
#line 4217
      __cil_tmp25 = (int )__cil_tmp24;
#line 4217
      __cil_tmp26 = (int )cksum;
#line 4217
      __cil_tmp27 = __cil_tmp26 + __cil_tmp25;
#line 4217
      cksum = (u16 )__cil_tmp27;
#line 4215
      __cil_tmp28 = (int )w_addr;
#line 4215
      __cil_tmp29 = __cil_tmp28 + 1;
#line 4215
      w_addr = (u16 )__cil_tmp29;
#line 4215
      w_eeprom = w_eeprom + 1;
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___2: 
    {
#line 4219
    __cil_tmp30 = (int )cksum;
#line 4219
    __cil_tmp31 = 4660 - __cil_tmp30;
#line 4219
    *w_eeprom = (u16 )__cil_tmp31;
#line 4220
    trms1040_write_all(eeprom, io_port);
#line 4221
    eeprom->delay_time = (u8 )cfg_data[5].value;
    }
  } else {
    {
#line 4223
    set_safe_settings();
#line 4224
    eeprom_index_to_delay(eeprom);
#line 4225
    eeprom_override(eeprom);
    }
  }
  }
#line 4227
  return;
}
}
#line 4236
static void print_eeprom_settings(struct NvRamType *eeprom )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4236
static void print_eeprom_settings(struct NvRamType *eeprom )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4236 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void print_eeprom_settings(struct NvRamType *eeprom ) 
{ u8 __cil_tmp2 ;
  int __cil_tmp3 ;
  u8 __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  u8 __cil_tmp10 ;
  int __cil_tmp11 ;
  u8 __cil_tmp12 ;
  int __cil_tmp13 ;
  u8 __cil_tmp14 ;
  int __cil_tmp15 ;
  u8 __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  u8 __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 4238
  __cil_tmp2 = eeprom->scsi_id;
#line 4238
  __cil_tmp3 = (int )__cil_tmp2;
#line 4238
  __cil_tmp4 = eeprom->target[0].period;
#line 4238
  __cil_tmp5 = (int )__cil_tmp4;
#line 4238
  __cil_tmp6 = (int )clock_speed[eeprom->target[0].period];
#line 4238
  __cil_tmp7 = __cil_tmp6 / 10;
#line 4238
  __cil_tmp8 = (int )clock_speed[eeprom->target[0].period];
#line 4238
  __cil_tmp9 = __cil_tmp8 % 10;
#line 4238
  __cil_tmp10 = eeprom->target[0].cfg0;
#line 4238
  __cil_tmp11 = (int )__cil_tmp10;
#line 4238
  printk("<6>dc395x: Used settings: AdapterID=%02i, Speed=%i(%02i.%01iMHz), dev_mode=0x%02x\n",
         __cil_tmp3, __cil_tmp5, __cil_tmp7, __cil_tmp9, __cil_tmp11);
#line 4244
  __cil_tmp12 = eeprom->channel_cfg;
#line 4244
  __cil_tmp13 = (int )__cil_tmp12;
#line 4244
  __cil_tmp14 = eeprom->max_tag;
#line 4244
  __cil_tmp15 = (int )__cil_tmp14;
#line 4244
  __cil_tmp16 = eeprom->max_tag;
#line 4244
  __cil_tmp17 = (int )__cil_tmp16;
#line 4244
  __cil_tmp18 = 1 << __cil_tmp17;
#line 4244
  __cil_tmp19 = eeprom->delay_time;
#line 4244
  __cil_tmp20 = (int )__cil_tmp19;
#line 4244
  printk("<6>dc395x:                AdaptMode=0x%02x, Tags=%i(%02i), DelayReset=%is\n",
         __cil_tmp13, __cil_tmp15, __cil_tmp18, __cil_tmp20);
  }
#line 4247
  return;
}
}
#line 4251 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_sg_tables_free(struct AdapterCtlBlk *acb ) 
{ int i ;
  unsigned int srbs_per_page ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct SGentry *__cil_tmp7 ;
  void const   *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;

  {
#line 4254
  __cil_tmp4 = 8UL * 64UL;
#line 4254
  __cil_tmp5 = 1UL << 12;
#line 4254
  __cil_tmp6 = __cil_tmp5 / __cil_tmp4;
#line 4254
  srbs_per_page = (unsigned int )__cil_tmp6;
#line 4256
  i = 0;
  {
#line 4256
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4256
    if (i < 63) {

    } else {
#line 4256
      goto while_break;
    }
    {
#line 4257
    __cil_tmp7 = acb->srb_array[i].segment_x;
#line 4257
    __cil_tmp8 = (void const   *)__cil_tmp7;
#line 4257
    kfree(__cil_tmp8);
#line 4256
    __cil_tmp9 = (unsigned int )i;
#line 4256
    __cil_tmp10 = __cil_tmp9 + srbs_per_page;
#line 4256
    i = (int )__cil_tmp10;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 4258
  return;
}
}
#line 4264
static int adapter_sg_tables_alloc(struct AdapterCtlBlk *acb )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4264
static int adapter_sg_tables_alloc(struct AdapterCtlBlk *acb )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4264 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int adapter_sg_tables_alloc(struct AdapterCtlBlk *acb ) 
{ unsigned int mem_needed ;
  int pages ;
  unsigned int srbs_per_page ;
  int srb_idx ;
  unsigned int i ;
  struct SGentry *ptr ;
  void *tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;

  {
#line 4266
  __cil_tmp12 = 8UL * 64UL;
#line 4266
  __cil_tmp13 = 64UL * __cil_tmp12;
#line 4266
  mem_needed = (unsigned int )__cil_tmp13;
#line 4268
  __cil_tmp14 = 1UL << 12;
#line 4268
  __cil_tmp15 = 1UL << 12;
#line 4268
  __cil_tmp16 = __cil_tmp15 - 1UL;
#line 4268
  __cil_tmp17 = (unsigned long )mem_needed;
#line 4268
  __cil_tmp18 = __cil_tmp17 + __cil_tmp16;
#line 4268
  __cil_tmp19 = __cil_tmp18 / __cil_tmp14;
#line 4268
  pages = (int )__cil_tmp19;
#line 4269
  __cil_tmp20 = 8UL * 64UL;
#line 4269
  __cil_tmp21 = 1UL << 12;
#line 4269
  __cil_tmp22 = __cil_tmp21 / __cil_tmp20;
#line 4269
  srbs_per_page = (unsigned int )__cil_tmp22;
#line 4270
  srb_idx = 0;
#line 4271
  i = 0U;
#line 4272
  ptr = ptr;
#line 4274
  i = 0U;
  {
#line 4274
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4274
    if (i < 63U) {

    } else {
#line 4274
      goto while_break;
    }
#line 4275
    __cil_tmp23 = (void *)0;
#line 4275
    acb->srb_array[i].segment_x = (struct SGentry *)__cil_tmp23;
#line 4274
    i = i + 1U;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 4277
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 4277
    goto while_break___0;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break___0: ;
  {
#line 4278
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4278
    tmp___10 = pages;
#line 4278
    pages = pages - 1;
#line 4278
    if (tmp___10) {

    } else {
#line 4278
      goto while_break___1;
    }
    {
#line 4279
    __cil_tmp24 = 1UL << 12;
#line 4279
    tmp___7 = kmalloc(__cil_tmp24, 208U);
#line 4279
    ptr = (struct SGentry *)tmp___7;
    }
#line 4280
    if (! ptr) {
      {
#line 4281
      adapter_sg_tables_free(acb);
      }
#line 4282
      return (1);
    } else {

    }
    {
#line 4284
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 4284
      goto while_break___2;
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break___2: 
#line 4286
    i = 0U;
    {
#line 4287
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 4287
      if (i < srbs_per_page) {
#line 4287
        if (srb_idx < 63) {

        } else {
#line 4287
          goto while_break___3;
        }
      } else {
#line 4287
        goto while_break___3;
      }
#line 4288
      tmp___8 = srb_idx;
#line 4288
      srb_idx = srb_idx + 1;
#line 4288
      tmp___9 = i;
#line 4288
      i = i + 1U;
#line 4288
      __cil_tmp25 = tmp___9 * 64U;
#line 4288
      acb->srb_array[tmp___8].segment_x = ptr + __cil_tmp25;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___3: ;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___1: ;
#line 4291
  if (i < srbs_per_page) {
#line 4292
    __cil_tmp26 = i * 64U;
#line 4292
    acb->srb.segment_x = ptr + __cil_tmp26;
  } else {
    {
#line 4295
    printk("<7>dc395x: No space for tmsrb SG table reserved?!\n");
    }
  }
#line 4296
  return (0);
}
}
#line 4310
static void adapter_print_config(struct AdapterCtlBlk *acb )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4310
static void adapter_print_config(struct AdapterCtlBlk *acb )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4310 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_print_config(struct AdapterCtlBlk *acb ) 
{ u8 bval ;
  unsigned char tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  unsigned char tmp___11 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 4314
  __cil_tmp8 = acb->io_port_base;
#line 4314
  __cil_tmp9 = __cil_tmp8 + 213UL;
#line 4314
  __cil_tmp10 = (int )__cil_tmp9;
#line 4314
  tmp___7 = inb(__cil_tmp10);
#line 4314
  bval = tmp___7;
  }
  {
#line 4315
  __cil_tmp11 = (int )bval;
#line 4315
  if (__cil_tmp11 & 2) {
#line 4315
    tmp___8 = "(Wide) ";
  } else {
#line 4315
    tmp___8 = "";
  }
  }
  {
#line 4315
  printk("<6>dc395x: %sConnectors: ", tmp___8);
  }
  {
#line 4317
  __cil_tmp12 = (int )bval;
#line 4317
  __cil_tmp13 = __cil_tmp12 & 16;
#line 4317
  if (! __cil_tmp13) {
    {
#line 4318
    __cil_tmp14 = (int )bval;
#line 4318
    __cil_tmp15 = __cil_tmp14 & 64;
#line 4318
    if (! __cil_tmp15) {
#line 4318
      tmp___9 = "68";
    } else {
#line 4318
      tmp___9 = "50";
    }
    }
    {
#line 4318
    printk("ext%s ", tmp___9);
    }
  } else {

  }
  }
  {
#line 4319
  __cil_tmp16 = (int )bval;
#line 4319
  __cil_tmp17 = __cil_tmp16 & 8;
#line 4319
  if (! __cil_tmp17) {
    {
#line 4320
    __cil_tmp18 = (int )bval;
#line 4320
    __cil_tmp19 = __cil_tmp18 & 32;
#line 4320
    if (! __cil_tmp19) {
#line 4320
      tmp___10 = "";
    } else {
#line 4320
      tmp___10 = "(50)";
    }
    }
    {
#line 4320
    printk("int68%s ", tmp___10);
    }
  } else {

  }
  }
  {
#line 4321
  __cil_tmp20 = (int )bval;
#line 4321
  __cil_tmp21 = __cil_tmp20 & 4;
#line 4321
  if (! __cil_tmp21) {
    {
#line 4322
    printk("int50 ");
    }
  } else {

  }
  }
  {
#line 4323
  __cil_tmp22 = (int )bval;
#line 4323
  __cil_tmp23 = __cil_tmp22 & 28;
#line 4323
  if (__cil_tmp23 == 0) {
    {
#line 4325
    printk(" Oops! (All 3?) ");
    }
  } else {

  }
  }
  {
#line 4326
  __cil_tmp24 = acb->io_port_base;
#line 4326
  __cil_tmp25 = __cil_tmp24 + 212UL;
#line 4326
  __cil_tmp26 = (int )__cil_tmp25;
#line 4326
  tmp___11 = inb(__cil_tmp26);
#line 4326
  bval = tmp___11;
#line 4327
  printk(" Termination: ");
  }
  {
#line 4328
  __cil_tmp27 = (int )bval;
#line 4328
  if (__cil_tmp27 & 8) {
    {
#line 4329
    printk("Disabled\n");
    }
  } else {
    {
#line 4331
    __cil_tmp28 = (int )bval;
#line 4331
    if (__cil_tmp28 & 4) {
      {
#line 4332
      printk("Auto ");
      }
    } else {

    }
    }
    {
#line 4333
    __cil_tmp29 = (int )bval;
#line 4333
    if (__cil_tmp29 & 2) {
      {
#line 4334
      printk("Low ");
      }
    } else {

    }
    }
    {
#line 4335
    __cil_tmp30 = (int )bval;
#line 4335
    if (__cil_tmp30 & 1) {
      {
#line 4336
      printk("High ");
      }
    } else {

    }
    }
    {
#line 4337
    printk("\n");
    }
  }
  }
#line 4339
  return;
}
}
#line 4370 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct lock_class_key __key___6  ;
#line 4371 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct lock_class_key __key___7  ;
#line 4354
static void adapter_init_params(struct AdapterCtlBlk *acb )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4354
static void adapter_init_params(struct AdapterCtlBlk *acb )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4354 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_init_params(struct AdapterCtlBlk *acb ) 
{ struct NvRamType *eeprom ;
  int i ;
  struct list_head *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  struct list_head *__cil_tmp7 ;
  struct timer_list *__cil_tmp8 ;
  struct timer_list *__cil_tmp9 ;
  u8 __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  u8 __cil_tmp13 ;
  int __cil_tmp14 ;
  u8 __cil_tmp15 ;
  int __cil_tmp16 ;
  struct Scsi_Host *__cil_tmp17 ;
  u8 __cil_tmp18 ;
  struct Scsi_Host *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  u16 __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  struct ScsiReqBlk *__cil_tmp25 ;

  {
  {
#line 4356
  eeprom = & acb->eeprom;
#line 4363
  __cil_tmp4 = & acb->dcb_list;
#line 4363
  INIT_LIST_HEAD(__cil_tmp4);
#line 4364
  __cil_tmp5 = (void *)0;
#line 4364
  acb->dcb_run_robin = (struct DeviceCtlBlk *)__cil_tmp5;
#line 4365
  __cil_tmp6 = (void *)0;
#line 4365
  acb->active_dcb = (struct DeviceCtlBlk *)__cil_tmp6;
#line 4367
  __cil_tmp7 = & acb->srb_free_list;
#line 4367
  INIT_LIST_HEAD(__cil_tmp7);
#line 4369
  acb->tmp_srb = & acb->srb;
  }
  {
#line 4370
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4370
    __cil_tmp8 = & acb->waiting_timer;
#line 4370
    init_timer_key(__cil_tmp8, "&acb->waiting_timer", & __key___6);
    }
#line 4370
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 4371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 4371
    __cil_tmp9 = & acb->selto_timer;
#line 4371
    init_timer_key(__cil_tmp9, "&acb->selto_timer", & __key___7);
    }
#line 4371
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___0: 
#line 4373
  acb->srb_count = (u16 )63;
#line 4375
  acb->sel_timeout = (u8 )153;
#line 4378
  __cil_tmp10 = eeprom->max_tag;
#line 4378
  __cil_tmp11 = (int )__cil_tmp10;
#line 4378
  __cil_tmp12 = 1 << __cil_tmp11;
#line 4378
  acb->tag_max_num = (u8 )__cil_tmp12;
  {
#line 4379
  __cil_tmp13 = acb->tag_max_num;
#line 4379
  __cil_tmp14 = (int )__cil_tmp13;
#line 4379
  if (__cil_tmp14 > 30) {
#line 4380
    acb->tag_max_num = (u8 )30;
  } else {

  }
  }
#line 4382
  acb->acb_flag = (u8 )0;
#line 4383
  acb->gmode2 = eeprom->channel_cfg;
#line 4384
  acb->config = (u8 )0;
  {
#line 4386
  __cil_tmp15 = eeprom->channel_cfg;
#line 4386
  __cil_tmp16 = (int )__cil_tmp15;
#line 4386
  if (__cil_tmp16 & 32) {
#line 4387
    acb->lun_chk = (u8 )1;
  } else {

  }
  }
#line 4388
  acb->scan_devices = (u8 )1;
#line 4390
  __cil_tmp17 = acb->scsi_host;
#line 4390
  __cil_tmp18 = eeprom->scsi_id;
#line 4390
  __cil_tmp17->this_id = (int )__cil_tmp18;
#line 4391
  __cil_tmp19 = acb->scsi_host;
#line 4391
  __cil_tmp20 = __cil_tmp19->this_id;
#line 4391
  __cil_tmp21 = 1 << __cil_tmp20;
#line 4391
  acb->hostid_bit = (u8 )__cil_tmp21;
#line 4393
  i = 0;
  {
#line 4393
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 4393
    if (i < 16) {

    } else {
#line 4393
      goto while_break___1;
    }
#line 4394
    acb->dcb_map[i] = (u8 )0;
#line 4393
    i = i + 1;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break___1: 
#line 4396
  acb->msg_len = (u8 )0;
#line 4399
  i = 0;
  {
#line 4399
  while (1) {
    while_continue___2: /* CIL Label */ ;

    {
#line 4399
    __cil_tmp22 = acb->srb_count;
#line 4399
    __cil_tmp23 = (int )__cil_tmp22;
#line 4399
    __cil_tmp24 = __cil_tmp23 - 1;
#line 4399
    if (i < __cil_tmp24) {

    } else {
#line 4399
      goto while_break___2;
    }
    }
    {
#line 4400
    __cil_tmp25 = & acb->srb_array[i];
#line 4400
    srb_free_insert(acb, __cil_tmp25);
#line 4399
    i = i + 1;
    }
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___2: ;
#line 4401
  return;
}
}
#line 4416
static void adapter_init_scsi_host(struct Scsi_Host *host )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4416
static void adapter_init_scsi_host(struct Scsi_Host *host )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4416 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_init_scsi_host(struct Scsi_Host *host ) 
{ struct AdapterCtlBlk *acb ;
  struct NvRamType *eeprom ;
  unsigned long *__cil_tmp4 ;
  u8 __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  u8 __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  u8 __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 4418
  __cil_tmp4 = & host->hostdata[0];
#line 4418
  acb = (struct AdapterCtlBlk *)__cil_tmp4;
#line 4419
  eeprom = & acb->eeprom;
#line 4421
  host->max_cmd_len = (unsigned short)24;
#line 4422
  host->can_queue = 32;
#line 4423
  host->cmd_per_lun = (short)16;
#line 4424
  __cil_tmp5 = eeprom->scsi_id;
#line 4424
  host->this_id = (int )__cil_tmp5;
#line 4425
  host->io_port = acb->io_port_base;
#line 4426
  __cil_tmp6 = acb->io_port_len;
#line 4426
  host->n_io_port = (unsigned char )__cil_tmp6;
#line 4427
  host->dma_channel = (unsigned char)255;
#line 4428
  __cil_tmp7 = acb->io_port_base;
#line 4428
  host->unique_id = (unsigned int )__cil_tmp7;
#line 4429
  host->irq = acb->irq_level;
#line 4430
  host->last_reset = (unsigned long )jiffies;
#line 4432
  host->max_id = 16U;
  {
#line 4433
  __cil_tmp8 = eeprom->scsi_id;
#line 4433
  __cil_tmp9 = (unsigned int )__cil_tmp8;
#line 4433
  __cil_tmp10 = host->max_id;
#line 4433
  __cil_tmp11 = __cil_tmp10 - 1U;
#line 4433
  if (__cil_tmp11 == __cil_tmp9) {
#line 4434
    __cil_tmp12 = host->max_id;
#line 4434
    host->max_id = __cil_tmp12 - 1U;
  } else {

  }
  }
  {
#line 4437
  __cil_tmp13 = eeprom->channel_cfg;
#line 4437
  __cil_tmp14 = (int )__cil_tmp13;
#line 4437
  if (__cil_tmp14 & 32) {
#line 4438
    host->max_lun = 8U;
  } else {
#line 4440
    host->max_lun = 1U;
  }
  }
#line 4445
  return;
}
}
#line 4457
static void adapter_init_chip(struct AdapterCtlBlk *acb )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4457
static void adapter_init_chip(struct AdapterCtlBlk *acb )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4457 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_init_chip(struct AdapterCtlBlk *acb ) 
{ struct NvRamType *eeprom ;
  unsigned char tmp___7 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  u8 __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  u8 __cil_tmp23 ;
  int __cil_tmp24 ;
  u8 __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  u8 __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  struct Scsi_Host *__cil_tmp33 ;
  u8 __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  unsigned long volatile   __cil_tmp37 ;
  unsigned long volatile   __cil_tmp38 ;
  unsigned long volatile   __cil_tmp39 ;
  unsigned long volatile   __cil_tmp40 ;

  {
  {
#line 4459
  eeprom = & acb->eeprom;
#line 4462
  __cil_tmp4 = acb->io_port_base;
#line 4462
  __cil_tmp5 = __cil_tmp4 + 164UL;
#line 4462
  __cil_tmp6 = (int )__cil_tmp5;
#line 4462
  outb((unsigned char)0, __cil_tmp6);
#line 4463
  __cil_tmp7 = acb->io_port_base;
#line 4463
  __cil_tmp8 = __cil_tmp7 + 140UL;
#line 4463
  __cil_tmp9 = (int )__cil_tmp8;
#line 4463
  outb((unsigned char)0, __cil_tmp9);
#line 4466
  __cil_tmp10 = acb->io_port_base;
#line 4466
  __cil_tmp11 = __cil_tmp10 + 128UL;
#line 4466
  __cil_tmp12 = (int )__cil_tmp11;
#line 4466
  outw((unsigned short)16, __cil_tmp12);
#line 4469
  __cil_tmp13 = acb->io_port_base;
#line 4469
  __cil_tmp14 = __cil_tmp13 + 161UL;
#line 4469
  __cil_tmp15 = (int )__cil_tmp14;
#line 4469
  outb((unsigned char)16, __cil_tmp15);
#line 4470
  __const_udelay(85900UL);
#line 4473
  acb->config = (u8 )12;
#line 4474
  __cil_tmp16 = acb->io_port_base;
#line 4474
  __cil_tmp17 = __cil_tmp16 + 213UL;
#line 4474
  __cil_tmp18 = (int )__cil_tmp17;
#line 4474
  tmp___7 = inb(__cil_tmp18);
  }
  {
#line 4474
  __cil_tmp19 = (int )tmp___7;
#line 4474
  if (__cil_tmp19 & 2) {
#line 4475
    __cil_tmp20 = acb->config;
#line 4475
    __cil_tmp21 = (int )__cil_tmp20;
#line 4475
    __cil_tmp22 = __cil_tmp21 | 32;
#line 4475
    acb->config = (u8 )__cil_tmp22;
  } else {

  }
  }
  {
#line 4477
  __cil_tmp23 = eeprom->channel_cfg;
#line 4477
  __cil_tmp24 = (int )__cil_tmp23;
#line 4477
  if (__cil_tmp24 & 4) {
#line 4478
    __cil_tmp25 = acb->config;
#line 4478
    __cil_tmp26 = (int )__cil_tmp25;
#line 4478
    __cil_tmp27 = __cil_tmp26 | 16;
#line 4478
    acb->config = (u8 )__cil_tmp27;
  } else {

  }
  }
  {
#line 4480
  __cil_tmp28 = acb->config;
#line 4480
  __cil_tmp29 = (int )__cil_tmp28;
#line 4480
  if (__cil_tmp29 & 16) {
    {
#line 4481
    printk("<6>dc395x: Performing initial SCSI bus reset\n");
#line 4482
    __cil_tmp30 = acb->io_port_base;
#line 4482
    __cil_tmp31 = __cil_tmp30 + 128UL;
#line 4482
    __cil_tmp32 = (int )__cil_tmp31;
#line 4482
    outb((unsigned char)8, __cil_tmp32);
#line 4486
    __const_udelay(2147500UL);
#line 4488
    __cil_tmp33 = acb->scsi_host;
#line 4488
    __cil_tmp34 = acb->eeprom.delay_time;
#line 4488
    __cil_tmp35 = (int )__cil_tmp34;
#line 4488
    __cil_tmp36 = 250 * __cil_tmp35;
#line 4488
    __cil_tmp37 = (unsigned long volatile   )__cil_tmp36;
#line 4488
    __cil_tmp38 = (unsigned long volatile   )125;
#line 4488
    __cil_tmp39 = jiffies + __cil_tmp38;
#line 4488
    __cil_tmp40 = __cil_tmp39 + __cil_tmp37;
#line 4488
    __cil_tmp33->last_reset = (unsigned long )__cil_tmp40;
    }
  } else {

  }
  }
#line 4494
  return;
}
}
#line 4510
static int adapter_init(struct AdapterCtlBlk *acb , unsigned long io_port , u32 io_port_len ,
                        unsigned int irq )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4510
static int adapter_init(struct AdapterCtlBlk *acb , unsigned long io_port , u32 io_port_len ,
                        unsigned int irq )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4510 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int adapter_init(struct AdapterCtlBlk *acb , unsigned long io_port , u32 io_port_len ,
                        unsigned int irq ) 
{ struct resource *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp ;
  int tmp___10 ;
  resource_size_t __cil_tmp10 ;
  resource_size_t __cil_tmp11 ;
  void *__cil_tmp12 ;
  struct NvRamType *__cil_tmp13 ;
  struct NvRamType *__cil_tmp14 ;
  struct Scsi_Host *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  resource_size_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  resource_size_t __cil_tmp21 ;

  {
  {
#line 4513
  __cil_tmp10 = (resource_size_t )io_port;
#line 4513
  __cil_tmp11 = (resource_size_t )io_port_len;
#line 4513
  tmp___7 = __request_region(& ioport_resource, __cil_tmp10, __cil_tmp11, "dc395x",
                             0);
  }
#line 4513
  if (tmp___7) {

  } else {
    {
#line 4514
    printk("<3>dc395x: Failed to reserve IO region 0x%lx\n", io_port);
    }
#line 4515
    goto failed;
  }
  {
#line 4518
  acb->io_port_base = io_port;
#line 4519
  acb->io_port_len = (unsigned long )io_port_len;
#line 4521
  __cil_tmp12 = (void *)acb;
#line 4521
  tmp___10 = (int )request_irq(irq, & dc395x_interrupt, 128UL, "dc395x", __cil_tmp12);
#line 4521
  tmp = tmp___10;
#line 4521
  tmp___8 = tmp;
  }
#line 4521
  if (tmp___8) {
    {
#line 4523
    printk("<6>dc395x: Failed to register IRQ\n");
    }
#line 4524
    goto failed;
  } else {

  }
  {
#line 4527
  acb->irq_level = irq;
#line 4530
  __cil_tmp13 = & acb->eeprom;
#line 4530
  check_eeprom(__cil_tmp13, io_port);
#line 4531
  __cil_tmp14 = & acb->eeprom;
#line 4531
  print_eeprom_settings(__cil_tmp14);
#line 4534
  adapter_init_params(acb);
#line 4537
  adapter_print_config(acb);
#line 4539
  tmp___9 = adapter_sg_tables_alloc(acb);
  }
#line 4539
  if (tmp___9) {
    {
#line 4540
    printk("<7>dc395x: Memory allocation for SG tables failed\n");
    }
#line 4541
    goto failed;
  } else {

  }
  {
#line 4543
  __cil_tmp15 = acb->scsi_host;
#line 4543
  adapter_init_scsi_host(__cil_tmp15);
#line 4544
  adapter_init_chip(acb);
#line 4545
  set_basic_config(acb);
  }
  {
#line 4547
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4547
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 4552
  return (0);
  failed: 
#line 4555
  if (acb->irq_level) {
    {
#line 4556
    __cil_tmp16 = acb->irq_level;
#line 4556
    __cil_tmp17 = (void *)acb;
#line 4556
    free_irq(__cil_tmp16, __cil_tmp17);
    }
  } else {

  }
#line 4557
  if (acb->io_port_base) {
    {
#line 4558
    __cil_tmp18 = acb->io_port_base;
#line 4558
    __cil_tmp19 = (resource_size_t )__cil_tmp18;
#line 4558
    __cil_tmp20 = acb->io_port_len;
#line 4558
    __cil_tmp21 = (resource_size_t )__cil_tmp20;
#line 4558
    __release_region(& ioport_resource, __cil_tmp19, __cil_tmp21);
    }
  } else {

  }
  {
#line 4559
  adapter_sg_tables_free(acb);
  }
#line 4561
  return (1);
}
}
#line 4572 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_uninit_chip(struct AdapterCtlBlk *acb ) 
{ unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  u8 __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 4575
  __cil_tmp2 = acb->io_port_base;
#line 4575
  __cil_tmp3 = __cil_tmp2 + 164UL;
#line 4575
  __cil_tmp4 = (int )__cil_tmp3;
#line 4575
  outb((unsigned char)0, __cil_tmp4);
#line 4576
  __cil_tmp5 = acb->io_port_base;
#line 4576
  __cil_tmp6 = __cil_tmp5 + 140UL;
#line 4576
  __cil_tmp7 = (int )__cil_tmp6;
#line 4576
  outb((unsigned char)0, __cil_tmp7);
  }
  {
#line 4579
  __cil_tmp8 = acb->config;
#line 4579
  __cil_tmp9 = (int )__cil_tmp8;
#line 4579
  if (__cil_tmp9 & 16) {
    {
#line 4580
    reset_scsi_bus(acb);
    }
  } else {

  }
  }
  {
#line 4583
  __cil_tmp10 = acb->io_port_base;
#line 4583
  __cil_tmp11 = __cil_tmp10 + 132UL;
#line 4583
  __cil_tmp12 = (int )__cil_tmp11;
#line 4583
  inb(__cil_tmp12);
  }
#line 4584
  return;
}
}
#line 4595 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void adapter_uninit(struct AdapterCtlBlk *acb ) 
{ unsigned long flags ;
  raw_spinlock_t *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct Scsi_Host *__cil_tmp6 ;
  spinlock_t *__cil_tmp7 ;
  struct timer_list *__cil_tmp8 ;
  struct timer_list  const  *__cil_tmp9 ;
  struct timer_list *__cil_tmp10 ;
  struct timer_list *__cil_tmp11 ;
  struct timer_list  const  *__cil_tmp12 ;
  struct timer_list *__cil_tmp13 ;
  struct Scsi_Host *__cil_tmp14 ;
  spinlock_t *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  resource_size_t __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  resource_size_t __cil_tmp21 ;

  {
  {
#line 4598
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 4598
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4598
      __cil_tmp6 = acb->scsi_host;
#line 4598
      __cil_tmp7 = __cil_tmp6->host_lock;
#line 4598
      tmp___7 = spinlock_check(__cil_tmp7);
#line 4598
      flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 4598
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
#line 4598
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4601
  __cil_tmp8 = & acb->waiting_timer;
#line 4601
  __cil_tmp9 = (struct timer_list  const  *)__cil_tmp8;
#line 4601
  tmp___8 = timer_pending(__cil_tmp9);
  }
#line 4601
  if (tmp___8) {
    {
#line 4602
    __cil_tmp10 = & acb->waiting_timer;
#line 4602
    del_timer(__cil_tmp10);
    }
  } else {

  }
  {
#line 4603
  __cil_tmp11 = & acb->selto_timer;
#line 4603
  __cil_tmp12 = (struct timer_list  const  *)__cil_tmp11;
#line 4603
  tmp___9 = timer_pending(__cil_tmp12);
  }
#line 4603
  if (tmp___9) {
    {
#line 4604
    __cil_tmp13 = & acb->selto_timer;
#line 4604
    del_timer(__cil_tmp13);
    }
  } else {

  }
  {
#line 4606
  adapter_uninit_chip(acb);
#line 4607
  adapter_remove_and_free_all_devices(acb);
#line 4608
  __cil_tmp14 = acb->scsi_host;
#line 4608
  __cil_tmp15 = __cil_tmp14->host_lock;
#line 4608
  spin_unlock_irqrestore(__cil_tmp15, flags);
  }
#line 4610
  if (acb->irq_level) {
    {
#line 4611
    __cil_tmp16 = acb->irq_level;
#line 4611
    __cil_tmp17 = (void *)acb;
#line 4611
    free_irq(__cil_tmp16, __cil_tmp17);
    }
  } else {

  }
#line 4612
  if (acb->io_port_base) {
    {
#line 4613
    __cil_tmp18 = acb->io_port_base;
#line 4613
    __cil_tmp19 = (resource_size_t )__cil_tmp18;
#line 4613
    __cil_tmp20 = acb->io_port_len;
#line 4613
    __cil_tmp21 = (resource_size_t )__cil_tmp20;
#line 4613
    __release_region(& ioport_resource, __cil_tmp19, __cil_tmp21);
    }
  } else {

  }
  {
#line 4615
  adapter_sg_tables_free(acb);
  }
#line 4616
  return;
}
}
#line 4627 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_proc_info(struct Scsi_Host *host , char *buffer , char **start ,
                            off_t offset , int length , int inout ) 
{ struct AdapterCtlBlk *acb ;
  int spd ;
  int spd1 ;
  char *pos ;
  struct DeviceCtlBlk *dcb ;
  unsigned long flags ;
  int dev ;
  int tmp___7 ;
  int tmp___8 ;
  raw_spinlock_t *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned char tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int nego_period ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct ScsiReqBlk *srb ;
  unsigned int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  int tmp___51 ;
  unsigned int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  unsigned long *__cil_tmp76 ;
  struct Scsi_Host *__cil_tmp77 ;
  spinlock_t *__cil_tmp78 ;
  unsigned int __cil_tmp79 ;
  u8 __cil_tmp80 ;
  int __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned int __cil_tmp83 ;
  u8 __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  unsigned int __cil_tmp88 ;
  unsigned int __cil_tmp89 ;
  int __cil_tmp90 ;
  u8 __cil_tmp91 ;
  int __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  unsigned long __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  u8 __cil_tmp97 ;
  int __cil_tmp98 ;
  struct list_head *__cil_tmp99 ;
  u8 __cil_tmp100 ;
  int __cil_tmp101 ;
  u8 __cil_tmp102 ;
  int __cil_tmp103 ;
  u8 __cil_tmp104 ;
  int __cil_tmp105 ;
  u8 __cil_tmp106 ;
  int __cil_tmp107 ;
  u8 __cil_tmp108 ;
  int __cil_tmp109 ;
  u8 __cil_tmp110 ;
  int __cil_tmp111 ;
  u8 __cil_tmp112 ;
  int __cil_tmp113 ;
  u8 __cil_tmp114 ;
  int __cil_tmp115 ;
  u8 __cil_tmp116 ;
  int __cil_tmp117 ;
  u8 __cil_tmp118 ;
  int __cil_tmp119 ;
  u8 __cil_tmp120 ;
  int __cil_tmp121 ;
  u8 __cil_tmp122 ;
  int __cil_tmp123 ;
  u8 __cil_tmp124 ;
  int __cil_tmp125 ;
  u8 __cil_tmp126 ;
  int __cil_tmp127 ;
  u8 __cil_tmp128 ;
  int __cil_tmp129 ;
  u8 __cil_tmp130 ;
  int __cil_tmp131 ;
  struct list_head *__cil_tmp132 ;
  struct DeviceCtlBlk *__cil_tmp133 ;
  struct list_head *__cil_tmp134 ;
  unsigned int __cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  struct list_head *__cil_tmp138 ;
  unsigned long __cil_tmp139 ;
  struct list_head *__cil_tmp140 ;
  unsigned long __cil_tmp141 ;
  u8 __cil_tmp142 ;
  int __cil_tmp143 ;
  u8 __cil_tmp144 ;
  int __cil_tmp145 ;
  u8 __cil_tmp146 ;
  int __cil_tmp147 ;
  u8 __cil_tmp148 ;
  int __cil_tmp149 ;
  u8 __cil_tmp150 ;
  int __cil_tmp151 ;
  u8 __cil_tmp152 ;
  int __cil_tmp153 ;
  u8 __cil_tmp154 ;
  int __cil_tmp155 ;
  int __cil_tmp156 ;
  u8 __cil_tmp157 ;
  int __cil_tmp158 ;
  int __cil_tmp159 ;
  u8 __cil_tmp160 ;
  int __cil_tmp161 ;
  int __cil_tmp162 ;
  int __cil_tmp163 ;
  int __cil_tmp164 ;
  u8 __cil_tmp165 ;
  int __cil_tmp166 ;
  int __cil_tmp167 ;
  u16 __cil_tmp168 ;
  int __cil_tmp169 ;
  struct list_head *__cil_tmp170 ;
  struct DeviceCtlBlk *__cil_tmp171 ;
  struct list_head *__cil_tmp172 ;
  unsigned int __cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  struct timer_list *__cil_tmp176 ;
  struct timer_list  const  *__cil_tmp177 ;
  struct list_head *__cil_tmp178 ;
  struct DeviceCtlBlk *__cil_tmp179 ;
  struct list_head *__cil_tmp180 ;
  unsigned int __cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  struct list_head *__cil_tmp184 ;
  unsigned long __cil_tmp185 ;
  struct list_head *__cil_tmp186 ;
  unsigned long __cil_tmp187 ;
  struct list_head *__cil_tmp188 ;
  struct list_head  const  *__cil_tmp189 ;
  struct list_head *__cil_tmp190 ;
  u8 __cil_tmp191 ;
  int __cil_tmp192 ;
  u8 __cil_tmp193 ;
  int __cil_tmp194 ;
  struct list_head *__cil_tmp195 ;
  struct ScsiReqBlk *__cil_tmp196 ;
  struct list_head *__cil_tmp197 ;
  unsigned int __cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  struct list_head *__cil_tmp201 ;
  unsigned long __cil_tmp202 ;
  struct list_head *__cil_tmp203 ;
  unsigned long __cil_tmp204 ;
  struct scsi_cmnd *__cil_tmp205 ;
  struct list_head *__cil_tmp206 ;
  struct ScsiReqBlk *__cil_tmp207 ;
  struct list_head *__cil_tmp208 ;
  unsigned int __cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  struct list_head *__cil_tmp212 ;
  struct list_head  const  *__cil_tmp213 ;
  struct list_head *__cil_tmp214 ;
  u8 __cil_tmp215 ;
  int __cil_tmp216 ;
  u8 __cil_tmp217 ;
  int __cil_tmp218 ;
  struct list_head *__cil_tmp219 ;
  struct ScsiReqBlk *__cil_tmp220 ;
  struct list_head *__cil_tmp221 ;
  unsigned int __cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  struct list_head *__cil_tmp225 ;
  unsigned long __cil_tmp226 ;
  struct list_head *__cil_tmp227 ;
  unsigned long __cil_tmp228 ;
  struct scsi_cmnd *__cil_tmp229 ;
  struct list_head *__cil_tmp230 ;
  struct ScsiReqBlk *__cil_tmp231 ;
  struct list_head *__cil_tmp232 ;
  unsigned int __cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  struct list_head *__cil_tmp236 ;
  struct list_head  const  *__cil_tmp237 ;
  struct list_head *__cil_tmp238 ;
  struct list_head  const  *__cil_tmp239 ;
  struct list_head *__cil_tmp240 ;
  struct DeviceCtlBlk *__cil_tmp241 ;
  struct list_head *__cil_tmp242 ;
  unsigned int __cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  struct Scsi_Host *__cil_tmp246 ;
  spinlock_t *__cil_tmp247 ;
  int __cil_tmp248 ;
  off_t __cil_tmp249 ;
  off_t __cil_tmp250 ;
  int __cil_tmp251 ;
  off_t __cil_tmp252 ;
  off_t __cil_tmp253 ;
  int __cil_tmp254 ;
  off_t __cil_tmp255 ;
  off_t __cil_tmp256 ;

  {
#line 4630
  __cil_tmp76 = & host->hostdata[0];
#line 4630
  acb = (struct AdapterCtlBlk *)__cil_tmp76;
#line 4632
  pos = buffer;
#line 4637
  if (inout) {
#line 4638
    return (-1);
  } else {

  }
  {
#line 4640
  tmp___7 = sprintf(pos, "Tekram DC395(U/UW/F), DC315(U) - ASIC TRM-S1040 PCI SCSI Host Adapter\n");
#line 4640
  pos = pos + tmp___7;
#line 4641
  tmp___8 = sprintf(pos, " Driver Version v2.05, 2004/03/08\n");
#line 4641
  pos = pos + tmp___8;
  }
  {
#line 4643
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 4643
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4643
      __cil_tmp77 = acb->scsi_host;
#line 4643
      __cil_tmp78 = __cil_tmp77->host_lock;
#line 4643
      tmp___9 = spinlock_check(__cil_tmp78);
#line 4643
      flags = _raw_spin_lock_irqsave(tmp___9);
      }
#line 4643
      goto while_break___0;
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___0: ;
#line 4643
    goto while_break;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4645
  __cil_tmp79 = host->host_no;
#line 4645
  tmp___10 = sprintf(pos, "SCSI Host Nr %i, ", __cil_tmp79);
#line 4645
  pos = pos + tmp___10;
  }
  {
#line 4646
  __cil_tmp80 = acb->config;
#line 4646
  __cil_tmp81 = (int )__cil_tmp80;
#line 4646
  if (__cil_tmp81 & 32) {
#line 4646
    tmp___11 = "Wide";
  } else {
#line 4646
    tmp___11 = "";
  }
  }
  {
#line 4646
  tmp___12 = sprintf(pos, "DC395U/UW/F DC315/U %s\n", tmp___11);
#line 4646
  pos = pos + tmp___12;
#line 4648
  __cil_tmp82 = acb->io_port_base;
#line 4648
  tmp___13 = sprintf(pos, "io_port_base 0x%04lx, ", __cil_tmp82);
#line 4648
  pos = pos + tmp___13;
#line 4649
  __cil_tmp83 = acb->irq_level;
#line 4649
  tmp___14 = sprintf(pos, "irq_level 0x%04x, ", __cil_tmp83);
#line 4649
  pos = pos + tmp___14;
#line 4650
  __cil_tmp84 = acb->sel_timeout;
#line 4650
  __cil_tmp85 = (int )__cil_tmp84;
#line 4650
  __cil_tmp86 = 1638 * __cil_tmp85;
#line 4650
  __cil_tmp87 = __cil_tmp86 / 1000;
#line 4650
  tmp___15 = sprintf(pos, " SelTimeout %ims\n", __cil_tmp87);
#line 4650
  pos = pos + tmp___15;
#line 4652
  __cil_tmp88 = host->max_id;
#line 4652
  __cil_tmp89 = host->max_lun;
#line 4652
  tmp___16 = sprintf(pos, "MaxID %i, MaxLUN %i, ", __cil_tmp88, __cil_tmp89);
#line 4652
  pos = pos + tmp___16;
#line 4653
  __cil_tmp90 = host->this_id;
#line 4653
  tmp___17 = sprintf(pos, "AdapterID %i\n", __cil_tmp90);
#line 4653
  pos = pos + tmp___17;
#line 4655
  __cil_tmp91 = acb->tag_max_num;
#line 4655
  __cil_tmp92 = (int )__cil_tmp91;
#line 4655
  tmp___18 = sprintf(pos, "tag_max_num %i", __cil_tmp92);
#line 4655
  pos = pos + tmp___18;
#line 4657
  __cil_tmp93 = acb->io_port_base;
#line 4657
  __cil_tmp94 = __cil_tmp93 + 142UL;
#line 4657
  __cil_tmp95 = (int )__cil_tmp94;
#line 4657
  tmp___19 = inb(__cil_tmp95);
#line 4657
  __cil_tmp96 = (int )tmp___19;
#line 4657
  tmp___20 = sprintf(pos, ", FilterCfg 0x%02x", __cil_tmp96);
#line 4657
  pos = pos + tmp___20;
#line 4659
  __cil_tmp97 = acb->eeprom.delay_time;
#line 4659
  __cil_tmp98 = (int )__cil_tmp97;
#line 4659
  tmp___21 = sprintf(pos, ", DelayReset %is\n", __cil_tmp98);
#line 4659
  pos = pos + tmp___21;
#line 4662
  __cil_tmp99 = & acb->dcb_list;
#line 4662
  tmp___22 = list_size(__cil_tmp99);
#line 4662
  tmp___23 = sprintf(pos, "Nr of DCBs: %i\n", tmp___22);
#line 4662
  pos = pos + tmp___23;
#line 4663
  __cil_tmp100 = acb->dcb_map[0];
#line 4663
  __cil_tmp101 = (int )__cil_tmp100;
#line 4663
  __cil_tmp102 = acb->dcb_map[1];
#line 4663
  __cil_tmp103 = (int )__cil_tmp102;
#line 4663
  __cil_tmp104 = acb->dcb_map[2];
#line 4663
  __cil_tmp105 = (int )__cil_tmp104;
#line 4663
  __cil_tmp106 = acb->dcb_map[3];
#line 4663
  __cil_tmp107 = (int )__cil_tmp106;
#line 4663
  __cil_tmp108 = acb->dcb_map[4];
#line 4663
  __cil_tmp109 = (int )__cil_tmp108;
#line 4663
  __cil_tmp110 = acb->dcb_map[5];
#line 4663
  __cil_tmp111 = (int )__cil_tmp110;
#line 4663
  __cil_tmp112 = acb->dcb_map[6];
#line 4663
  __cil_tmp113 = (int )__cil_tmp112;
#line 4663
  __cil_tmp114 = acb->dcb_map[7];
#line 4663
  __cil_tmp115 = (int )__cil_tmp114;
#line 4663
  tmp___24 = sprintf(pos, "Map of attached LUNs: %02x %02x %02x %02x %02x %02x %02x %02x\n",
                     __cil_tmp101, __cil_tmp103, __cil_tmp105, __cil_tmp107, __cil_tmp109,
                     __cil_tmp111, __cil_tmp113, __cil_tmp115);
#line 4663
  pos = pos + tmp___24;
#line 4668
  __cil_tmp116 = acb->dcb_map[8];
#line 4668
  __cil_tmp117 = (int )__cil_tmp116;
#line 4668
  __cil_tmp118 = acb->dcb_map[9];
#line 4668
  __cil_tmp119 = (int )__cil_tmp118;
#line 4668
  __cil_tmp120 = acb->dcb_map[10];
#line 4668
  __cil_tmp121 = (int )__cil_tmp120;
#line 4668
  __cil_tmp122 = acb->dcb_map[11];
#line 4668
  __cil_tmp123 = (int )__cil_tmp122;
#line 4668
  __cil_tmp124 = acb->dcb_map[12];
#line 4668
  __cil_tmp125 = (int )__cil_tmp124;
#line 4668
  __cil_tmp126 = acb->dcb_map[13];
#line 4668
  __cil_tmp127 = (int )__cil_tmp126;
#line 4668
  __cil_tmp128 = acb->dcb_map[14];
#line 4668
  __cil_tmp129 = (int )__cil_tmp128;
#line 4668
  __cil_tmp130 = acb->dcb_map[15];
#line 4668
  __cil_tmp131 = (int )__cil_tmp130;
#line 4668
  tmp___25 = sprintf(pos, "                      %02x %02x %02x %02x %02x %02x %02x %02x\n",
                     __cil_tmp117, __cil_tmp119, __cil_tmp121, __cil_tmp123, __cil_tmp125,
                     __cil_tmp127, __cil_tmp129, __cil_tmp131);
#line 4668
  pos = pos + tmp___25;
#line 4674
  tmp___26 = sprintf(pos, "Un ID LUN Prty Sync Wide DsCn SndS TagQ nego_period SyncFreq SyncOffs MaxCmd\n");
#line 4674
  pos = pos + tmp___26;
#line 4677
  dev = 0;
#line 4678
  __cil_tmp132 = acb->dcb_list.next;
#line 4678
  __mptr = (struct list_head  const  *)__cil_tmp132;
#line 4678
  __cil_tmp133 = (struct DeviceCtlBlk *)0;
#line 4678
  __cil_tmp134 = & __cil_tmp133->list;
#line 4678
  __cil_tmp135 = (unsigned int )__cil_tmp134;
#line 4678
  __cil_tmp136 = (char *)__mptr;
#line 4678
  __cil_tmp137 = __cil_tmp136 - __cil_tmp135;
#line 4678
  dcb = (struct DeviceCtlBlk *)__cil_tmp137;
  }
  {
#line 4678
  while (1) {
    while_continue___1: /* CIL Label */ ;

    {
#line 4678
    __cil_tmp138 = & acb->dcb_list;
#line 4678
    __cil_tmp139 = (unsigned long )__cil_tmp138;
#line 4678
    __cil_tmp140 = & dcb->list;
#line 4678
    __cil_tmp141 = (unsigned long )__cil_tmp140;
#line 4678
    if (__cil_tmp141 != __cil_tmp139) {

    } else {
#line 4678
      goto while_break___1;
    }
    }
    {
#line 4680
    __cil_tmp142 = dcb->target_id;
#line 4680
    __cil_tmp143 = (int )__cil_tmp142;
#line 4680
    __cil_tmp144 = dcb->target_lun;
#line 4680
    __cil_tmp145 = (int )__cil_tmp144;
#line 4680
    tmp___27 = sprintf(pos, "%02i %02i  %02i ", dev, __cil_tmp143, __cil_tmp145);
#line 4680
    pos = pos + tmp___27;
    }
    {
#line 4682
    __cil_tmp146 = dcb->dev_mode;
#line 4682
    __cil_tmp147 = (int )__cil_tmp146;
#line 4682
    if (__cil_tmp147 & 1) {
      {
#line 4682
      tmp___28 = sprintf(pos, " Yes ");
#line 4682
      pos = pos + tmp___28;
      }
    } else {
      {
#line 4682
      tmp___29 = sprintf(pos, " No  ");
#line 4682
      pos = pos + tmp___29;
      }
    }
    }
#line 4683
    if (dcb->sync_offset) {
      {
#line 4683
      tmp___30 = sprintf(pos, " Yes ");
#line 4683
      pos = pos + tmp___30;
      }
    } else {
      {
#line 4683
      tmp___31 = sprintf(pos, " No  ");
#line 4683
      pos = pos + tmp___31;
      }
    }
    {
#line 4684
    __cil_tmp148 = dcb->sync_period;
#line 4684
    __cil_tmp149 = (int )__cil_tmp148;
#line 4684
    if (__cil_tmp149 & 16) {
      {
#line 4684
      tmp___32 = sprintf(pos, " Yes ");
#line 4684
      pos = pos + tmp___32;
      }
    } else {
      {
#line 4684
      tmp___33 = sprintf(pos, " No  ");
#line 4684
      pos = pos + tmp___33;
      }
    }
    }
    {
#line 4685
    __cil_tmp150 = dcb->dev_mode;
#line 4685
    __cil_tmp151 = (int )__cil_tmp150;
#line 4685
    if (__cil_tmp151 & 4) {
      {
#line 4685
      tmp___34 = sprintf(pos, " Yes ");
#line 4685
      pos = pos + tmp___34;
      }
    } else {
      {
#line 4685
      tmp___35 = sprintf(pos, " No  ");
#line 4685
      pos = pos + tmp___35;
      }
    }
    }
    {
#line 4686
    __cil_tmp152 = dcb->dev_mode;
#line 4686
    __cil_tmp153 = (int )__cil_tmp152;
#line 4686
    if (__cil_tmp153 & 8) {
      {
#line 4686
      tmp___36 = sprintf(pos, " Yes ");
#line 4686
      pos = pos + tmp___36;
      }
    } else {
      {
#line 4686
      tmp___37 = sprintf(pos, " No  ");
#line 4686
      pos = pos + tmp___37;
      }
    }
    }
    {
#line 4687
    __cil_tmp154 = dcb->sync_mode;
#line 4687
    __cil_tmp155 = (int )__cil_tmp154;
#line 4687
    if (__cil_tmp155 & 32) {
      {
#line 4687
      tmp___38 = sprintf(pos, " Yes ");
#line 4687
      pos = pos + tmp___38;
      }
    } else {
      {
#line 4687
      tmp___39 = sprintf(pos, " No  ");
#line 4687
      pos = pos + tmp___39;
      }
    }
    }
#line 4688
    __cil_tmp156 = (int )clock_period[(int )dcb->sync_period & 7];
#line 4688
    nego_period = __cil_tmp156 << 2;
#line 4689
    if (dcb->sync_offset) {
      {
#line 4690
      tmp___40 = sprintf(pos, "  %03i ns ", nego_period);
#line 4690
      pos = pos + tmp___40;
      }
    } else {
      {
#line 4692
      __cil_tmp157 = dcb->min_nego_period;
#line 4692
      __cil_tmp158 = (int )__cil_tmp157;
#line 4692
      __cil_tmp159 = __cil_tmp158 << 2;
#line 4692
      tmp___41 = sprintf(pos, " (%03i ns)", __cil_tmp159);
#line 4692
      pos = pos + tmp___41;
      }
    }
    {
#line 4694
    __cil_tmp160 = dcb->sync_offset;
#line 4694
    __cil_tmp161 = (int )__cil_tmp160;
#line 4694
    if (__cil_tmp161 & 15) {
      {
#line 4695
      spd = 1000 / nego_period;
#line 4696
      spd1 = 1000 % nego_period;
#line 4697
      __cil_tmp162 = nego_period / 2;
#line 4697
      __cil_tmp163 = spd1 * 10;
#line 4697
      __cil_tmp164 = __cil_tmp163 + __cil_tmp162;
#line 4697
      spd1 = __cil_tmp164 / nego_period;
#line 4698
      __cil_tmp165 = dcb->sync_offset;
#line 4698
      __cil_tmp166 = (int )__cil_tmp165;
#line 4698
      __cil_tmp167 = __cil_tmp166 & 15;
#line 4698
      tmp___42 = sprintf(pos, "   %2i.%1i M     %02i ", spd, spd1, __cil_tmp167);
#line 4698
      pos = pos + tmp___42;
      }
    } else {
      {
#line 4701
      tmp___43 = sprintf(pos, "                 ");
#line 4701
      pos = pos + tmp___43;
      }
    }
    }
    {
#line 4704
    __cil_tmp168 = dcb->max_command;
#line 4704
    __cil_tmp169 = (int )__cil_tmp168;
#line 4704
    tmp___44 = sprintf(pos, "     %02i\n", __cil_tmp169);
#line 4704
    pos = pos + tmp___44;
#line 4705
    dev = dev + 1;
#line 4678
    __cil_tmp170 = dcb->list.next;
#line 4678
    __mptr___0 = (struct list_head  const  *)__cil_tmp170;
#line 4678
    __cil_tmp171 = (struct DeviceCtlBlk *)0;
#line 4678
    __cil_tmp172 = & __cil_tmp171->list;
#line 4678
    __cil_tmp173 = (unsigned int )__cil_tmp172;
#line 4678
    __cil_tmp174 = (char *)__mptr___0;
#line 4678
    __cil_tmp175 = __cil_tmp174 - __cil_tmp173;
#line 4678
    dcb = (struct DeviceCtlBlk *)__cil_tmp175;
    }
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break___1: 
  {
#line 4708
  __cil_tmp176 = & acb->waiting_timer;
#line 4708
  __cil_tmp177 = (struct timer_list  const  *)__cil_tmp176;
#line 4708
  tmp___47 = timer_pending(__cil_tmp177);
  }
#line 4708
  if (tmp___47) {
    {
#line 4709
    tmp___45 = sprintf(pos, "Waiting queue timer running\n");
#line 4709
    pos = pos + tmp___45;
    }
  } else {
    {
#line 4711
    tmp___46 = sprintf(pos, "\n");
#line 4711
    pos = pos + tmp___46;
    }
  }
#line 4713
  __cil_tmp178 = acb->dcb_list.next;
#line 4713
  __mptr___1 = (struct list_head  const  *)__cil_tmp178;
#line 4713
  __cil_tmp179 = (struct DeviceCtlBlk *)0;
#line 4713
  __cil_tmp180 = & __cil_tmp179->list;
#line 4713
  __cil_tmp181 = (unsigned int )__cil_tmp180;
#line 4713
  __cil_tmp182 = (char *)__mptr___1;
#line 4713
  __cil_tmp183 = __cil_tmp182 - __cil_tmp181;
#line 4713
  dcb = (struct DeviceCtlBlk *)__cil_tmp183;
  {
#line 4713
  while (1) {
    while_continue___2: /* CIL Label */ ;

    {
#line 4713
    __cil_tmp184 = & acb->dcb_list;
#line 4713
    __cil_tmp185 = (unsigned long )__cil_tmp184;
#line 4713
    __cil_tmp186 = & dcb->list;
#line 4713
    __cil_tmp187 = (unsigned long )__cil_tmp186;
#line 4713
    if (__cil_tmp187 != __cil_tmp185) {

    } else {
#line 4713
      goto while_break___2;
    }
    }
    {
#line 4715
    __cil_tmp188 = & dcb->srb_waiting_list;
#line 4715
    __cil_tmp189 = (struct list_head  const  *)__cil_tmp188;
#line 4715
    tmp___50 = list_empty(__cil_tmp189);
    }
#line 4715
    if (tmp___50) {

    } else {
      {
#line 4716
      __cil_tmp190 = & dcb->srb_waiting_list;
#line 4716
      tmp___48 = list_size(__cil_tmp190);
#line 4716
      __cil_tmp191 = dcb->target_id;
#line 4716
      __cil_tmp192 = (int )__cil_tmp191;
#line 4716
      __cil_tmp193 = dcb->target_lun;
#line 4716
      __cil_tmp194 = (int )__cil_tmp193;
#line 4716
      tmp___49 = sprintf(pos, "DCB (%02i-%i): Waiting: %i:", __cil_tmp192, __cil_tmp194,
                         tmp___48);
#line 4716
      pos = pos + tmp___49;
      }
    }
#line 4719
    __cil_tmp195 = dcb->srb_waiting_list.next;
#line 4719
    __mptr___3 = (struct list_head  const  *)__cil_tmp195;
#line 4719
    __cil_tmp196 = (struct ScsiReqBlk *)0;
#line 4719
    __cil_tmp197 = & __cil_tmp196->list;
#line 4719
    __cil_tmp198 = (unsigned int )__cil_tmp197;
#line 4719
    __cil_tmp199 = (char *)__mptr___3;
#line 4719
    __cil_tmp200 = __cil_tmp199 - __cil_tmp198;
#line 4719
    srb = (struct ScsiReqBlk *)__cil_tmp200;
    {
#line 4719
    while (1) {
      while_continue___3: /* CIL Label */ ;

      {
#line 4719
      __cil_tmp201 = & dcb->srb_waiting_list;
#line 4719
      __cil_tmp202 = (unsigned long )__cil_tmp201;
#line 4719
      __cil_tmp203 = & srb->list;
#line 4719
      __cil_tmp204 = (unsigned long )__cil_tmp203;
#line 4719
      if (__cil_tmp204 != __cil_tmp202) {

      } else {
#line 4719
        goto while_break___3;
      }
      }
      {
#line 4720
      __cil_tmp205 = srb->cmd;
#line 4720
      tmp___51 = sprintf(pos, " %p", __cil_tmp205);
#line 4720
      pos = pos + tmp___51;
#line 4719
      __cil_tmp206 = srb->list.next;
#line 4719
      __mptr___4 = (struct list_head  const  *)__cil_tmp206;
#line 4719
      __cil_tmp207 = (struct ScsiReqBlk *)0;
#line 4719
      __cil_tmp208 = & __cil_tmp207->list;
#line 4719
      __cil_tmp209 = (unsigned int )__cil_tmp208;
#line 4719
      __cil_tmp210 = (char *)__mptr___4;
#line 4719
      __cil_tmp211 = __cil_tmp210 - __cil_tmp209;
#line 4719
      srb = (struct ScsiReqBlk *)__cil_tmp211;
      }
    }
    while_break___9: /* CIL Label */ ;
    }

    while_break___3: 
    {
#line 4721
    __cil_tmp212 = & dcb->srb_going_list;
#line 4721
    __cil_tmp213 = (struct list_head  const  *)__cil_tmp212;
#line 4721
    tmp___54 = list_empty(__cil_tmp213);
    }
#line 4721
    if (tmp___54) {

    } else {
      {
#line 4722
      __cil_tmp214 = & dcb->srb_going_list;
#line 4722
      tmp___52 = list_size(__cil_tmp214);
#line 4722
      __cil_tmp215 = dcb->target_id;
#line 4722
      __cil_tmp216 = (int )__cil_tmp215;
#line 4722
      __cil_tmp217 = dcb->target_lun;
#line 4722
      __cil_tmp218 = (int )__cil_tmp217;
#line 4722
      tmp___53 = sprintf(pos, "\nDCB (%02i-%i): Going  : %i:", __cil_tmp216, __cil_tmp218,
                         tmp___52);
#line 4722
      pos = pos + tmp___53;
      }
    }
#line 4725
    __cil_tmp219 = dcb->srb_going_list.next;
#line 4725
    __mptr___5 = (struct list_head  const  *)__cil_tmp219;
#line 4725
    __cil_tmp220 = (struct ScsiReqBlk *)0;
#line 4725
    __cil_tmp221 = & __cil_tmp220->list;
#line 4725
    __cil_tmp222 = (unsigned int )__cil_tmp221;
#line 4725
    __cil_tmp223 = (char *)__mptr___5;
#line 4725
    __cil_tmp224 = __cil_tmp223 - __cil_tmp222;
#line 4725
    srb = (struct ScsiReqBlk *)__cil_tmp224;
    {
#line 4725
    while (1) {
      while_continue___4: /* CIL Label */ ;

      {
#line 4725
      __cil_tmp225 = & dcb->srb_going_list;
#line 4725
      __cil_tmp226 = (unsigned long )__cil_tmp225;
#line 4725
      __cil_tmp227 = & srb->list;
#line 4725
      __cil_tmp228 = (unsigned long )__cil_tmp227;
#line 4725
      if (__cil_tmp228 != __cil_tmp226) {

      } else {
#line 4725
        goto while_break___4;
      }
      }
      {
#line 4726
      __cil_tmp229 = srb->cmd;
#line 4726
      tmp___55 = sprintf(pos, " %p", __cil_tmp229);
#line 4726
      pos = pos + tmp___55;
#line 4725
      __cil_tmp230 = srb->list.next;
#line 4725
      __mptr___6 = (struct list_head  const  *)__cil_tmp230;
#line 4725
      __cil_tmp231 = (struct ScsiReqBlk *)0;
#line 4725
      __cil_tmp232 = & __cil_tmp231->list;
#line 4725
      __cil_tmp233 = (unsigned int )__cil_tmp232;
#line 4725
      __cil_tmp234 = (char *)__mptr___6;
#line 4725
      __cil_tmp235 = __cil_tmp234 - __cil_tmp233;
#line 4725
      srb = (struct ScsiReqBlk *)__cil_tmp235;
      }
    }
    while_break___10: /* CIL Label */ ;
    }

    while_break___4: 
    {
#line 4727
    __cil_tmp236 = & dcb->srb_waiting_list;
#line 4727
    __cil_tmp237 = (struct list_head  const  *)__cil_tmp236;
#line 4727
    tmp___57 = list_empty(__cil_tmp237);
    }
#line 4727
    if (tmp___57) {
      {
#line 4727
      __cil_tmp238 = & dcb->srb_going_list;
#line 4727
      __cil_tmp239 = (struct list_head  const  *)__cil_tmp238;
#line 4727
      tmp___58 = list_empty(__cil_tmp239);
      }
#line 4727
      if (tmp___58) {

      } else {
        {
#line 4728
        tmp___56 = sprintf(pos, "\n");
#line 4728
        pos = pos + tmp___56;
        }
      }
    } else {
      {
#line 4728
      tmp___56 = sprintf(pos, "\n");
#line 4728
      pos = pos + tmp___56;
      }
    }
#line 4713
    __cil_tmp240 = dcb->list.next;
#line 4713
    __mptr___2 = (struct list_head  const  *)__cil_tmp240;
#line 4713
    __cil_tmp241 = (struct DeviceCtlBlk *)0;
#line 4713
    __cil_tmp242 = & __cil_tmp241->list;
#line 4713
    __cil_tmp243 = (unsigned int )__cil_tmp242;
#line 4713
    __cil_tmp244 = (char *)__mptr___2;
#line 4713
    __cil_tmp245 = __cil_tmp244 - __cil_tmp243;
#line 4713
    dcb = (struct DeviceCtlBlk *)__cil_tmp245;
  }
  while_break___8: /* CIL Label */ ;
  }

  while_break___2: 
  {
#line 4739
  *start = buffer + offset;
#line 4740
  __cil_tmp246 = acb->scsi_host;
#line 4740
  __cil_tmp247 = __cil_tmp246->host_lock;
#line 4740
  spin_unlock_irqrestore(__cil_tmp247, flags);
  }
  {
#line 4742
  __cil_tmp248 = pos - buffer;
#line 4742
  __cil_tmp249 = (off_t )__cil_tmp248;
#line 4742
  if (__cil_tmp249 < offset) {
#line 4743
    return (0);
  } else {
    {
#line 4744
    __cil_tmp250 = (off_t )length;
#line 4744
    __cil_tmp251 = pos - buffer;
#line 4744
    __cil_tmp252 = (off_t )__cil_tmp251;
#line 4744
    __cil_tmp253 = __cil_tmp252 - offset;
#line 4744
    if (__cil_tmp253 < __cil_tmp250) {
      {
#line 4745
      __cil_tmp254 = pos - buffer;
#line 4745
      __cil_tmp255 = (off_t )__cil_tmp254;
#line 4745
      __cil_tmp256 = __cil_tmp255 - offset;
#line 4745
      return ((int )__cil_tmp256);
      }
    } else {
#line 4747
      return (length);
    }
    }
  }
  }
}
}
#line 4751 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct scsi_host_template dc395x_driver_template  = 
#line 4751
     {& __this_module, "Tekram DC395(U/UW/F), DC315(U) - ASIC TRM-S1040 v2.05, 2004/03/08",
    (int (*)(struct scsi_host_template * ))0, (int (*)(struct Scsi_Host * ))0, (char const   *(*)(struct Scsi_Host * ))0,
    (int (*)(struct scsi_device *dev , int cmd , void *arg ))0, (int (*)(struct scsi_device *dev ,
                                                                         int cmd ,
                                                                         void *arg ))0,
    & dc395x_queue_command, (int (*)(struct scsi_cmnd * , void (*done)(struct scsi_cmnd * ) ))0,
    & dc395x_eh_abort, (int (*)(struct scsi_cmnd * ))0, (int (*)(struct scsi_cmnd * ))0,
    & dc395x_eh_bus_reset, (int (*)(struct scsi_cmnd * ))0, & dc395x_slave_alloc,
    (int (*)(struct scsi_device * ))0, & dc395x_slave_destroy, (int (*)(struct scsi_target * ))0,
    (void (*)(struct scsi_target * ))0, (int (*)(struct Scsi_Host * , unsigned long  ))0,
    (void (*)(struct Scsi_Host * ))0, (int (*)(struct scsi_device * , int  , int  ))0,
    (int (*)(struct scsi_device * , int  ))0, & dc395x_bios_param, (void (*)(struct scsi_device * ))0,
    & dc395x_proc_info, (enum blk_eh_timer_return (*)(struct scsi_cmnd * ))0, "dc395x",
    (struct proc_dir_entry *)0, 63, 7, (unsigned short)64, (unsigned short)0, (unsigned short)0,
    0UL, (short)16, (unsigned char)0, 0U, 0U, 0U, 0U, 0U, 0U, 0U, (struct device_attribute **)0,
    (struct device_attribute **)0, {(struct list_head *)0, (struct list_head *)0},
    0ULL};
#line 4776
static void banner_display(void) ;
#line 4776 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int banner_done  =    0;
#line 4774 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void banner_display(void) 
{ 

  {
#line 4777
  if (! banner_done) {
    {
#line 4779
    printk("<6>dc395x: %s %s\n", "Tekram DC395(U/UW/F), DC315(U) - ASIC TRM-S1040",
           "v2.05, 2004/03/08");
#line 4780
    banner_done = 1;
    }
  } else {

  }
#line 4782
  return;
}
}
#line 4798
static int dc395x_init_one(struct pci_dev *dev , struct pci_device_id  const  *id )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4798
static int dc395x_init_one(struct pci_dev *dev , struct pci_device_id  const  *id )  __attribute__((__section__(".devinit.text"),
__no_instrument_function__)) ;
#line 4798 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_init_one(struct pci_dev *dev , struct pci_device_id  const  *id ) 
{ struct Scsi_Host *scsi_host ;
  struct AdapterCtlBlk *acb ;
  unsigned long io_port_base ;
  unsigned int io_port_len ;
  unsigned int irq ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  resource_size_t __cil_tmp17 ;
  unsigned long long __cil_tmp18 ;
  resource_size_t __cil_tmp19 ;
  resource_size_t __cil_tmp20 ;
  resource_size_t __cil_tmp21 ;
  resource_size_t __cil_tmp22 ;
  resource_size_t __cil_tmp23 ;
  resource_size_t __cil_tmp24 ;
  resource_size_t __cil_tmp25 ;
  resource_size_t __cil_tmp26 ;
  resource_size_t __cil_tmp27 ;
  resource_size_t __cil_tmp28 ;
  resource_size_t __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned long *__cil_tmp31 ;
  struct device *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  void *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned long __cil_tmp39 ;

  {
#line 4801
  __cil_tmp15 = (void *)0;
#line 4801
  scsi_host = (struct Scsi_Host *)__cil_tmp15;
#line 4802
  __cil_tmp16 = (void *)0;
#line 4802
  acb = (struct AdapterCtlBlk *)__cil_tmp16;
  {
#line 4807
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4807
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4808
  banner_display();
#line 4810
  tmp___11 = (int )pci_enable_device(dev);
#line 4810
  tmp = tmp___11;
#line 4810
  tmp___7 = tmp;
  }
#line 4810
  if (tmp___7) {
    {
#line 4812
    printk("<6>dc395x: PCI Enable device failed.\n");
    }
#line 4813
    return (-19);
  } else {

  }
#line 4815
  __cil_tmp17 = dev->resource[0].start;
#line 4815
  __cil_tmp18 = __cil_tmp17 & 1152921504606846972ULL;
#line 4815
  io_port_base = (unsigned long )__cil_tmp18;
  {
#line 4816
  __cil_tmp19 = dev->resource[0].start;
#line 4816
  if (__cil_tmp19 == 0ULL) {
    {
#line 4816
    __cil_tmp20 = dev->resource[0].start;
#line 4816
    __cil_tmp21 = dev->resource[0].end;
#line 4816
    if (__cil_tmp21 == __cil_tmp20) {
#line 4816
      io_port_len = 0U;
    } else {
#line 4816
      __cil_tmp22 = dev->resource[0].start;
#line 4816
      __cil_tmp23 = dev->resource[0].end;
#line 4816
      __cil_tmp24 = __cil_tmp23 - __cil_tmp22;
#line 4816
      __cil_tmp25 = __cil_tmp24 + 1ULL;
#line 4816
      io_port_len = (unsigned int )__cil_tmp25;
    }
    }
  } else {
#line 4816
    __cil_tmp26 = dev->resource[0].start;
#line 4816
    __cil_tmp27 = dev->resource[0].end;
#line 4816
    __cil_tmp28 = __cil_tmp27 - __cil_tmp26;
#line 4816
    __cil_tmp29 = __cil_tmp28 + 1ULL;
#line 4816
    io_port_len = (unsigned int )__cil_tmp29;
  }
  }
#line 4817
  irq = dev->irq;
  {
#line 4818
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 4818
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 4821
  __cil_tmp30 = (int )11264UL;
#line 4821
  scsi_host = scsi_host_alloc(& dc395x_driver_template, __cil_tmp30);
  }
#line 4823
  if (! scsi_host) {
    {
#line 4824
    printk("<6>dc395x: scsi_host_alloc failed\n");
    }
#line 4825
    goto fail;
  } else {

  }
  {
#line 4827
  __cil_tmp31 = & scsi_host->hostdata[0];
#line 4827
  acb = (struct AdapterCtlBlk *)__cil_tmp31;
#line 4828
  acb->scsi_host = scsi_host;
#line 4829
  acb->dev = dev;
#line 4832
  tmp___8 = adapter_init(acb, io_port_base, io_port_len, irq);
  }
#line 4832
  if (tmp___8) {
    {
#line 4833
    printk("<6>dc395x: adapter init failed\n");
    }
#line 4834
    goto fail;
  } else {

  }
  {
#line 4837
  pci_set_master(dev);
#line 4840
  __cil_tmp32 = & dev->dev;
#line 4840
  tmp___12 = (int )scsi_add_host(scsi_host, __cil_tmp32);
#line 4840
  tmp___10 = tmp___12;
#line 4840
  tmp___9 = tmp___10;
  }
#line 4840
  if (tmp___9) {
    {
#line 4841
    printk("<3>dc395x: scsi_add_host failed\n");
    }
#line 4842
    goto fail;
  } else {

  }
  {
#line 4844
  __cil_tmp33 = (void *)scsi_host;
#line 4844
  pci_set_drvdata(dev, __cil_tmp33);
#line 4845
  scsi_scan_host(scsi_host);
  }
#line 4847
  return (0);
  fail: 
  {
#line 4850
  __cil_tmp34 = (void *)0;
#line 4850
  __cil_tmp35 = (unsigned long )__cil_tmp34;
#line 4850
  __cil_tmp36 = (unsigned long )acb;
#line 4850
  if (__cil_tmp36 != __cil_tmp35) {
    {
#line 4851
    adapter_uninit(acb);
    }
  } else {

  }
  }
  {
#line 4852
  __cil_tmp37 = (void *)0;
#line 4852
  __cil_tmp38 = (unsigned long )__cil_tmp37;
#line 4852
  __cil_tmp39 = (unsigned long )scsi_host;
#line 4852
  if (__cil_tmp39 != __cil_tmp38) {
    {
#line 4853
    scsi_host_put(scsi_host);
    }
  } else {

  }
  }
  {
#line 4854
  pci_disable_device(dev);
  }
#line 4855
  return (-19);
}
}
#line 4865
static void dc395x_remove_one(struct pci_dev *dev )  __attribute__((__section__(".devexit.text"),
__no_instrument_function__)) ;
#line 4865
static void dc395x_remove_one(struct pci_dev *dev )  __attribute__((__section__(".devexit.text"),
__no_instrument_function__)) ;
#line 4865 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void dc395x_remove_one(struct pci_dev *dev ) 
{ struct Scsi_Host *scsi_host ;
  void *tmp___7 ;
  struct AdapterCtlBlk *acb ;
  unsigned long *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 4867
  tmp___7 = pci_get_drvdata(dev);
#line 4867
  scsi_host = (struct Scsi_Host *)tmp___7;
#line 4868
  __cil_tmp5 = & scsi_host->hostdata[0];
#line 4868
  acb = (struct AdapterCtlBlk *)__cil_tmp5;
  }
  {
#line 4870
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4870
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4872
  scsi_remove_host(scsi_host);
#line 4873
  adapter_uninit(acb);
#line 4874
  pci_disable_device(dev);
#line 4875
  scsi_host_put(scsi_host);
#line 4876
  __cil_tmp6 = (void *)0;
#line 4876
  pci_set_drvdata(dev, __cil_tmp6);
  }
#line 4877
  return;
}
}
#line 4880 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct pci_device_id dc395x_pci_table[1]  = {      {(__u32 )7649, (__u32 )913, (__u32 )(~ 0), (__u32 )(~ 0), 0U, 0U, 0UL}};
#line 4889
extern struct pci_device_id  const  __mod_pci_device_table  __attribute__((__unused__,
__alias__("dc395x_pci_table"))) ;
#line 4892 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static struct pci_driver dc395x_driver  = 
#line 4892
     {{(struct list_head *)0, (struct list_head *)0}, "dc395x", (struct pci_device_id  const  *)(dc395x_pci_table),
    & dc395x_init_one, & dc395x_remove_one, (int (*)(struct pci_dev *dev , pm_message_t state ))0,
    (int (*)(struct pci_dev *dev , pm_message_t state ))0, (int (*)(struct pci_dev *dev ))0,
    (int (*)(struct pci_dev *dev ))0, (void (*)(struct pci_dev *dev ))0, (struct pci_error_handlers *)0,
    {(char const   *)0, (struct bus_type *)0, (struct module *)0, (char const   *)0,
     (_Bool)0, (struct of_device_id  const  *)0, (int (*)(struct device *dev ))0,
     (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0, (int (*)(struct device *dev ,
                                                                                 pm_message_t state ))0,
     (int (*)(struct device *dev ))0, (struct attribute_group  const  **)0, (struct dev_pm_ops  const  *)0,
     (struct driver_private *)0}, {{{{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0,
                                                                {(struct lock_class *)0,
                                                                 (struct lock_class *)0},
                                                                (char const   *)0,
                                                                0, 0UL}}}}, {(struct list_head *)0,
                                                                             (struct list_head *)0}}};
#line 4905
static int dc395x_module_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 4905
static int dc395x_module_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 4905 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int dc395x_module_init(void) 
{ int tmp___7 ;
  int tmp ;
  int tmp___8 ;

  {
  {
#line 4907
  tmp___8 = (int )__pci_register_driver(& dc395x_driver, & __this_module, "dc395x");
#line 4907
  tmp = tmp___8;
#line 4907
  tmp___7 = tmp;
  }
#line 4907
  return (tmp___7);
}
}
#line 4914
static void dc395x_module_exit(void)  __attribute__((__section__(".exit.text"), __no_instrument_function__)) ;
#line 4914
static void dc395x_module_exit(void)  __attribute__((__section__(".exit.text"), __no_instrument_function__)) ;
#line 4914 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static void dc395x_module_exit(void) 
{ 

  {
  {
#line 4916
  pci_unregister_driver(& dc395x_driver);
  }
#line 4917
  return;
}
}
#line 4920 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
int init_module(void) 
{ int tmp___7 ;

  {
  {
#line 4920
  tmp___7 = dc395x_module_init();
  }
#line 4920
  return (tmp___7);
}
}
#line 4921 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
void cleanup_module(void) 
{ 

  {
  {
#line 4921
  dc395x_module_exit();
  }
#line 4921
  return;
}
}
#line 4923 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_author4923[46]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 4923
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'C', 
        (char const   )'.',      (char const   )'L',      (char const   )'.',      (char const   )' ', 
        (char const   )'H',      (char const   )'u',      (char const   )'a',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'/',      (char const   )' ', 
        (char const   )'E',      (char const   )'r',      (char const   )'i',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'C',      (char const   )'h', 
        (char const   )'e',      (char const   )'n',      (char const   )' ',      (char const   )'/', 
        (char const   )' ',      (char const   )'K',      (char const   )'u',      (char const   )'r', 
        (char const   )'t',      (char const   )' ',      (char const   )'G',      (char const   )'a', 
        (char const   )'r',      (char const   )'l',      (char const   )'o',      (char const   )'f', 
        (char const   )'f',      (char const   )'\000'};
#line 4924 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_description4924[104]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 4924
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'S',      (char const   )'C',      (char const   )'S',      (char const   )'I', 
        (char const   )' ',      (char const   )'h',      (char const   )'o',      (char const   )'s', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'d', 
        (char const   )'a',      (char const   )'p',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'d',      (char const   )'r', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'T',      (char const   )'e',      (char const   )'k', 
        (char const   )'r',      (char const   )'a',      (char const   )'m',      (char const   )' ', 
        (char const   )'T',      (char const   )'R',      (char const   )'M',      (char const   )'-', 
        (char const   )'S',      (char const   )'1',      (char const   )'0',      (char const   )'4', 
        (char const   )'0',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'s',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'a',      (char const   )'p', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )':',      (char const   )' ',      (char const   )'T',      (char const   )'e', 
        (char const   )'k',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )' ',      (char const   )'D',      (char const   )'C',      (char const   )'3', 
        (char const   )'9',      (char const   )'5',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'D', 
        (char const   )'C',      (char const   )'3',      (char const   )'1',      (char const   )'5', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'r', 
        (char const   )'i',      (char const   )'e',      (char const   )'s',      (char const   )'\000'};
#line 4925 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static char const   __mod_license4925[12]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 4925
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
#line 4943
void ldv_check_final_state(void)  __attribute__((__ldv_model__)) ;
#line 4946
extern void ldv_check_return_value(int res ) ;
#line 4949
extern void ldv_initialize(void) ;
#line 4952
extern int nondet_int(void) ;
#line 4955 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
int LDV_IN_INTERRUPT  ;
#line 5806 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
static int res_dc395x_init_one_106  ;
#line 4958 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/drivers/scsi/dc395x.c.common.c"
void main(void) 
{ struct Scsi_Host *var_group1 ;
  char *var_dc395x_proc_info_104_p1 ;
  char **var_dc395x_proc_info_104_p2 ;
  off_t var_dc395x_proc_info_104_p3 ;
  int var_dc395x_proc_info_104_p4 ;
  int var_dc395x_proc_info_104_p5 ;
  struct scsi_device *var_group2 ;
  struct block_device *var_group3 ;
  sector_t var_dc395x_bios_param_24_p2 ;
  int *var_dc395x_bios_param_24_p3 ;
  struct scsi_cmnd *var_group4 ;
  struct pci_dev *var_group5 ;
  struct pci_device_id  const  *var_dc395x_init_one_106_p1 ;
  int var_dc395x_interrupt_38_p0 ;
  void *var_dc395x_interrupt_38_p1 ;
  unsigned long var_waiting_timeout_20_p0 ;
  int tmp___7 ;
  int ldv_s_dc395x_driver_pci_driver ;
  int tmp___8 ;
  int tmp___9 ;
  int __cil_tmp21 ;

  {
  {
#line 6174
  LDV_IN_INTERRUPT = 1;
#line 6183
  ldv_initialize();
#line 6302
  tmp___7 = dc395x_module_init();
  }
#line 6302
  if (tmp___7) {
#line 6303
    goto ldv_final;
  } else {

  }
#line 6306
  ldv_s_dc395x_driver_pci_driver = 0;
  {
#line 6313
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 6313
    tmp___9 = nondet_int();
    }
#line 6313
    if (tmp___9) {

    } else {
      {
#line 6313
      __cil_tmp21 = ldv_s_dc395x_driver_pci_driver == 0;
#line 6313
      if (! __cil_tmp21) {

      } else {
#line 6313
        goto while_break;
      }
      }
    }
    {
#line 6317
    tmp___8 = nondet_int();
    }
#line 6319
    if (tmp___8 == 0) {
#line 6319
      goto case_0;
    } else
#line 6448
    if (tmp___8 == 1) {
#line 6448
      goto case_1;
    } else
#line 6576
    if (tmp___8 == 2) {
#line 6576
      goto case_2;
    } else
#line 6707
    if (tmp___8 == 3) {
#line 6707
      goto case_3;
    } else
#line 6838
    if (tmp___8 == 4) {
#line 6838
      goto case_4;
    } else
#line 6969
    if (tmp___8 == 5) {
#line 6969
      goto case_5;
    } else
#line 7100
    if (tmp___8 == 6) {
#line 7100
      goto case_6;
    } else
#line 7232
    if (tmp___8 == 7) {
#line 7232
      goto case_7;
    } else
#line 7360
    if (tmp___8 == 8) {
#line 7360
      goto case_8;
    } else
#line 7491
    if (tmp___8 == 9) {
#line 7491
      goto case_9;
    } else {
#line 7622
      goto switch_default;
#line 6317
      if (0) {
        case_0: 
        {
#line 6440
        dc395x_proc_info(var_group1, var_dc395x_proc_info_104_p1, var_dc395x_proc_info_104_p2,
                         var_dc395x_proc_info_104_p3, var_dc395x_proc_info_104_p4,
                         var_dc395x_proc_info_104_p5);
        }
#line 6447
        goto switch_break;
        case_1: 
        {
#line 6518
        dc395x_bios_param(var_group2, var_group3, var_dc395x_bios_param_24_p2, var_dc395x_bios_param_24_p3);
        }
#line 6575
        goto switch_break;
        case_2: 
        {
#line 6688
        dc395x_slave_alloc(var_group2);
        }
#line 6706
        goto switch_break;
        case_3: 
        {
#line 6819
        dc395x_slave_destroy(var_group2);
        }
#line 6837
        goto switch_break;
        case_4: 
        {
#line 6913
        dc395x_eh_abort(var_group4);
        }
#line 6968
        goto switch_break;
        case_5: 
        {
#line 7044
        dc395x_eh_bus_reset(var_group4);
        }
#line 7099
        goto switch_break;
        case_6: 
#line 7103
        if (ldv_s_dc395x_driver_pci_driver == 0) {
          {
#line 7221
          res_dc395x_init_one_106 = dc395x_init_one(var_group5, var_dc395x_init_one_106_p1);
#line 7222
          ldv_check_return_value(res_dc395x_init_one_106);
          }
#line 7223
          if (res_dc395x_init_one_106) {
#line 7224
            goto ldv_module_exit;
          } else {

          }
#line 7225
          ldv_s_dc395x_driver_pci_driver = 0;
        } else {

        }
#line 7231
        goto switch_break;
        case_7: 
        {
#line 7235
        LDV_IN_INTERRUPT = 2;
#line 7318
        dc395x_interrupt(var_dc395x_interrupt_38_p0, var_dc395x_interrupt_38_p1);
#line 7353
        LDV_IN_INTERRUPT = 1;
        }
#line 7359
        goto switch_break;
        case_8: ;
#line 7490
        goto switch_break;
        case_9: 
        {
#line 7561
        waiting_timeout(var_waiting_timeout_20_p0);
        }
#line 7621
        goto switch_break;
        switch_default: 
#line 7622
        goto switch_break;
      } else {
        switch_break: ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
  ldv_module_exit: 
  {
#line 7747
  dc395x_module_exit();
  }
  ldv_final: 
  {
#line 7750
  ldv_check_final_state();
  }
#line 7753
  return;
}
}
#line 5 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/engine-blast-assert.h"
void ldv_blast_assert(void) 
{ 

  {
  ERROR: 
#line 6
  goto ERROR;
}
}
#line 7 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/engine-blast.h"
extern void *ldv_undefined_pointer(void) ;
#line 1332 "include/linux/usb.h"
struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags )  __attribute__((__ldv_model__)) ;
#line 1333
void usb_free_urb(struct urb *urb )  __attribute__((__ldv_model__)) ;
#line 1377
void *usb_alloc_coherent(struct usb_device *dev , size_t size , gfp_t mem_flags ,
                         dma_addr_t *dma )  __attribute__((__ldv_model__)) ;
#line 1379
void usb_free_coherent(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma )  __attribute__((__ldv_model__)) ;
#line 10 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
void ldv_assume_stop(void)  __attribute__((__ldv_model_inline__)) ;
#line 22
void ldv_assume_stop(void)  __attribute__((__ldv_model_inline__)) ;
#line 22 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
void ldv_assume_stop(void) 
{ 

  {
  LDV_STOP: 
#line 23
  goto LDV_STOP;
}
}
#line 29 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
int ldv_urb_state  =    0;
#line 31 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
int ldv_coherent_state  =    0;
#line 62
void *usb_alloc_coherent(struct usb_device *dev , size_t size , gfp_t mem_flags ,
                         dma_addr_t *dma )  __attribute__((__ldv_model__)) ;
#line 62 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
void *usb_alloc_coherent(struct usb_device *dev , size_t size , gfp_t mem_flags ,
                         dma_addr_t *dma ) 
{ void *arbitrary_memory ;
  void *tmp___7 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp___7 = ldv_undefined_pointer();
#line 64
    arbitrary_memory = tmp___7;
    }
#line 64
    if (! arbitrary_memory) {
#line 64
      return ((void *)0);
    } else {

    }
#line 64
    ldv_coherent_state = ldv_coherent_state + 1;
#line 64
    return (arbitrary_memory);
#line 64
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 65
  return ((void *)0);
}
}
#line 68
void usb_free_coherent(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma )  __attribute__((__ldv_model__)) ;
#line 68 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
void usb_free_coherent(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) 
{ void *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 70
    __cil_tmp5 = (void *)0;
#line 70
    __cil_tmp6 = (unsigned long )__cil_tmp5;
#line 70
    __cil_tmp7 = (unsigned long )addr;
#line 70
    __cil_tmp8 = __cil_tmp7 != __cil_tmp6;
#line 70
    if (! __cil_tmp8) {
      {
#line 70
      ldv_assume_stop();
      }
    } else {

    }
    }
#line 70
    if (addr) {
#line 70
      if (ldv_coherent_state >= 1) {

      } else {
        {
#line 70
        ldv_blast_assert();
        }
      }
#line 70
      ldv_coherent_state = ldv_coherent_state - 1;
    } else {

    }
#line 70
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 71
  return;
}
}
#line 74
struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags )  __attribute__((__ldv_model__)) ;
#line 74 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) 
{ void *arbitrary_memory ;
  void *tmp___7 ;
  void *__cil_tmp5 ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    tmp___7 = ldv_undefined_pointer();
#line 75
    arbitrary_memory = tmp___7;
    }
#line 75
    if (! arbitrary_memory) {
      {
#line 75
      __cil_tmp5 = (void *)0;
#line 75
      return ((struct urb *)__cil_tmp5);
      }
    } else {

    }
#line 75
    ldv_urb_state = ldv_urb_state + 1;
#line 75
    return ((struct urb *)arbitrary_memory);
#line 75
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 76
  return ((struct urb *)0);
}
}
#line 79
void usb_free_urb(struct urb *urb )  __attribute__((__ldv_model__)) ;
#line 79 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
void usb_free_urb(struct urb *urb ) 
{ struct urb *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 80
    __cil_tmp2 = (struct urb *)0;
#line 80
    __cil_tmp3 = (unsigned long )__cil_tmp2;
#line 80
    __cil_tmp4 = (unsigned long )urb;
#line 80
    __cil_tmp5 = __cil_tmp4 != __cil_tmp3;
#line 80
    if (! __cil_tmp5) {
      {
#line 80
      ldv_assume_stop();
      }
    } else {

    }
    }
#line 80
    if (urb) {
#line 80
      if (ldv_urb_state >= 1) {

      } else {
        {
#line 80
        ldv_blast_assert();
        }
      }
#line 80
      ldv_urb_state = ldv_urb_state - 1;
    } else {

    }
#line 80
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 81
  return;
}
}
#line 84
void ldv_check_final_state(void)  __attribute__((__ldv_model__)) ;
#line 84 "/anthill/stuff/tacas-comp/work/current--X--drivers/scsi/dc395x.ko--X--bulklinux-3.0.1--X--68_1/linux-3.0.1/csd_deg_dscv/11/dscv_tempdir/dscv/ri/68_1/kernel-rules/files/model0068.c"
void ldv_check_final_state(void) 
{ 

  {
#line 86
  if (ldv_urb_state == 0) {

  } else {
    {
#line 86
    ldv_blast_assert();
    }
  }
#line 88
  if (ldv_coherent_state == 0) {

  } else {
    {
#line 88
    ldv_blast_assert();
    }
  }
#line 89
  return;
}
}
